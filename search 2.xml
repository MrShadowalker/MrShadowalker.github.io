<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>区块链系列——密码学与安全技术</title>
    <url>/articles/Blockchain-Cryptography-and-Network-Security.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="密码学与安全技术"><a href="#密码学与安全技术" class="headerlink" title="密码学与安全技术"></a>密码学与安全技术</h1><p>工程领域从来没有黑科技；密码学不仅是工程。</p>
<p>密码学相关的安全技术在整个信息技术领域的重要地位无需多言。如果没有现代密码学和信息安全的研究成果，人类社会根本无法进入信息时代。区块链技术大量依赖了密码学和安全技术的研究成果。</p>
<p>实际上，密码学和安全领域所涉及的知识体系十分繁杂，本章将介绍密码学领域中跟区块链相关的一些基础知识，包括Hash算法与数字摘要、加密算法、数字签名、数字证书、PKI 体系、Merkle 树、布隆过滤器、同态加密等。读者通过阅读本章可以了解如何使用这些技术保护信息的机密性、完整性、认证性和不可抵赖性。</p>
<span id="more"></span>

<h2 id="Hash-算法与数字摘要"><a href="#Hash-算法与数字摘要" class="headerlink" title="Hash 算法与数字摘要"></a>Hash 算法与数字摘要</h2><h3 id="Hash-定义"><a href="#Hash-定义" class="headerlink" title="Hash 定义"></a>Hash 定义</h3><p>Hash（哈希或散列）算法是非常基础也非常重要的计算机算法，它能将任意长度的二进制明文串映射为较短的（通常是固定长度的）二进制串（Hash 值），并且不同的明文很难映射为相同的 Hash 值。</p>
<p>例如计算一段话 <code>hello blockchain world，this is yeasy@github</code> 的 SHA-256 Hash 值。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello blockchain world, this is yeasy@github&quot;</span>|shasum -a 256</span><br><span class="line">db8305d71a9f2f90a3e118a9b49a4c381d2b80cf7bcef81930f30ab1832a3c90</span><br></pre></td></tr></table></figure>

<p>这意味着对于某个文件，无需查看其内容，只要其 SHA-256 Hash 计算后结果同样为<code>db8305d71a9f2f90a3e118a9b49a4c381d2b80cf7bcef81930f30ab1832a3c90</code>，则说明文件内容极大概率上就是 <code>hello blockchain world，this is yeasy@github</code>。</p>
<p>Hash 值在应用中又常被称为指纹（fingerprint）或摘要（digest）。Hash 算法的核心思想也经常被应用到基于内容的编址或命名算法中。</p>
<p>一个优秀的 Hash 算法将能实现如下功能：</p>
<ul>
<li><p>正向快速：给定明文和 Hash 算法，在有限时间和有限资源内能计算得到 Hash 值；</p>
</li>
<li><p>逆向困难：给定（若干）Hash 值，在有限时间内很难（基本不可能）逆推出明文；</p>
</li>
<li><p>输入敏感：原始输入信息发生任何改变，新产生的 Hash 值都应该出现很大不同；</p>
</li>
<li><p>冲突避免：很难找到两段内容不同的明文，使得它们的 Hash 值一致（发生碰撞）。</p>
</li>
</ul>
<p>冲突避免有时候又称为“抗碰撞性”，分为“弱抗碰撞性”和“强抗碰撞性”。如果给定明文前提下，无法找到与之碰撞的其他明文，则算法具有“弱抗碰撞性”；如果无法找到任意两个发生 Hash 碰撞的明文，则称算法具有“强抗碰撞性”。</p>
<p>很多场景下，也往往要求算法对于任意长的输入内容，可以输出定长的 Hash 值结果。</p>
<h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><p>目前常见的 Hash 算法包括 MD5 和 SHA 系列算法。</p>
<ul>
<li><p>MD4（RFC 1320）是 MIT 的 Ronald L.Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。其输出为 128 位。MD4 已被证明不够安全。</p>
</li>
<li><p>MD5（RFC 1321）是 Rivest 于 1991 年对 MD4 的改进版本。它对输入仍以 512 位进行分组，其输出是 128 位。MD5 比 MD4 更加安全，但过程更加复杂，计算速度要慢一点。MD5 已被证明不具备“强抗碰撞性”。</p>
</li>
<li><p>SHA（Secure Hash Algorithm）并非一个算法，而是一个 Hash 函数族。NIST（National Institute of Standards and Technology）于 1993 年发布其首个实现。目前知名的 SHA-1 算法在 1995 年面世，它的输出为长度 160 位的 Hash 值，抗穷举性更好。SHA-1 设计时模仿了 MD4 算法，采用了类似原理。SHA-1 已被证明不具备“强抗碰撞性”。</p>
</li>
</ul>
<p>为了提高安全性，NIST 还设计出了 SHA-224、SHA-256、SHA-384 和 SHA-512 算法（统称为SHA-2），跟 SHA-1 算法原理类似。SHA-3 相关算法也已被提出。</p>
<p>目前，MD5 和 SHA1 已经被破解，一般推荐至少使用 SHA2-256 或更安全的算法。</p>
<p>提示：MD5 是一个经典的 Hash 算法，但和 SHA-1 算法一起都被认为安全性已不足应用于商业场景。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Hash 算法一般都是计算敏感型的。意味着计算资源是瓶颈，主频越高的 CPU 运行 Hash 算法的速度也越快。因此可以通过硬件加速来提升 Hash 计算的吞吐量。例如采用 FPGA 来计算 MD5 值，可以轻易达到数十 Gbps 的吞吐量。</p>
<p>也有一些 Hash 算法不是计算敏感型的。例如 scrypt 算法，计算过程需要大量的内存资源，节点不能通过简单地增加更多 CPU 来获得 Hash 性能的提升。这样的 Hash 算法经常用在避免算力攻击的场景。</p>
<h3 id="数字摘要"><a href="#数字摘要" class="headerlink" title="数字摘要"></a>数字摘要</h3><p>顾名思义，数字摘要是对数字内容进行 Hash 运算，获取唯一的摘要值来指代原始完整的数字内容。数字摘要是 Hash 算法最重要的一个用途。利用 Hash 函数的抗碰撞性特点，数字摘要可以解决确保内容未被篡改过的问题。</p>
<p>细心的读者可能会注意到，从网站下载软件或文件时，有时会提供一个相应的数字摘要值。用户下载原始文件后可以在本地自行计算摘要值，并与提供的摘要值进行比对，可检查文件内容是否被篡改过。</p>
<h3 id="Hash-攻击与防护"><a href="#Hash-攻击与防护" class="headerlink" title="Hash 攻击与防护"></a>Hash 攻击与防护</h3><p>Hash 算法并不是一种加密算法，不能用于对信息的保护。但 Hash 算法常用于对口令的保存上。例如用户登录网站需要通过用户名和密码来进行验证。如果网站后台直接保存用户的口令明文，一旦数据库发生泄露后果不堪设想。大量用户倾向于在多个网站选用相同或关联的口令。</p>
<p>利用 Hash 的特性，后台可以仅保存口令的 Hash 值，这样每次比对 Hash 值一致，则说明输入的口令正确。即便数据库泄露了，也无法从 Hash 值还原回口令，只有进行穷举测试。</p>
<p>然而，由于有时用户设置口令的强度不够，只是一些常见的简单字符串，如 password、123456 等。有人专门搜集了这些常见口令，计算对应的 Hash 值，制作成字典。这样通过 Hash 值可以快速反查到原始口令。这一类型以空间换时间的攻击方法包括字典攻击和彩虹表攻击（只保存一条 Hash 链的首尾值，相对字典攻击可以节省存储空间）等。</p>
<p>为了防范这一类攻击，一般采用加盐（salt）的方法。保存的不是口令明文的 Hash 值，而是口令明文再加上一段随机字符串（即“盐”）之后的 Hash 值。Hash 结果和“盐”分别存放在不同的地方，这样只要不是两者同时泄露，攻击者就很难破解了。</p>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>加解密算法是密码学的核心技术，从设计理念上可以分为两大基本类型，如下表所示。 </p>
<p><img src="Blockchain-Cryptography-and-Network-Security/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt="加解密算法的类型">
　 </p>
<h3 id="加解密系统基本组成"><a href="#加解密系统基本组成" class="headerlink" title="加解密系统基本组成"></a>加解密系统基本组成</h3><p>现代加解密系统的典型组件一般包括：加解密算法、加密密钥、解密密钥。其中，加解密算法自身是固定不变的，并且一般是公开可见的；密钥则是最关键的信息，需要安全地保存起来，甚至通过特殊硬件进行保护。一般来说，对同一种算法，密钥需要按照特定算法每次加密前随机生成，长度越长，则加密强度越大。加解密的基本过程如下图所示。 </p>
<p><img src="Blockchain-Cryptography-and-Network-Security/%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.png" alt="加解密基本过程"></p>
<p>加密过程中，通过加密算法和加密密钥，对明文进行加密，获得密文。</p>
<p>解密过程中，通过解密算法和解密密钥，对密文进行解密，获得明文。</p>
<p>根据加解密过程中所使用的密钥是否相同，算法可以分为对称加密（symmetric cryptography，又称公共密钥加密，common-key cryptography）和非对称加密（asymmetric cryptography，又称公钥加密，public-key cryptography）。两种模式适用于不同的需求，恰好形成互补。某些时候可以组合使用，形成混合加密机制。</p>
<p>并非所有加密算法的安全性都可以从数学上得到证明。公认的高强度的加密算法和实现往往经过长时间各方面充分实践论证后，才被大家所认可，但也不代表其绝对不存在漏洞。因此，自行设计和发明未经过大规模验证的加密算法是一种不太明智的行为。即便不公开算法加密过程，也很容易被攻破，无法在安全性上得到保障。</p>
<p>实际上，密码学实现的安全往往是通过算法所依赖的数学问题来提供，而并非通过对算法的实现过程进行保密。</p>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密算法，顾名思义，加密和解密过程的密钥是相同的。该类算法优点是加解密效率（速度快，空间占用小）和加密强度都很高。缺点是参与方都需要提前持有密钥，一旦有人泄露则安全性被破坏；另外如何在不安全通道中提前分发密钥也是个问题，需要借助 Diffie–Hellman 协议或非对称加密方式来实现。</p>
<p>对称密码从实现原理上可以分为两种：分组密码和序列密码。前者将明文切分为定长数据块作为基本加密单位，应用最为广泛。后者则每次只对一个字节或字符进行加密处理，且密码不断变化，只用在一些特定领域，如数字媒介的加密等。</p>
<p>分组对称加密代表算法包括 DES、3DES、AES、IDEA 等：</p>
<ul>
<li><p>DES（Data Encryption Standard）：经典的分组加密算法，1977 年由美国联邦信息处理标准（FIPS）采用 FIPS-46-3，将 64 位明文加密为 64 位的密文，其密钥长度为 64 位（包含 8 位校验位）。现在已经很容易被暴力破解；<a href="http://blog.csdn.net/zyhlwzy/article/details/77948137">详见</a></p>
</li>
<li><p>3DES：三重DES操作，加密→解密→加密，处理过程和加密强度优于 DES，但现在也被认为不够安全；</p>
</li>
<li><p>AES（Advanced Encryption Standard）：由美国国家标准研究所（NIST）采用，取代 DES 成为对称加密实现的标准，1997～2000 年 NIST 从 15 个候选算法中评选 Rijndael 算法（由比利时密码学家 Joan Daemon 和 Vincent Rijmen 发明）作为 AES，标准为 FIPS-197。AES 也是分组算法，分组长度为 128、192、256 位三种。AES 的优势在于处理速度快，整个过程可以用数学描述，目前尚未有有效的破解手段；<a href="http://blog.csdn.net/zyhlwzy/article/details/77948165">详见</a></p>
</li>
<li><p>IDEA（International Data Encryption Algorithm）：1991 年由密码学家 James Massey 与来学嘉联合提出。设计类似于 3DES，密钥长度增加到 128 位，具有更好的加密强度。</p>
</li>
<li><p>序列密码，又称流密码。1949 年，Claude Elwood Shannon（信息论创始人）首次证明，要实现绝对安全的完善保密性（perfect secrecy），可以通过“一次性密码本”的对称加密处理。即通信双方每次使用跟明文等长的随机密钥串对明文进行加密处理。序列密码采用了类似的思想，每次通过伪随机数生成器来生成伪随机密钥串。代表算法包括RC4等。</p>
</li>
</ul>
<p>对称加密算法适用于大量数据的加解密过程；不能用于签名场景；并且往往需要提前分发好密钥。</p>
<p>注意：分组加密每次只能处理固定长度的明文，因此对于过长的内容需要采用一定模式进行分割处理，《实用密码学》一书中推荐使用密文分组链（Cipher Block Chain，CBC）、计数器（Counter，CTR）等模式。</p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>非对称加密是现代密码学历史上一项伟大的发明，可以很好地解决对称加密中提前分发密钥的问题。</p>
<p>顾名思义，非对称加密算法中，加密密钥和解密密钥是不同的，分别称为公钥（public key）和私钥（private key）。私钥一般需要通过随机数算法生成，公钥可以根据私钥生成。公钥一般是公开的，他人可获取的；私钥一般是个人持有，他人不能获取。</p>
<p>非对称加密算法的优点是公私钥分开，不安全通道也可使用。缺点是处理速度（特别是生成密钥和解密过程）往往比较慢，一般比对称加解密算法慢 2～3 个数量级；同时加密强度也往往不如对称加密算法。</p>
<p>非对称加密算法的安全性往往需要基于数学问题来保障，目前主要有基于大数质因子分解、离散对数、椭圆曲线等经典数学难题进行保护。</p>
<p>代表算法包括：RSA、ElGamal、椭圆曲线（Elliptic Curve Crytosystems，ECC）、SM2 等系列算法。</p>
<ul>
<li><p>RSA：经典的公钥算法，1978 年由 Ron Rivest、Adi Shamir、Leonard Adleman 共同提出，三人于 2002 年因此获得图灵奖。算法利用了对大数进行质因子分解困难的特性，但目前还没有数学证明两者难度等价，或许存在未知算法在不进行大数分解的前提下解密；<a href="http://blog.csdn.net/zyhlwzy/article/details/77948195">详见</a></p>
</li>
<li><p>Diffie-Hellman 密钥交换：基于离散对数无法快速求解，可以在不安全的通道上，双方协商一个公共密钥；</p>
</li>
<li><p>ElGamal：由 Taher ElGamal 设计，利用了模运算下求离散对数困难的特性。被应用在 PGP 等安全工具中；</p>
</li>
<li><p>椭圆曲线算法（Elliptic Curve Cryptography，ECC）：现代备受关注的算法系列，基于对椭圆曲线上特定点进行特殊乘法逆运算难以计算的特性。最早在1985年由Neal Koblitz和Victor Miller分别独立提出。ECC系列算法一般被认为具备较高的安全性，但加解密计算过程往往比较费时；</p>
</li>
<li><p>SM2（ShangMi 2）：国家商用密码算法，由国家密码管理局于2010年12月17日发布，同样基于椭圆曲线算法，加密强度优于RSA系列算法。</p>
</li>
</ul>
<p>非对称加密算法一般适用于签名场景或密钥协商，但不适于大量数据的加解密。</p>
<p>目前普遍认为RSA类算法可能在不远的将来被破解，一般推荐可采用安全强度更高的椭圆曲线系列算法。</p>
<h3 id="选择明文攻击"><a href="#选择明文攻击" class="headerlink" title="选择明文攻击"></a>选择明文攻击</h3><p>在非对称加密中，由于公钥是公开可以获取的，因此任何人都可以给定明文，获取对应的密文，这就带来选择明文攻击的风险。</p>
<p>为了规避这种风险，现有的非对称加密算法（如RSA、ECC）都引入了一定的保护机制。对同样的明文使用同样密钥进行多次加密，得到的结果完全不同，这就避免了选择明文攻击的破坏。</p>
<p>在实现上可以有多种思路。一种是对明文先进行变形，添加随机的字符串或标记，再对添加后结果进行处理。另外一种是先用随机生成的临时密钥对明文进行对称加密，然后再对对称密钥进行加密，即混合利用多种加密机制。</p>
<h3 id="混合加密机制"><a href="#混合加密机制" class="headerlink" title="混合加密机制"></a>混合加密机制</h3><p>混合加密机制同时结合了对称加密和非对称加密的优点。</p>
<p>先用计算复杂度高的非对称加密协商出一个临时的对称加密密钥（也称为会话密钥，一般相对所加密内容来说要短得多），然后双方再通过对称加密算法对传递的大量数据进行快速的加解密处理。</p>
<p>典型的应用案例是现在大家常用的 HTTPS 协议。HTTPS 协议正在替换掉传统的不安全的 HTTP 协议，成为最普遍的 Web 通信协议。</p>
<p>HTTPS 在传统的 HTTP 层和 TCP 层之间通过引入 Transport Layer Security/Secure Socket Layer（TLS/SSL）加密层来实现可靠的传输。</p>
<p>SSL 协议最早是 Netscape 于 1994 年设计出来实现早期 HTTPS 的方案，SSL 3.0 及之前版本存在漏洞，被认为不够安全。TLS 协议是 IETF 基于 SSL 协议提出的安全标准，目前最新的版本为 1.2（2008年发布）。推荐使用的版本号至少为 TLS 1.0，对应到 SSL 3.1版本。除了 Web 服务外，TLS 协议也广泛应用于 Email、实时消息、音视频通话等领域。</p>
<p>采用 HTTPS 建立安全连接（TLS握手协商过程）的基本步骤如下（可参见图5-2）：</p>
<p><img src="Blockchain-Cryptography-and-Network-Security/TLS%E6%8F%A1%E6%89%8B%E5%8D%8F%E5%95%86%E8%BF%87%E7%A8%8B.png" alt="TLS握手协商过程"></p>
<p>客户端浏览器发送信息到服务器，包括随机数 R1、支持的加密算法类型、协议版本、压缩算法等。注意该过程为明文。<br>服务端返回信息，包括随机数 R2、选定加密算法类型、协议版本以及服务器证书。注意该过程为明文。<br>浏览器检查带有该网站公钥的证书。该证书需要由第三方CA来签发，浏览器和操作系统会预置权威 CA 的根证书。如果证书被篡改作假（中间人攻击），很容易通过 CA 的证书验证出来。<br>如果证书没问题，则客户端用服务端证书中的公钥加密随机数 R3（又叫 Pre-MasterSecret），发送给服务器。此时，只有客户端和服务器都拥有 R1、R2 和 R3 信息，基于随机数 R1、R2 和 R3，双方通过伪随机数函数来生成共同的对称会话密钥 MasterSecret。<br>后续客户端和服务端的通信都通过对称加密算法（如AES）进行保护。<br>可以看出，该过程的主要功能是在防止中间人窃听和篡改的前提下完成会话密钥的协商。为了保障前向安全性（perfect forward secrecy），TLS 对每个会话连接都可以生成不同的密钥，避免某次会话密钥泄露之后影响了其他会话连接的安全性。需要注意，TLS 协商过程支持加密算法方案较多，要合理地选择安全强度高的算法，如 DHE-RSA、ECDHE-RSA 和 ECDHE-ECDSA。</p>
<p>示例中对称密钥的协商过程采用了 RSA 非对称加密算法，实践中也可以通过 Diffie–Hellman 协议来完成。</p>
<h3 id="离散对数与-Diffie–Hellman-密钥交换协议"><a href="#离散对数与-Diffie–Hellman-密钥交换协议" class="headerlink" title="离散对数与 Diffie–Hellman 密钥交换协议"></a>离散对数与 Diffie–Hellman 密钥交换协议</h3><p>Diffie–Hellman（DH）密钥交换协议是一个经典的协议，最早发表于 1976 年，应用十分广泛。使用该协议可以在不安全信道完成对称密钥的协商，以便后续通信采用对称加密。</p>
<p>DH 协议的设计基于离散对数问题（Discrete Logarithm Problem，DLP）。离散对数问题是指对于一个很大的素数 p，已知 g 为 p 的模循环群的原根，给定任意 x，求解 X = g^x mod p 是可以很快获取的。但在已知 p、g 和 X 的前提下，逆向求解 x 目前没有多项式时间实现的算法。该问题同时也是 ECC 类加密算法的基础。</p>
<p>DH 协议的基本交换过程如下：</p>
<ul>
<li>Alice 和 Bob 两个人协商密钥，先公开商定 p，g；</li>
<li>Alice 自行选取私密的整数x，计算 X = g^x mod p，发送 X 给 Bob；</li>
<li>Bob 自行选取私密的整数 y，计算 Y = g^y mod p，发送 Y给 Alice；</li>
<li>Alice 根据 x 和 Y，求解共同密钥 Z_A = Y^x mod p；</li>
<li>Bob 根据 X 和 y，求解共同密钥 Z_B = X^y mod p。</li>
</ul>
<p>实际上，Alice 和 Bob 计算出来的结果将完全相同，因为在 mod p 的前提下，Y^x = (g^y)^x = g^(xy) = (g^x)^y = X^y。而信道监听者在已知 p、g、X、Y 的前提下，无法求得 Z。</p>
<h2 id="消息认证码与数字签名"><a href="#消息认证码与数字签名" class="headerlink" title="消息认证码与数字签名"></a>消息认证码与数字签名</h2><p>消息认证码和数字签名技术通过对消息的摘要进行加密，可用于消息防篡改和身份证明问题。</p>
<h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><p>消息认证码全称是“基于 Hash 的消息认证码”（Hash-based Message Authentication Code，HMAC）。消息验证码基于对称加密，可以用于对消息完整性（integrity）进行保护。</p>
<p>基本过程为：对某个消息利用提前共享的对称密钥和 Hash 算法进行加密处理，得到 HMAC 值。该 HMAC 值持有方可以证明自己拥有共享的对称密钥，并且也可以利用 HMAC 确保消息内容未被篡改。</p>
<p>典型的 HMAC（K，H，Message）算法包括三个因素，K 为提前共享的对称密钥，H 为提前商定的 Hash 算法（一般为公认的经典算法如SHA-256），Message 为要处理的消息内容。如果不知道 K 或 H 的任何一个，则无法根据 Message 得到正确的 HMAC 值。</p>
<p>消息认证码一般用于证明身份的场景。如 Alice、Bob 提前共享和 HMCA 的密钥和 Hash 算法，Alice 需要知晓对方是否为 Bob，可发送随机消息给 Bob。Bob 收到消息后进行计算，把消息 HMAC 值返回给 Alice，Alice 通过检验收到 HMAC 值的正确性可以知晓对方是否是 Bob。注意这里并没有考虑中间人攻击的情况，假定信道是安全的。</p>
<p>消息认证码使用过程中主要问题是需要共享密钥。当密钥可能被多方拥有的场景下，无法证明消息来自某个确切的身份。反之，如果采用非对称加密方式，则可以追溯到来源身份，即数字签名。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>与在纸质合同上签名确认合同内容和证明身份类似，数字签名基于非对称加密，既可以用于证实某数字内容的完整性，又同时可以确认来源（或不可抵赖，Non-Repudiation）。</p>
<p>一个典型的场景是，Alice 通过信道发给 Bob 一个文件（一份信息），Bob 如何获知所收到的文件即为 Alice 发出的原始版本？Alice 可以先对文件内容进行摘要，然后用自己的私钥对摘要进行加密（签名），之后同时将文件和签名都发给 Bob。Bob 收到文件和签名后，用 Alice 的公钥来解密签名，得到数字摘要，与收到文件进行摘要后的结果进行比对。如果一致，说明该文件确实是 Alice 发过来的（别人无法拥有 Alice 的私钥），并且文件内容没有被修改过（摘要结果一致）。</p>
<p>知名的数字签名算法包括 DSA（Digital Signature Algorithm）和安全强度更高的 ECSDA（Elliptic Curve Digital Signature Algorithm）等。</p>
<p>除普通的数字签名应用场景外，针对一些特定的安全需求，产生了一些特殊数字签名技术，包括盲签名、多重签名、群签名、环签名等。</p>
<h4 id="盲签名"><a href="#盲签名" class="headerlink" title="盲签名"></a>盲签名</h4><p>盲签名（blind signature）是在 1982 年由 David Chaum 在论文《Blind Signatures for Untraceable Payment》中提出。签名者需要在无法看到原始内容的前提下对信息进行签名。</p>
<p>盲签名可以实现对所签名内容的保护，防止签名者看到原始内容；另一方面，盲签名还可以实现防止追踪（unlinkability），签名者无法将签名内容和签名结果进行对应。典型的实现包括RSA盲签名算法等。</p>
<h4 id="多重签名"><a href="#多重签名" class="headerlink" title="多重签名"></a>多重签名</h4><p>多重签名（multiple signature）即 n 个签名者中，收集到至少 m 个（ n ≥ m ≥ 1）的签名，即认为合法。其中，n 是提供的公钥个数，m 是需要匹配公钥的最少的签名个数。</p>
<p>多重签名可以有效地被应用在多人投票共同决策的场景中。例如双方进行协商，第三方作为审核方。三方中任何两方达成一致即可完成协商。</p>
<p>比特币交易中就支持多重签名，可以实现多个人共同管理某个账户的比特币交易。</p>
<h4 id="群签名"><a href="#群签名" class="headerlink" title="群签名"></a>群签名</h4><p>群签名（group signature）即某个群组内一个成员可以代表群组进行匿名签名。签名可以验证来自于该群组，却无法准确追踪到签名的是哪个成员。</p>
<p>群签名需要存在一个群管理员来添加新的群成员，因此存在群管理员可能追踪到签名成员身份的风险。</p>
<p>群签名最早于 1991 年由 David Chaum 和 Eugene van Heyst 提出。</p>
<h4 id="环签名"><a href="#环签名" class="headerlink" title="环签名"></a>环签名</h4><p>环签名（ring signature），由 Rivest、Shamir 和 Tauman 三位密码学家在 2001 年首次提出。环签名属于一种简化的群签名。</p>
<p>签名者首先选定一个临时的签名者集合，集合中包括签名者自身。然后签名者利用自己的私钥和签名集合中其他人的公钥就可以独立地产生签名，而无需他人的帮助。签名者集合中的其他成员可能并不知道自己被包含在最终的签名中。</p>
<p>环签名在保护匿名性方面有很多的用途。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>数字签名算法自身的安全性由数学问题进行保障，但在使用上，系统的安全性也十分关键。目前常见的数字签名算法往往需要选取合适的随机数作为配置参数，配置参数不合理的使用或泄露都会造成安全漏洞，需要进行安全保护。</p>
<p>2010 年，SONY 公司因为其 PS3 产品上采用安全的 ECDSA 进行签名时，不慎采用了重复的随机参数，导致私钥被最终破解，造成重大经济损失。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>对于非对称加密算法和数字签名来说，很重要的一点就是公钥的分发。理论上任何人可以公开获取到对方的公钥。然而这个公钥有没有可能是伪造的呢？传输过程中有没有可能被篡改掉呢？一旦公钥自身出了问题，则整个建立在其上的安全体系的安全性将不复存在。</p>
<p>数字证书机制正是为了解决这个问题，它就像日常生活中的一个证书一样，可以证明所记录信息的合法性。比如证明某个公钥是某个实体（如组织或个人）的，并且确保一旦内容被篡改能被探测出来，从而实现对用户公钥的安全分发。</p>
<p>根据所保护公钥的用途，可以分为加密数字证书（Encryption Certificate）和签名验证数字证书（Signature Certificate）。前者往往用于保护用于加密信息的公钥；后者则保护用于进行解密签名进行身份验证的公钥。两种类型的公钥也可以同时放在同一证书中。</p>
<p>一般情况下，证书需要由证书认证机构（Certification Authority，CA）来进行签发和背书。权威的证书认证机构包括 DigiCert、GlobalSign、VeriSign 等。用户也可以自行搭建本地 CA 系统，在私有网络中进行使用。</p>
<h3 id="X-509证书规范"><a href="#X-509证书规范" class="headerlink" title="X.509证书规范"></a>X.509证书规范</h3><p>一般来说，一个数字证书内容可能包括基本数据（版本、序列号）、所签名对象信息（签名算法类型、签发者信息、有效期、被签发人、签发的公开密钥）、CA的数字签名，等等。</p>
<p>目前使用最广泛的标准为 ITU 和 ISO 联合制定的 X.509 的 v3 版本规范（RFC 5280），其中定义了如下证书信息域：</p>
<ul>
<li><p>版本号（Version Number）：规范的版本号，目前为版本 3，值为 0x2；</p>
</li>
<li><p>序列号（Serial Number）：由 CA 维护的为它所颁发的每个证书分配的唯一的序列号，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能超过 20 个字节；</p>
</li>
<li><p>签名算法（Signature Algorithm）：数字签名所采用的算法，如 SHA256WithRSAEncryption 或 ecdsa-with-SHA256；</p>
</li>
<li><p>颁发者（Issuer）：颁发证书单位的标识信息，如“C=CN，ST=Beijing，L=Beijing，O=org.example.com，CN=ca.org.example.com”；</p>
</li>
<li><p>有效期（Validity）：证书的有效期限，包括起止时间；</p>
</li>
<li><p>主体（Subject）：证书拥有者的标识信息（Distinguished Name），如“C=CN，ST=Beijing，L=Beijing，CN=person.org.example.com”；</p>
</li>
<li><p>主体的公钥信息（Subject Public Key Info）：所保护的公钥相关的信息；</p>
</li>
<li><p>公钥算法（Public Key Algorithm）：公钥采用的算法；</p>
</li>
<li><p>主体公钥（Subject Public Key）：公钥的内容；</p>
</li>
<li><p>颁发者唯一号（Issuer Unique Identifier）：代表颁发者的唯一信息，仅 2、3 版本支持，可选；</p>
</li>
<li><p>主体唯一号（Subject Unique Identifier）：代表拥有证书实体的唯一信息，仅 2、3 版本支持，可选；</p>
</li>
<li><p>扩展（Extensions，可选）：可选的一些扩展。v3 中可能包括：</p>
</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">· Subject <span class="built_in">Key</span> Identifier：实体的密钥标识符，区分实体的多对密钥；</span><br><span class="line"></span><br><span class="line">· Basic Constraints：一般指明是否属于 CA；</span><br><span class="line"></span><br><span class="line">· Authority <span class="built_in">Key</span> Identifier：证书颁发者的公钥标识符；</span><br><span class="line"></span><br><span class="line">· CRL Distribution Points：撤销文件的发布地址；</span><br><span class="line"></span><br><span class="line">· <span class="built_in">Key</span> Usage：证书的用途或功能信息。</span><br></pre></td></tr></table></figure>

<p>此外，证书的颁发者还需要对证书内容利用自己的公钥添加签名，以防止别人对证书内容进行篡改。</p>
<h3 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h3><p>X.509 规范中一般推荐使用 PEM（Privacy Enhanced Mail）格式来存储证书相关的文件。证书文件的文件名后缀一般为 .crt 或 .cer，对应私钥文件的文件名后缀一般为 .key，证书请求文件的文件名后缀为 .csr。有时候也统一用 .pem 作为文件名后缀。</p>
<p>PEM 格式采用文本方式进行存储，一般包括首尾标记和内容块，内容块采用 Base64 进行编码。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-----<span class="keyword">BEGIN</span> CERTIFICATE-----</span><br><span class="line">MIICMzCCAdmgAwIBAgIQIhMiRzqkCljq3ZXnsl6EijAKBggqhkjOPQQDAjBmMQsw</span><br><span class="line">CQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy</span><br><span class="line">YW5jaXNjbzEUMBIGA1UEChMLZXhhbXBsZS5jb20xFDASBgNVBAMTC2V4YW1wbGUu</span><br><span class="line">Y29tMB4XDTE3MDQyNTAzMzAzN1oXDTI3MDQyMzAzMzAzN1owZjELMAkGA1UEBhMC</span><br><span class="line">VVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBGcmFuY2lzY28x</span><br><span class="line">FDASBgNVBAoTC2V4YW1wbGUuY29tMRQwEgYDVQQDEwtleGFtcGxlLmNvbTBZMBMG</span><br><span class="line">ByqGSM49AgEGCCqGSM49AwEHA0IABCkIHZ3mJCEPbIbUdh/Kz3zWW1C9wxnZOwfy</span><br><span class="line">yrhr6aHwWREW3ZpMWKUcbsYup5kbouBc2dvMFUgoPBoaFYJ9D0SjaTBnMA4GA1Ud</span><br><span class="line">DwEB/wQEAwIBpjAZBgNVHSUEEjAQBgRVHSUABggrBgEFBQcDATAPBgNVHRMBAf8E</span><br><span class="line">BTADAQH<span class="regexp">/MCkGA1UdDgQiBCBIA/</span>DmemwTGibbGe8uWjt5hnlE63SUsXuNKO9iGEhV</span><br><span class="line">qDAKBggqhkjOPQQDAgNIADBFAiEAyoMO2BAQ3c9gBJOk1oSyXP70XRk4dTwXMF7q</span><br><span class="line">R72ijLECIFKLANpgWFoMoo3W91uzJeUmnbJJt8Jlr00ByjurfAvv</span><br><span class="line">-----<span class="keyword">END</span> CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p>可以通过 OpenSSL 工具来查看其内容：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl x509 -in example.com-cert.pem -noout -text</span></span><br><span class="line"><span class="attribute">Certificate</span>:</span><br><span class="line"><span class="attribute">Data</span>:</span><br><span class="line"><span class="attribute">Version</span>: <span class="number">3</span> (<span class="number">0</span>x<span class="number">2</span>)</span><br><span class="line"><span class="attribute">Serial</span> Number:</span><br><span class="line"><span class="attribute">22</span>:<span class="number">13</span>:<span class="number">22</span>:<span class="number">47</span>:<span class="number">3</span>a:a<span class="number">4</span>:<span class="number">0</span>a:<span class="number">58</span>:ea:dd:<span class="number">95</span>:e<span class="number">7</span>:b<span class="number">2</span>:<span class="number">5</span>e:<span class="number">84</span>:<span class="number">8</span>a</span><br><span class="line"><span class="attribute">Signature</span> Algorithm: ecdsa-with-SHA<span class="number">256</span></span><br><span class="line"><span class="attribute">Issuer</span>: C=US, ST=California, L=San Francisco, O=example.com,</span><br><span class="line"><span class="attribute">CN</span>=example.com</span><br><span class="line"><span class="attribute">Validity</span></span><br><span class="line"><span class="attribute">Not</span> Before: Apr <span class="number">25</span> <span class="number">03</span>:<span class="number">30</span>:<span class="number">37</span> <span class="number">2017</span> GMT</span><br><span class="line"><span class="attribute">Not</span> After : Apr <span class="number">23</span> <span class="number">03</span>:<span class="number">30</span>:<span class="number">37</span> <span class="number">2027</span> GMT</span><br><span class="line"><span class="attribute">Subject</span>: C=US, ST=California, L=San Francisco, O=example.com,</span><br><span class="line"><span class="attribute">CN</span>=example.com</span><br><span class="line"><span class="attribute">Subject</span> Public Key Info:</span><br><span class="line"><span class="attribute">Public</span> Key Algorithm: id-ecPublicKey</span><br><span class="line"><span class="attribute">Public</span>-Key: (<span class="number">256</span> bit)</span><br><span class="line"><span class="attribute">pub</span>:</span><br><span class="line"><span class="attribute">04</span>:<span class="number">29</span>:<span class="number">08</span>:<span class="number">1</span>d:<span class="number">9</span>d:e<span class="number">6</span>:<span class="number">24</span>:<span class="number">21</span>:<span class="number">0</span>f:<span class="number">6</span>c:<span class="number">86</span>:d<span class="number">4</span>:<span class="number">76</span>:<span class="number">1</span>f:ca:</span><br><span class="line"><span class="attribute">cf</span>:<span class="number">7</span>c:d<span class="number">6</span>:<span class="number">5</span>b:<span class="number">50</span>:bd:c<span class="number">3</span>:<span class="number">19</span>:d<span class="number">9</span>:<span class="number">3</span>b:<span class="number">07</span>:f<span class="number">2</span>:ca:b<span class="number">8</span>:<span class="number">6</span>b:</span><br><span class="line"><span class="attribute">e9</span>:a<span class="number">1</span>:f<span class="number">0</span>:<span class="number">59</span>:<span class="number">11</span>:<span class="number">16</span>:dd:<span class="number">9</span>a:<span class="number">4</span>c:<span class="number">58</span>:a<span class="number">5</span>:<span class="number">1</span>c:<span class="number">6</span>e:c<span class="number">6</span>:<span class="number">2</span>e:</span><br><span class="line"><span class="attribute">a7</span>:<span class="number">99</span>:<span class="number">1</span>b:a<span class="number">2</span>:e<span class="number">0</span>:<span class="number">5</span>c:d<span class="number">9</span>:db:cc:<span class="number">15</span>:<span class="number">48</span>:<span class="number">28</span>:<span class="number">3</span>c:<span class="number">1</span>a:<span class="number">1</span>a:</span><br><span class="line"><span class="attribute">15</span>:<span class="number">82</span>:<span class="number">7</span>d:<span class="number">0</span>f:<span class="number">44</span></span><br><span class="line"><span class="attribute">ASN1</span> OID: prime<span class="number">256</span>v<span class="number">1</span></span><br><span class="line"><span class="attribute">X509v3</span> extensions:</span><br><span class="line"><span class="attribute">X509v3</span> Key Usage: critical</span><br><span class="line"><span class="attribute">Digital</span> Signature, Key Encipherment, Certificate Sign,</span><br><span class="line"><span class="attribute">CRL</span> Sign</span><br><span class="line"><span class="attribute">X509v3</span> Extended Key Usage:</span><br><span class="line"><span class="attribute">Any</span> Extended Key Usage, TLS Web Server Authentication</span><br><span class="line"><span class="attribute">X509v3</span> Basic Constraints: critical</span><br><span class="line"><span class="attribute">CA</span>:TRUE</span><br><span class="line"><span class="attribute">X509v3</span> Subject Key Identifier:</span><br><span class="line"><span class="attribute">48</span>:<span class="number">03</span>:F<span class="number">0</span>:E<span class="number">6</span>:<span class="number">7</span>A:<span class="number">6</span>C:<span class="number">13</span>:<span class="number">1</span>A:<span class="number">26</span>:DB:<span class="number">19</span>:EF:<span class="number">2</span>E:<span class="number">5</span>A:<span class="number">3</span>B:<span class="number">79</span>:<span class="number">86</span>:</span><br><span class="line"><span class="attribute">79</span>:<span class="number">44</span>:EB:<span class="number">74</span>:<span class="number">94</span>:B<span class="number">1</span>:<span class="number">7</span>B:<span class="number">8</span>D:<span class="number">28</span>:EF:<span class="number">62</span>:<span class="number">18</span>:<span class="number">48</span>:<span class="number">55</span>:A<span class="number">8</span></span><br><span class="line"><span class="attribute">Signature</span> Algorithm: ecdsa-with-SHA<span class="number">256</span></span><br><span class="line"><span class="attribute">30</span>:<span class="number">45</span>:<span class="number">02</span>:<span class="number">21</span>:<span class="number">00</span>:ca:<span class="number">83</span>:<span class="number">0</span>e:d<span class="number">8</span>:<span class="number">10</span>:<span class="number">10</span>:dd:cf:<span class="number">60</span>:<span class="number">04</span>:<span class="number">93</span>:a<span class="number">4</span>:d<span class="number">6</span>:</span><br><span class="line"><span class="attribute">84</span>:b<span class="number">2</span>:<span class="number">5</span>c:fe:f<span class="number">4</span>:<span class="number">5</span>d:<span class="number">19</span>:<span class="number">38</span>:<span class="number">75</span>:<span class="number">3</span>c:<span class="number">17</span>:<span class="number">30</span>:<span class="number">5</span>e:ea:<span class="number">47</span>:bd:a<span class="number">2</span>:<span class="number">8</span>c:</span><br><span class="line"><span class="attribute">b1</span>:<span class="number">02</span>:<span class="number">20</span>:<span class="number">52</span>:<span class="number">8</span>b:<span class="number">00</span>:da:<span class="number">60</span>:<span class="number">58</span>:<span class="number">5</span>a:<span class="number">0</span>c:a<span class="number">2</span>:<span class="number">8</span>d:d<span class="number">6</span>:f<span class="number">7</span>:<span class="number">5</span>b:b<span class="number">3</span>:<span class="number">25</span>:</span><br><span class="line"><span class="attribute">e5</span>:<span class="number">26</span>:<span class="number">9</span>d:b<span class="number">2</span>:<span class="number">49</span>:b<span class="number">7</span>:c<span class="number">2</span>:<span class="number">65</span>:af:<span class="number">4</span>d:<span class="number">01</span>:ca:<span class="number">3</span>b:ab:<span class="number">7</span>c:<span class="number">0</span>b:ef</span><br></pre></td></tr></table></figure>

<p>需要注意，用户自行生成私钥情况下，私钥文件一旦丢失，CA 方由于不持有私钥信息，无法进行恢复，意味着通过该证书中公钥加密的内容将无法被解密。</p>
<h3 id="证书的撤销"><a href="#证书的撤销" class="headerlink" title="证书的撤销"></a>证书的撤销</h3><p>证书超出有效期后会作废，用户也可以主动向 CA 申请撤销某证书文件。</p>
<p>由于 CA 无法强制收回已经颁发出去的数字证书，因此为了实现证书的作废，往往还需要维护一个撤销证书列表（Certificate Revocation List，CRL），用于记录已经撤销的证书序号。</p>
<p>因此，通常情况下，当第三方对某个证书进行验证时，需要首先检查该证书是否在撤销列表中。如果存在，则该证书无法通过验证。如果不在，则继续进行后续的证书验证过程。</p>
<h2 id="Merkle树结构"><a href="#Merkle树结构" class="headerlink" title="Merkle树结构"></a>Merkle树结构</h2><p>Merkle（默克尔）树，又叫哈希树，是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。在区块链系统出现之前，广泛用于文件系统和 P2P 系统中，如下图所示。 </p>
<p><img src="Blockchain-Cryptography-and-Network-Security/Merkle%E6%A0%91%E7%A4%BA%E4%BE%8B.png" alt="Merkle树示例"></p>
<p>其主要特点为：</p>
<p>最下面的叶节点包含存储数据或其哈希值；</p>
<p>非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。</p>
<p>进一步地，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点内容的哈希值。</p>
<p>默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。</p>
<p>目前，默克尔树的典型应用场景有很多，下面分别介绍。</p>
<h3 id="快速比较大量数据"><a href="#快速比较大量数据" class="headerlink" title="快速比较大量数据"></a>快速比较大量数据</h3><p>对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着两组数据必然相同。否则，必然存在不同。</p>
<p>由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。</p>
<h3 id="快速定位修改"><a href="#快速定位修改" class="headerlink" title="快速定位修改"></a>快速定位修改</h3><p>例如上图中，如果 D1 中数据被修改，会影响到 N1、N4 和 Root。</p>
<p>因此，一旦发现某个节点如 Root 的数值发生变化，沿着 Root→N4→N1，最多通过 O(logn) 时间即可快速定位到实际发生改变的数据块 D1。</p>
<h3 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h3><p>仍以上图为例，如何向他人证明拥有的某组数据（D0……D3）中包括给定某个内容D0而不暴露其他任何内容。</p>
<p>很简单，构造如图所示的一个默克尔树，公布 N1、N5、Root。D0 拥有者通过验证生成的 Root 是否跟提供的值一致，即可很容易检测 D0 存在。整个过程中验证者无法获知其他内容。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器（Bloom Filter）于 1970 年由 Burton Howard Bloom 在论文《Space/Time Trade-offs in Hash Coding with Allowable Errors》中提出。布隆过滤器是一种基于Hash的高效查找结构，能够快速（常数时间内）回答“某个元素是否在一个集合内”的问题。</p>
<p>布隆过滤器因为其高效性大量应用于网络和安全领域，例如信息检索（BigTable和HBase）、垃圾邮件规则、注册管理等。</p>
<h3 id="基于Hash的快速查找"><a href="#基于Hash的快速查找" class="headerlink" title="基于Hash的快速查找"></a>基于Hash的快速查找</h3><p>在布隆过滤器之前，先来看基于 Hash 的快速查找算法。在前面的讲解中我们提到，Hash 可以将任意内容映射到一个固定长度的字符串，而且不同内容映射到相同串的概率很低。因此，这就构成了一个很好的“内容→索引”的生成关系。</p>
<p>试想，如果给定一个内容和存储数组，通过构造 Hash 函数，让映射后的 Hash 值总不超过数组的大小，则可以实现快速的基于内容的查找。例如，内容 “hello world” 的 Hash 值如果是 “100”，则存放到数组的第 100 个单元上去。如果需要快速查找任意内容，如 “hello world” 字符串是否在存储系统中，只需要将其在常数时间内计算 Hash 值，并用 Hash 值查看系统中对应元素即可。该系统“完美地”实现了常数时间内的查找。</p>
<p>然而，令人遗憾的是，当映射后的值限制在一定范围（如总数组的大小）内时，会发现 Hash 冲突的概率会变高，而且范围越小，冲突概率越大。很多时候，存储系统的大小又不能无限扩展，这就造成算法效率的下降。为了提高空间利用率，后来人们基于Hash算法的思想设计出了布隆过滤器结构。</p>
<h3 id="更高效的布隆过滤器"><a href="#更高效的布隆过滤器" class="headerlink" title="更高效的布隆过滤器"></a>更高效的布隆过滤器</h3><p>布隆过滤器采用了多个 Hash 函数来提高空间利用率。对同一个给定输入来说，多个 Hash 函数计算出多个地址，分别在位串的这些地址上标记为 1。进行查找时，进行同样的计算过程，并查看对应元素，如果都为 1，则说明较大概率是存在该输入。如下图所示。</p>
<p><img src="Blockchain-Cryptography-and-Network-Security/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="布隆过滤器"></p>
<p>布隆过滤器相对单个 Hash 算法查找，大大提高了空间利用率，可以使用较少的空间来表示较大集合的存在关系。</p>
<p>实际上，无论是 Hash 算法，还是布隆过滤器，基本思想是一致的，都是基于内容的编址。Hash 函数存在冲突，布隆过滤器也存在冲突。这就造成了两种方法都存在着误报（false positive）的情况，但绝对不会漏报（false negative）。</p>
<p>布隆过滤器在应用中误报率往往很低，例如，在使用 7 个不同 Hash 函数的情况下，记录 100 万个数据，采用 2 MB 大小的位串，整体的误判率将低于 1%。而传统的 Hash 查找算法的误报率将接近 10%。</p>
<h2 id="同态加密"><a href="#同态加密" class="headerlink" title="同态加密"></a>同态加密</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>同态加密（homomorphic encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度讲，保持了同态性。</p>
<p>同态加密可以保证实现处理者无法访问到数据自身的信息。</p>
<p>如果定义一个运算符 Δ，对加密算法E和解密算法D，满足：</p>
<p>E(XΔY) = E(X) Δ E(Y)</p>
<p>则意味着对于该运算满足同态性。</p>
<p>同态性来自代数领域，一般包括四种类型：加法同态、乘法同态、减法同态和除法同态。同时满足加法同态和乘法同态，则意味着是代数同态，称为全同态（full homomorphic）。同时满足四种同态性，则称为算数同态。</p>
<p>对于计算机操作来讲，实现了全同态意味着对于所有处理都可以实现同态性。只能实现部分特定操作的同态性，称为特定同态（somewhat homomorphic）。</p>
<h3 id="问题与挑战"><a href="#问题与挑战" class="headerlink" title="问题与挑战"></a>问题与挑战</h3><p>同态加密的问题最早是由 Ron Rivest、Leonard Adleman 和 Michael L.Dertouzos 在 1978 年提出，同年提出了 RSA 加密算法。但第一个“全同态”的算法直到 2009 年才被克雷格·金特里（Craig Gentry）在论文《Fully Homomorphic Encryption Using Ideal Lattices》中提出并进行数学证明。</p>
<p>仅满足加法同态的算法包括 Paillier 和 Benaloh 算法；仅满足乘法同态的算法包括 RSA 和 ElGamal 算法。</p>
<p>同态加密在云计算和大数据的时代意义十分重大。目前，虽然云计算带来了包括低成本、高性能和便捷性等优势，但从安全角度讲，用户还不敢将敏感信息直接放到第三方云上进行处理。如果有了比较实用的同态加密技术，则大家就可以放心地使用各种云服务了，同时各种数据分析过程也不会泄露用户隐私。加密后的数据在第三方服务处理后得到加密后的结果，这个结果只有用户自身可以进行解密，整个过程第三方平台无法获知任何有效的数据信息。</p>
<p>另一方面，对于区块链技术，同态加密也是很好的互补。使用同态加密技术，运行在区块链上的智能合约可以处理密文，而无法获知真实数据，极大地提高了隐私安全性。</p>
<p>目前全同态的加密方案主要包括如下三种类型：</p>
<p>基于理想格（ideal lattice）的方案：Gentry 和 Halevi 在 2011 年提出的基于理想格的方案可以实现 72 bit 的安全强度，对应的公钥大小约为 2.3 GB，同时刷新密文的处理时间需要几十分钟；</p>
<p>基于整数上近似 GCD 问题的方案：Dijk 等人在 2010 年提出的方案（及后续方案）采用了更简化的概念模型，可以降低公钥大小至几十MB量级；</p>
<p>基于带扰动学习（Learning With Errors，LWE）问题的方案：Brakerski 和 Vaikuntanathan 等在 2011 年左右提出了相关方案；Lopez-Alt A 等在 2012 年设计出多密钥全同态加密方案，接近实时多方安全计算的需求。</p>
<p>目前，已知的同态加密技术往往需要较高的计算时间或存储成本，相比传统加密算法的性能和强度还有差距，但该领域被关注度一直很高，笔者相信，在不远的将来会出现接近实用的方案。</p>
<h3 id="函数加密"><a href="#函数加密" class="headerlink" title="函数加密"></a>函数加密</h3><p>与同态加密相关的一个问题是函数加密。</p>
<p>同态加密保护的是数据本身，而函数加密保护的是处理函数本身，即让第三方看不到处理过程的前提下，对数据进行处理。</p>
<p>该问题已被证明不存在对多个通用函数的任意多密钥的方案，目前仅能做到对某个特定函数的一个密钥的方案。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>密码学领域涉及的问题还有许多，这里列出一些还在发展和探讨中的相关技术。</p>
<h3 id="零知识证明-1"><a href="#零知识证明-1" class="headerlink" title="零知识证明"></a>零知识证明</h3><p>零知识证明（zero knowledge proof）是这样的一个过程，证明者在不向验证者提供任何额外信息的前提下，使验证者相信某个论断是正确的。</p>
<p>例如，Alice 向 Bob 证明自己知道某个数字，在证明过程中 Bob 可以按照某个顺序提出问题（比如数字加上某些随机数后的变换）由 Alice 回答，并通过回答确信 Alice 较大概率确实知道某数字。证明过程中，Bob 除了知道 Alice 确实知道该数字外，自己无法获知或推理出任何额外信息（包括该数字本身），也无法用 Alice 的证明去向别人证明（Alice如果提前猜测出Bob问题的顺序，存在作假的可能性）。</p>
<p>零知识证明的研究始于 1985 年 Shafi Goldwasser 等人的论文《The Knowledge Complexity of Interactive Proof-Systems》，目前一般认为至少要满足三个条件：</p>
<ul>
<li><p>完整性（Completeness）：真实的证明可以让验证者成功验证；</p>
</li>
<li><p>可靠性（Soundness）：虚假的证明无法让验证者保证通过验证，但允许存在小概率例外；</p>
</li>
<li><p>零知识（Zero-Knowledge）：如果得到证明，无法从证明过程中获知除了所证明信息之外的任何信息。</p>
</li>
</ul>
<h3 id="量子密码学"><a href="#量子密码学" class="headerlink" title="量子密码学"></a>量子密码学</h3><p>量子密码学（quantum cryptography）随着量子计算和量子通信的研究而受到越来越多的关注，将会对已有的密码学安全机制产生较大的影响。</p>
<p>量子计算的概念最早是物理学家费曼于 1981 年提出，基本原理是利用量子比特可以同时处于多个相干叠加态，理论上可以同时用少量量子比特来表达大量的信息，并同时进行处理，大大提高计算速度。如 1994 年提出的基于量子计算的 Shor 算法，理论上可以实现远超经典计算速度的大数因子分解。这意味着大量加密算法包括 RSA、DES、椭圆曲线算法等都将很容易被破解。但量子计算目前离实际可用的通用计算机还有一定距离。</p>
<p>量子通信则提供对密钥进行安全分发的机制，有望实现无条件安全的“一次性密码”。量子通信基于量子纠缠效应，两个发生纠缠的量子可以进行远距离的实时状态同步。一旦信道被窃听，则通信双方会获知该情况，丢弃此次传输的泄露信息。该性质十分适合进行大量的密钥分发，如 1984 年提出的 BB84 协议，结合量子通道和公开信道，可以实现安全的密钥分发。</p>
<p>提示：一次性密码：最早由香农提出，实现理论上绝对安全的对称加密。其特点为密钥真随机且只使用一次；密钥长度跟明文一致，加密过程为两者进行二进制异或操作。</p>
<h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>密码学与安全问题，一直是学术界和工业界都十分关心的重要话题，相关的技术也一直在不断发展和完善。然而，即便存在理论上完美的技术，也不存在完美的系统。无数例子证实，看起来设计十分完善的系统最后被攻破，并非是因为设计上出现了深层次的漏洞，而问题往往出在事后看来十分浅显的某些方面。</p>
<p>例如，系统管理员将登录密码贴到电脑前；财务人员在电话里泄露用户的个人敏感信息；公司职员随意运行来自不明邮件的附件；不明人员借推销或调查问卷的名义进入办公场所窃取信息……</p>
<p>著名计算机黑客和安全顾问 Kevin David Mitnick 曾在 15 岁时成功入侵北美空中防务指挥系统，其著作《The Art of Deception》大量揭示了如何通过社交工程学的手段轻易获取各种安全信息的案例。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此部分主要总结了密码学与安全领域中的一些核心问题和经典算法。</p>
<p>通过阅读本章内容，相信读者已经对现代密码学的发展状况和关键技术有了初步了解。掌握这些知识，对于帮助理解区块链系统如何实现隐私保护和安全防护都很有好处。</p>
<p>现代密码学安全技术在设计上大量应用了十分专业的现代数学知识，如果读者希望成为这方面的专家，则需要进一步学习并深入掌握近现代的数学科学，特别是数论、抽象代数等相关内容。可以说，密码学安全学科是没有捷径可走的。</p>
<p>另外，从应用的角度来看，一套完整的安全系统除了核心算法外，还包括协议、机制、系统、人员等多个方面。任何一个环节出现漏洞都将带来巨大的安全风险。因此，要实现高安全可靠的系统是十分困难的。</p>
<p>区块链技术中大量利用了现代密码学的已有成果，包括哈希、加解密、签名、Merkle 树数据结构等。另一方面，区块链系统和诸多新的场景也对密码学和安全技术提出了很多新的需求，反过来也将促进相关学科的进一步发展。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链系列——浅谈以太坊</title>
    <url>/articles/Blockchain-Ethereum.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>区块链系列——分布式核心问题</title>
    <url>/articles/Blockchain-Distributed-issues.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式核心问题"><a href="#分布式核心问题" class="headerlink" title="分布式核心问题"></a>分布式核心问题</h1><p>随着摩尔定律遇到瓶颈，越来越多情况下要依靠分布式架构，才能实现海量数据处理能力和可扩展计算能力。</p>
<p>区块链系统，首先是一个分布式系统。传统单节点结构演变到分布式系统，碰到的首要问题就是一致性的保障。很显然，如果分布式集群无法保证处理结果保持一致的话，那人和建立于其上的业务系统都无法正常工作。</p>
<p>此处将介绍分布式系统领域的核心问题，包括一致性、共识的定义，基本的原理和算法，另外介绍一些评估分布式系统可靠性的指标。</p>
<span id="more"></span>

<h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>一致性问题是分布式领域最为基础也是最为重要的问题。如果分布式系统能实现“一致”，对外就可以呈现为一个完美的、可扩展的“虚拟节点”，相对物理节点具备更优越的性能和稳定性。这也是分布式系统希望能实现的最终目标。</p>
<h3 id="问题与挑战"><a href="#问题与挑战" class="headerlink" title="问题与挑战"></a>问题与挑战</h3><ul>
<li>节点之间的网络通信是不可靠的，包括消息延迟、乱序和内容错误等。</li>
<li>节点的处理时间无法保障，结果可能出现错误，甚至节点自身可能发生宕机。</li>
<li>同步调用可以简化设计，但会严重降低分布式系统的可扩展性，甚至使其退化为单点系统。</li>
</ul>
<h3 id="一致性要求"><a href="#一致性要求" class="headerlink" title="一致性要求"></a>一致性要求</h3><ul>
<li><strong>可终止性（termination）</strong>：一致的结果在有限时间内能完成</li>
<li><strong>约同性（agreement）</strong>：不同节点最终完成决策的结果是相同的</li>
<li><strong>合法性（validity）</strong>：决策的结果必须是某个节点提出的提案</li>
</ul>
<h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><p><strong>共识</strong>（consensus）在很多时候会与<strong>一致性</strong>（consistency）术语放在一起讨论。严谨地讲，两者含义并不完全相同。</p>
<p>一致性往往指分布式系统中多个副本对外呈现的数据的状态。如前面提到的顺序一直行、线性一致性，描述了多个节点对数据状态的维护能力。而共识则描述了分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。因此，一致性描述的是结果状态，共识则是一种手段。达成某种共识并不意味着就保障了一致性。</p>
<p>实践中，要保障系统满足不同程度的一致性，核心过程我那个网需要通过共识算法来达成。共识算法解决的是对某个天大家达成一致意见的过程。</p>
<h3 id="问题与挑战-1"><a href="#问题与挑战-1" class="headerlink" title="问题与挑战"></a>问题与挑战</h3><p>如果分布式系统中哥哥单节点都能保证以十分完美的性能（瞬间相应、超高吞吐）无故障运行，节点之间通信瞬时送达，则实现共识过程并不十分复杂，简单地通过广播进行瞬时投票和应答即可。</p>
<p>然而现实中，这样的“理想”情况并不存在。不同节点之间通信存在延迟（光速物理限制，通信处理延迟），并且任意环节都可能存在故障（系统规模越大，发生故障可能性越高）。如通信网络会发生中断、节点发生故障、甚至存在恶意节点故意伪造消息，破坏系统正常工作流程。</p>
<p>一般来说，把出现故障（crash 或 fail-stop，即不响应）但不会伪造信息的情况成为“非拜占庭错误”（non-Byzantine Fault）或“故障错误”（Crash Fault）；伪造信息恶意响应的情况称为“拜占庭错误”（Byzantine Fault），对应节点为拜占庭节点。</p>
<h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><p>根据解决的是非拜占庭错误情况还是拜占庭错误情况，共识算法可以分为 Crash Fault Tolerance（CFT）类算法和 Byzantine Fault Tolerance（BFT）类算法。</p>
<p>针对常见的非拜占庭错误情况，已经存在一些经典的解决算法，包括 Paxos、Raft 及其变种等。这类容错算法往往性能比较好，处理较快，容忍不超过一半的故障节点。</p>
<p>对于要能容忍拜占庭错误的情况，一般包括 PBFT（Practical Byzantine Fault Tolerance）为代表的确定性系列算法、PoW 为代表的概率算法等。对于确定性算法，一旦达成对某个结果的共识就不可逆转，即共识是最终结果；对于概率类算法，共识结果则是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，成为事实上的最终结果。拜占庭类容错算法往往性能较差，容忍不超过1/3的故障节点。</p>
<p>此外，XFT（Cross Fault Tolerance）等最近提出的改进算法可以提供类似 CFT 的处理响应速度，并能在大多数节点正常工作时提供 BFT 保障。</p>
<h3 id="理论界限"><a href="#理论界限" class="headerlink" title="理论界限"></a>理论界限</h3><p><strong>FLP 不可能原理：即便在网络通信可靠情况下，可扩展的分布式系统的共识问题，其通用解法的理论下限是——没有下限（无解）。</strong></p>
<h2 id="FLP-不可能原理"><a href="#FLP-不可能原理" class="headerlink" title="FLP 不可能原理"></a>FLP 不可能原理</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法。</p>
<p>FLP 不可能原理实际上告诉人们，<strong>不要浪费时间，去为异步分布式系统设计在任意场景下都能实现共识的算法。</strong></p>
<h3 id="正确理解"><a href="#正确理解" class="headerlink" title="正确理解"></a>正确理解</h3><p>要理解 FLP，首先要搞清楚“异步”的含义。在分布式系统中，同步和异步这两个属于存在特殊的含义。</p>
<p><strong>同步</strong>是指系统中的各个节点的时钟误差存在上线；并且消息传递必须在一定时间内完成，否则认为失败；同时各个节点完成处理消息的时间是一定的。对于同步系统，可以很容易地判断消息是否丢失。</p>
<p><strong>异步</strong>是指系统中各个节点可能存在较大的时钟差异，同时消息传输时间是任意长的，各节点对消息进行处理的时间也可能是任意长的，这就造成无法判断某个消息迟迟没有响应是哪里出了问题（节点故障还是传输故障？）。不幸的是，现实生活中的系统往往都是异步系统。</p>
<p>FLP不可能性在原始论文中以图论的形式进行了严格证明。要理解这一基本原理并不复杂，一个不严谨的例子如下。</p>
<p>三个人在不同房间进行投票（投票结果是0或者1）。彼此可以通过电话进行沟通，但经常有人会时不时睡着。比如某个时候，A 投票 0，B 投票 1，C 收到了两人的投票，然后 C 睡着了。此时，A 和 B 将永远无法在有限时间内获知最终的结果，究竟是 C 没有应答还是应答的时间过长。如果可以重新投票，则类似情形可以在每次取得结果前发生，这将导致共识过程永远无法完成。</p>
<p>FLP 原理实际上说明对于允许节点失效情况下，纯粹异步系统无法确保一致性在有限时间内完成。即便对于非拜占庭错误的前提下，包括 Paxos、Raft 等算法也都存在无法达成共识的情况，只是在工程实践中这种情况出现的概率很小。</p>
<p>那么，FLP 不可能原理是否意味着研究共识算法压根没有意义？</p>
<p>先别这么悲观。学术界做研究，往往考虑地是数学和物理意义上最极端的情形，很多时候现实生活要美好得多（感谢这个世界如此鲁棒！）。例如，上面例子中描述的最坏情形，每次都发生的概率其实并没有那么大。工程实现上多尝试几次，很大可能就成功了。</p>
<p><strong>科学告诉你什么是不可能的；工程则告诉你，付出一些代价，可以把它变成可行。</strong>这就是科学和工程不同的魅力。</p>
<p>那么，退一步讲，在付出一些代价的情况下，我们在共识的达成上，能做到多好？回答这一问题的是另一个很出名的原理：CAP 原理。</p>
<p>提示：科学告诉你去赌场赌博从概率上总会是输钱的；工程则告诉你，如果你愿意接受最终输钱的风险，中间说不定能偶尔小赢几笔呢！</p>
<h2 id="CAP-原理"><a href="#CAP-原理" class="headerlink" title="CAP 原理"></a>CAP 原理</h2><p>CAP 原理最早是 2000 年由 Eric Brewer 在 ACM 组织的一个研讨会上提出猜想，后来 Lynch 等人进行了证明。该原理被认为是分布式系统领域的重要原理之一。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>CAP 原理：分布式计算系统不可能同时确保以下三个特性：一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。</p>
<p>这里，一致性、可用性和分区容忍性的含义如下：</p>
<ul>
<li><p>一致性：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性；</p>
</li>
<li><p>可用性：在有限时间内，任何非失败节点都能应答请求；</p>
</li>
<li><p>分区容忍性：网络可能发生分区，即节点之间的通信不可保障。</p>
</li>
</ul>
<p>比较直观地理解如下，当网络可能出现分区的时候，系统是无法同时保证一致性和可用性的。要么，节点收到请求后因为没有得到其他节点的确认而不应答（牺牲可用性），要么节点只能应答非一致的结果（牺牲一致性）。</p>
<p>由于大多数时候网络被认为是可靠的，因此系统可以提供一致可靠的服务；当网络不可靠时，系统要么牺牲掉一致性（多数场景下），要么牺牲掉可用性。</p>
<p>注意：网络分区是可能存在的，出现分区情况后很可能会导致发生“脑裂”，多个新出现的主节点可能会尝试关闭其他主节点。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>既然 CAP 三种特性不可同时得到保障，则设计系统时必然要弱化对某个特性的支持。那么可能出现下面三个应用场景。</p>
<h4 id="弱化一致性"><a href="#弱化一致性" class="headerlink" title="弱化一致性"></a>弱化一致性</h4><p>对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才最终更新成功，期间不保证一致性。例如网站静态页面内容、实时性较弱的查询类数据库等，简单分布式同步协议如 Gossip，以及 CouchDB、Cassandra 数据库等，都是为此设计的。</p>
<h4 id="弱化可用性"><a href="#弱化可用性" class="headerlink" title="弱化可用性"></a>弱化可用性</h4><p>对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis、MapReduce 等是为此设计的。Paxos、Raft 等共识算法，主要处理这种情况。在 Paxos 类算法中，可能存在着无法提供可用结果的情形，同时允许少数节点离线。</p>
<h4 id="弱化分区容忍性"><a href="#弱化分区容忍性" class="headerlink" title="弱化分区容忍性"></a>弱化分区容忍性</h4><p>现实中，网络分区出现概率较小，但较难完全避免。两阶段的提交算法，某些关系型数据库及 ZooKeeper 主要考虑了这种设计。实践中，网络可以通过双通道等机制增强可靠性，达到高稳定的网络通信。</p>
<h2 id="ACID-原则"><a href="#ACID-原则" class="headerlink" title="ACID 原则"></a>ACID 原则</h2><p>ACID 原则指的是：Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性），用了四种特性的缩写。</p>
<p>ACID 也是一种比较出名的描述一致性的原则，通常出现在分布式数据库领域。具体来说，ACID 原则描述了分布式数据库需要满足的一致性需求，同时允许付出可用性的代价。</p>
<p>ACID 特征如下：</p>
<ul>
<li><p>Atomicity：每次操作是原子的，要么成功，要么不执行；</p>
</li>
<li><p>Consistency：数据库的状态是一致的，无中间状态；</p>
</li>
<li><p>Isolation：各种操作彼此之间互相不影响；</p>
</li>
<li><p>Durability：状态的改变是持久的，不会失效。</p>
</li>
</ul>
<p>与 ACID 相对的一个原则是 BASE（Basic Availability，Soft-state，Eventual Consistency）原则，牺牲掉对一致性的约束（但实现最终一致性），来换取一定的可用性。</p>
<p>注意：ACID 和 BASE 在英文中分别是“酸”和“碱”，看似对立，实则是分别对 CAP 三特性的不同取舍。</p>
<h2 id="Paxos-算法与-Raft-算法"><a href="#Paxos-算法与-Raft-算法" class="headerlink" title="Paxos 算法与 Raft 算法"></a>Paxos 算法与 Raft 算法</h2><p>Paxos 问题是指分布式的系统中存在故障（crash fault），但不存在恶意（corrupt）节点的场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。这也是分布式共识领域最为常见的问题。解决 Paxos 问题的算法主要有 Paxos 系列算法和 Raft 算法。</p>
<h3 id="Paxos-算法"><a href="#Paxos-算法" class="headerlink" title="Paxos 算法"></a>Paxos 算法</h3><p>1990 年由 Leslie Lamport 在论文《The Part-time Parliament》中提出的 Paxos 共识算法，在工程角度实现了一种最大化保障分布式系统一致性（存在极小的概率无法实现一致）的机制。Paxos 算法被广泛应用在 Chubby、ZooKeeper 这样的分布式系统中。Leslie Lamport 作为分布式系统领域的早期研究者，因为相关成果获得了 2013 年度图灵奖。</p>
<p>故事背景是古希腊 Paxon 岛上的多个法官在一个大厅内对一个议案进行表决，如何达成统一的结果。他们之间通过服务人员来传递纸条，但法官可能离开或进入大厅，服务人员可能偷懒去睡觉。</p>
<p>Paxos 是第一个广泛应用的共识算法，其原理基于“两阶段提交”算法并进行泛化和扩展，通过消息传递来逐步消除系统中的不确定状态，是后来不少共识算法（如 Raft、ZAB 等）设计的基础。Paxos 算法基本思想并不复杂，但最初论文描述得比较难懂，后来在 2001 年 Leslie Lamport 还专门写了论文《Paxos Made Simple》予以解释。</p>
<p>算法的基本原理是将节点分为三种逻辑角色，在实现上同一个节点可以担任多个角色：</p>
<ul>
<li><p>Proposer（提案者）：提出一个提案，等待大家批准（chosen）为结案（value）。系统中提案都拥有一个自增的唯一提案号。往往由客户端担任该角色；</p>
</li>
<li><p>Acceptor（接受者）：负责对提案进行投票，接受（accept）提案。往往由服务端担任该角色；</p>
</li>
<li><p>Learner（学习者）：获取批准结果，并可以帮忙传播，不参与投票过程。可能为客户端或服务端。</p>
</li>
</ul>
<p>算法需要满足Safety和Liveness两方面的约束要求。实际上这两个基础属性也是大部分分布式算法都该考虑的：</p>
<ul>
<li>Safety 约束：保证决议（value）结果是对的，无歧义的，不会出现错误情况。</li>
</ul>
<blockquote>
<p>· 只有是被 Proposers 提出的提案才可能被最终批准；</p>
<p>· 在一次执行中，只批准（chosen）一个最终决议。被多数接受（accept）的结果成为决议；</p>
</blockquote>
<ul>
<li>Liveness约束：保证决议过程能在有限时间内完成。</li>
</ul>
<blockquote>
<p>· 决议总会产生，并且学习者能获得被批准的决议。</p>
</blockquote>
<p>基本过程是多个提案者先争取到提案的权利（得到大多数接受者的支持）；得到提案权利的提案者发送提案给所有人进行确认，得到大部分人确认的提案成为批准的结案。</p>
<p>Paxos 不保证系统随时处在一致的状态。但由于每次达成一致的过程中至少有超过一半的节点参与，这样最终整个系统都会获知共识的结果。一个潜在的问题是 Proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新一轮提案的 Proposer 都恰好故障，又或者两个 Proposer 恰好依次提出更新的提案，则导致活锁，系统永远无法达成一致（实际发生概率很小）。</p>
<p>Paxos 能保证在超过一半的节点正常工作时，系统总能以较大概率达成共识。读者可以试着自己设计一套非拜占庭容错下基于消息传递的异步共识方案，会发现在满足各种约束情况下，算法过程会十分类似于 Paxos 的过程。</p>
<p>下面，由简单情况逐步推广到一般情况来探讨算法过程。</p>
<h4 id="单个提案者-多接受者"><a href="#单个提案者-多接受者" class="headerlink" title="单个提案者+多接受者"></a>单个提案者+多接受者</h4><p>如果系统中限定只有某个特定节点是提案者，那么共识结果很容易能达成（只有一个方案，要么达成，要么失败）。提案者只要收到了来自多数接受者的投票，即可认为通过，因为系统中不存在其他的提案。</p>
<p>但此时一旦提案者故障，则系统无法工作。</p>
<h4 id="多个提案者-单个接受者"><a href="#多个提案者-单个接受者" class="headerlink" title="多个提案者+单个接受者"></a>多个提案者+单个接受者</h4><p>限定某个节点作为接受者。这种情况下，共识也很容易达成，接受者收到多个提案，选第一个提案作为决议，发送给其他提案者即可。</p>
<p>缺陷也是容易发生单点故障，包括接受者故障或首个提案者节点故障。</p>
<p>以上两种情形其实类似主从模式，虽然不那么可靠，但因为原理简单而被广泛采用。</p>
<p>当提案者和接受者都推广到多个的情形，会出现一些挑战。</p>
<h4 id="多个提案者-多个接受者"><a href="#多个提案者-多个接受者" class="headerlink" title="多个提案者+多个接受者"></a>多个提案者+多个接受者</h4><p>既然限定单提案者或单接受者都会出现故障，那么就得允许出现多个提案者和多个接受者。问题一下子变得复杂了。</p>
<p>一种情况是同一时间片段（如一个提案周期）内只有一个提案者，这时可以退化到单提案者的情形。需要设计一种机制来保障提案者的正确产生，例如按照时间、序列、或者大家猜拳（出一个参数来比较）之类。考虑到分布式系统要处理的工作量很大，这个过程要尽量高效，满足这一条件的机制非常难设计。</p>
<p>另一种情况是允许同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？这个时候采用只接受第一个提案而拒绝后续提案的方法也不适用。很自然的，提案需要带上不同的序号。节点需要根据提案序号来判断接受哪个。比如接受其中序号较大（往往意味着是接受新提出的，因为旧提案者故障概率更大）的提案。</p>
<p>如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。</p>
<p>同时允许多个提案意味着很可能单个提案人无法集齐足够多的投票；另一方面，提案者即便收到了多数接受者的投票，也不敢说就一定通过。因为在此过程中投票者无法获知其他投票人的结果，也无法确认提案人是否收到了自己的投票。因此，需要实现两个阶段的提交过程。</p>
<h4 id="两阶段的提交"><a href="#两阶段的提交" class="headerlink" title="两阶段的提交"></a>两阶段的提交</h4><p>提案者发出提案申请之后，会收到来自接受者的反馈。一种结果是提案被大多数接受者接受了，一种结果是没被接受。没被接受的话，可以过会再重试。即便收到来自大多数接受者的答复，也不能认为就最终确认了。因为这些接受者并不知道自己刚答复的提案是否可以构成大多数的一致意见。</p>
<p>很自然，需要引入新的一个阶段，即提案者在第一阶段拿到所有的反馈后，需要再次判断这个提案是否得到大多数的支持，如果支持则需要对其进行最终确认。</p>
<p>Paxos里面对这两个阶段分别命名为准备（Prepare）阶段和提交（Commit）阶段。准备阶段通过锁来解决对哪个提案内容进行确认的问题，提交阶段解决大多数确认最终值的问题。</p>
<p>准备阶段：</p>
<ul>
<li><p>提案者发送自己计划提交的提案的编号到多个接收者，试探是否可以锁定多数接收者的支持；</p>
</li>
<li><p>接受者时刻保留收到过提案的最大编号和接受的最大提案。如果收到提案号比目前保留的最大提案号还大，则返回自己已接受的提案值（如果还未接受过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接受小于最大提案号的提案。</p>
</li>
</ul>
<p>提交阶段：</p>
<ul>
<li><p>提案者如果收到大多数的回复（表示大部分人听到它的请求），则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功。则使用自己的提案内容；如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没收到足够多的回复，则需要再次发出请求；</p>
</li>
<li><p>接受者收到“接受消息”后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。</p>
</li>
</ul>
<p>一旦多数接受者接受了共同的提案值，则形成决议，成为最终确认。</p>
<h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><p>Paxos 算法的设计并没有考虑到一些优化机制，同时论文中也没有给出太多实现细节，因此后来出现了不少性能更优化的算法和实现，包括Fast Paxos、Multi-Paxos 等。最近出现的 Raft 算法，算是对 Multi-Paxos 的重新简化设计和实现，相对也更容易理解。</p>
<p>Raft 算法由斯坦福大学的 Diego Ongaro 和 John Ousterhout 于 2014 年在论文《In Search of an Understandable Consensus Algorithm》中提出。Raft 算法面向对多个决策达成一致的问题，分解了 Leader 选举、日志复制和安全方面的考虑，并通过约束减少了不确定性的状态空间。</p>
<p>Raft 算法包括三种角色：Leader（领导者）、Candidate（候选领导者）和 Follower（跟随者），决策前通过选举一个全局的 Leader 来简化后续的决策过程。Leader 角色十分关键，决定日志（log）的提交。日志只能由 Leader 向 Follower 单向复制。</p>
<p>典型的过程包括以下两个主要阶段：</p>
<ul>
<li><p>Leader 选举：开始所有节点都是 Follower，在随机超时发生后未收到来自 Leader 或 Candidate 消息，则转变角色为 Candidate，提出选举请求。最近选举阶段（Term）中得票超过一半者被选为 Leader；如果未选出，随机超时后进入新的阶段重试。Leader 负责从客户端接收 log，并分发到其他节点；</p>
</li>
<li><p>同步日志：Leader 会找到系统中日志最新的记录，并强制所有的 Follower 来刷新到这个记录，数据的同步是单向的。</p>
</li>
</ul>
<p>注意：此处日志并非是指输出消息，而是各种事件的发生记录。</p>
<h2 id="拜占庭问题与算法"><a href="#拜占庭问题与算法" class="headerlink" title="拜占庭问题与算法"></a>拜占庭问题与算法</h2><p>拜占庭问题（Byzantine Problem）更为广泛，讨论的是允许存在少数节点作恶（消息可能被伪造）场景下的一致性达成问题。拜占庭容错（Byzantine Fault Tolerant，BFT）算法讨论的是在拜占庭情况下对系统如何达成共识。</p>
<h3 id="两将军问题"><a href="#两将军问题" class="headerlink" title="两将军问题"></a>两将军问题</h3><p>在拜占庭将军问题之前，就已经存在两将军问题（Two Generals Paradox）：两个将军要通过信使来达成进攻还是撤退的约定，但信使可能迷路或被敌军阻拦（消息丢失或伪造），如何达成一致？根据 FLP 不可能原理，这个问题无通用解。</p>
<h3 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h3><p>拜占庭问题又叫拜占庭将军问题（Byzantine Generals Problem），是 Leslie Lamport 等科学家于 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图干扰共识的达成。拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。</p>
<p>论文中指出，对于拜占庭问题来说，假如节点总数为N，叛变将军数为F，则当 N ≥ 3F+1 时，问题才有解，由 BFT 算法进行保证。</p>
<p>例如，N = 3，F = 1 时。</p>
<p>提案人不是叛变者，提案人发送一个提案出来，叛变者可以宣称收到的是相反的命令。则对于第三个人（忠诚者）收到两个相反的消息，无法判断谁是叛变者，则系统无法达到一致。</p>
<p>提案人是叛变者，发送两个相反的提案分别给另外两人，另外两人都收到两个相反的消息，无法判断究竟谁是叛变者，则系统无法达到一致。</p>
<p>更一般的，当提案人不是叛变者，提案人提出提案信息 1，则对于合作者来看，系统中会有 N-F 份确定的信息 1，和 F 份不确定的信息（可能为 0 或 1，假设叛变者会尽量干扰一致的达成），N - F &gt; F，即 N &gt; 2F 情况下才能达成一致。</p>
<p>当提案人是叛变者，会尽量发送相反的提案给 N - F 个合作者，从收到1的合作者看来，系统中会存在（N - F）/ 2 个信息 1，以及（N - F）/ 2 个信息 0；从收到 0 的合作者看来，系统中会存在（N - F）/ 2 个信息 0，以及（N - F）/ 2 个信息 1；另外存在 F - 1 个不确定的信息。合作者要想达成一致，必须进一步对所获得的消息进行判定，询问其他人某个被怀疑对象的消息值，并通过取多数来作为被怀疑者的信息值。这个过程可以进一步递归下去。</p>
<p>Leslie Lamport 等人在论文《Reaching agreement in the presence of faults》中证明，当叛变者不超过 1/3 时，存在有效的拜占庭容错算法（最坏需要 F+1 轮交互）。反之，如果叛变者过多，超过 1/3，则无法保证一定能达到一致结果。</p>
<p>那么，当存在多于 1/3 的叛变者时，有没有可能存在解决方案呢？</p>
<p>设想 F 个叛变者和 L 个忠诚者，叛变者故意使坏，可以给出错误的结果，也可以不响应。某个时候 F 个叛变者都不响应，则 L 个忠诚者取多数即能得到正确结果。当 F 个叛变者都给出一个恶意的提案，并且 L 个忠诚者中有 F 个离线时，剩下的 L-F 个忠诚者此时无法分别是否混入了叛变者，仍然要确保取多数能得到正确结果，因此，L - F &gt; F，即 L &gt; 2F 或 N - F &gt; 2F，所以系统整体规模 N 要大于 3F。</p>
<p>能确保达成一致的拜占庭系统节点数至少为 4，此时最多允许出现 1 个坏的节点。</p>
<h3 id="拜占庭容错算法"><a href="#拜占庭容错算法" class="headerlink" title="拜占庭容错算法"></a>拜占庭容错算法</h3><p>拜占庭容错算法（Byzantine Fault Tolerant，BFT）是面向拜占庭问题的容错算法，解决的是在网络通信可靠但节点可能故障情况下如何达成共识。拜占庭容错算法最早的讨论在 1980 年 Leslie Lamport 等人发表的论文《Polynomial Algorithms for Byzantine Agreement》，之后出现了大量的改进工作。长期以来，拜占庭问题的解决方案都存在复杂度过高的问题，直到PBFT算法的提出。</p>
<p>1999 年，Castro 和 Liskov 于论文《Practical Byzantine Fault Tolerance and Proactive Recovery》中提出的 Practical Byzantine Fault Tolerant（PBFT）算法，基于前人工作进行了优化，首次将拜占庭容错算法复杂度从指数级降低到了多项式级，目前已得到广泛应用。其可以在失效节点不超过总数 1/3 的情况下同时保证 Safety 和 Liveness。</p>
<p>PBFT算法采用密码学相关技术（RSA 签名算法、消息验证编码和摘要）确保消息传递过程无法被篡改和破坏。</p>
<p>算法的基本过程如下：</p>
<ul>
<li>首先通过轮换或随机算法选出某个节点为主节点，此后只要主节点不切换，则称为一个视图（View）；</li>
<li>在某个视图中，客户端将请求（REQUEST，operation，timestamp，client）发送给主节点，主节点负责广播请求到所有其他副本节点；</li>
<li>所有节点处理完成请求，将处理结果（REPLY，view，timestamp，client，id_node，response）返回给客户端。客户端检查是否收到了至少 f+1 个来自不同节点的相同结果，作为最终结果。</li>
</ul>
<p>主节点广播过程包括三个阶段的处理：预准备（pre-prepare）阶段、准备（prepare）阶段和提交（commit）阶段。预准备和准备阶段确保在同一个视图内请求发送的顺序正确；准备和提交阶段则确保在不同视图之间的确认请求是保序的；</p>
<ul>
<li><p>预准备阶段：主节点为从客户端收到的请求分配提案编号，然后发出预准备消息（PRE-PREPARE，view，n，digest，message）给各副本节点，其中 message 是客户端的请求消息，digest 是消息的摘要；</p>
</li>
<li><p>准备阶段：副本节点收到预准备消息后，检查消息合法，如检查通过则向其他节点发送准备消息（PREPARE，view，n，digest，id），带上自己的 id 信息，同时接收来自其他节点的准备消息。收到准备消息的节点对消息同样进行合法性检查。验证通过则把这个准备消息写入消息日志中。集齐至少 2f + 1 个验证过的消息才进入准备状态；</p>
</li>
<li><p>提交阶段：广播 commit 消息，告诉其他节点某个提案n在视图v里已经处于准备状态。如果集齐至少 2f + 1 个验证过的 commit 消息，则说明提案通过。</p>
</li>
</ul>
<p>具体实现上还包括视图切换、checkpoint 机制等，可自行参考论文内容，在此不再赘述。</p>
<h3 id="新的解决思路"><a href="#新的解决思路" class="headerlink" title="新的解决思路"></a>新的解决思路</h3><p>拜占庭问题之所以难解，在于任何时候系统中都可能存在多个提案（因为提案成本很低），并且要完成最终一致性确认过程十分困难，容易受干扰。</p>
<p>比特币的区块链网络在设计时提出了创新的 PoW（Proof of Work）概率算法思路，针对这两个环节进行了改进。</p>
<p>首先，限制一段时间内整个网络中出现提案的个数（通过增加提案成本）；其次是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓展。系统的最终确认是概率意义上的存在。这样，即便有人试图恶意破坏，也会付出相应的经济代价（超过整体系统一半的计算力）。</p>
<p>后来的各种 PoX 系列算法，也都是沿着这个思路进行改进，采用经济上的惩罚来制约破坏者。</p>
<h2 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h2><p>可靠性（availability），或者说可用性，是描述系统可以提供服务能力的重要指标。高可靠的分布式系统往往需要各种复杂的机制来进行保障。</p>
<p>通常情况下，服务的可用性可以用服务承诺（Service Level Agreement，SLA）、服务指标（Service Level Indicator，SLI）、服务目标（Service Level Objective，SLO）等方面进行衡量。</p>
<h3 id="几个9的指标"><a href="#几个9的指标" class="headerlink" title="几个9的指标"></a>几个9的指标</h3><p>很多领域里谈到服务的高可靠性，都喜欢用几个 9 的指标来进行衡量。几个 9，其实是概率意义上粗略反映了系统能提供服务的可靠性指标，最初是电信领域提出的概念。</p>
<p>下表给出同指标下每年允许服务出现不可用时间的参考值。 </p>
<p><img src="Blockchain-Distributed-issues/%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8C%87%E6%A0%87.jpg" alt="同指标下，每年允许服务出现不可用时间的参考值"></p>
<p>一般来说，单点的服务器系统至少应能满足两个 9；普通企业信息系统三个 9 就肯定足够了（大家可以统计下自己企业内因系统维护每年要停多少时间），系统能达到四个 9 已经是领先水平了（参考 AWS 等云计算平台）。电信级的应用一般需要能达到五个 9，这已经很厉害了，一年里面最多允许出现五分钟左右的服务不可用。六个 9 以及以上的系统，就更加少见了，要实现往往意味着极高的代价。</p>
<h3 id="两个核心时间"><a href="#两个核心时间" class="headerlink" title="两个核心时间"></a>两个核心时间</h3><p>一般地，描述系统出现故障的可能性和故障出现后的恢复能力，有两个基础的指标：MTBF 和 MTTR</p>
<ul>
<li><p>MTBF（Mean Time Between Failures）：平均故障间隔时间，即系统可以无故障运行的预期时间；</p>
</li>
<li><p>MTTR（Mean Time to Repair）：平均修复时间，即发生故障后，系统可以恢复到正常运行的预期时间。</p>
</li>
</ul>
<p>MTBF 衡量了系统发生故障的频率，如果一个系统的MTBF很短，则往往意味着该系统可用性低；而 MTTR 则反映了系统碰到故障后服务的恢复能力，如果系统的 MTTR 过长，则说明系统一旦发生故障，需要较长时间才能恢复服务。</p>
<p>一个高可用的系统应该是具有尽量长的 MTBF 和尽量短的 MTTR。</p>
<h3 id="提高可靠性"><a href="#提高可靠性" class="headerlink" title="提高可靠性"></a>提高可靠性</h3><p>如何提升系统的可靠性呢？有两个基本思路：一是让系统中的单个组件都变得更可靠；二是干脆消灭单点。</p>
<p>IT 从业人员大都有类似的经验，普通笔记本电脑，基本上是过一阵可能就要重启一下；而运行 Linux/Unix 系统的专用服务器，则可能连续运行几个月甚至几年时间都不出问题。另外，普通的家用路由器，跟生产级别路由器相比，更容易出现运行故障。这些都是单个组件可靠性不同导致的例子，可以通过简单升级单点的软硬件来改善可靠性。</p>
<p>然而，依靠单点实现的可靠性毕竟是有限的。要想进一步地提升，那就只好消灭单点，通过主从、多活等模式让多个节点集体完成原先单点的工作。这可以从概率意义上改善服务对外的整体可靠性，这也是分布式系统的一个重要用途。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分布式系统是计算机科学中十分重要的一个研究领域。随着现代计算机集群规模的不断增长，所处理的数据量越来越大，同时对于性能、可靠性的要求越来越高，分布式系统相关技术已经变得越来越重要，起到的作用也越来越关键。</p>
<p>分布式系统中如何保证共识是个经典的技术问题，无论在学术上还是工程上都存在很高的研究价值。令人遗憾地是，理想的（各项指标均最优）解决方案并不存在。在现实各种约束条件下，往往需要通过牺牲掉某些需求，来设计出满足特定场景的协议。通过本文的学习，读者可以体会到在工程应用中的类似设计技巧。</p>
<p>实际上，工程领域中不少问题都不存在一劳永逸的通用解法；而实用的解决思路是，合理地在实际需求和条件限制之间进行灵活的取舍。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>超级账本——面向企业的分布式账本</title>
    <url>/articles/Blockchain-Hyperledger.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>超级账本（Hyperledger）项目是首个面向企业应用场景的开源分布式账本平台。</p>
<p>本文将简单介绍超级账本项目的发展历史和社区组织，以及旗下的多个顶级开源项目的情况，还将展示开源社区提供的多个高效开发工具。</p>
<span id="more"></span>

<h1 id="超级账本项目简介"><a href="#超级账本项目简介" class="headerlink" title="超级账本项目简介"></a>超级账本项目简介</h1><p>2015 年 12 月，由 Linux 基金会牵头，30 家初始成员，包括 IBM、Intel、Cisco、SWIFT 等，共同宣布了 Hyperledger 联合项目成立。超级账本项目为透明、公开、去中心化的企业级分布式账本技术提供开源参考实现，并推动区块链和分布式账本相关协议、规范和标准的发展。项目官网为 <a href="hyperledger.org">hyperledger.org</a></p>
<p>作为一个联合项目，超级账本由面向不同目的和场景的子项目构成。目前包括 Fabric、Sawtooth、Iroha、Blockchain Explorer、Cello、Indy、Composer、Burrow 等 8 大顶级项目，所有项目都遵守 Apache v2 许可，并约定共同遵守如下的基本原则：</p>
<ul>
<li>重视模块化设计：包括交易、合同、一致性、身份、存储等技术场景；</li>
<li>重视代码可读性：保障新功能和模块都可以很容易添加和扩展；</li>
<li>可持续的演化路线：随着需求的深入和更多的应用场景，不断增加和演化新的项目。</li>
</ul>
<p><strong>如果说以比特币为代表的数字货币提供了区块链技术应用的原型，以太坊为代表的智能合约平台延伸了区块链技术的功能，那么进一步引入权限控制和安全保障的超级账本项目则开拓了区块链技术的全新领域。</strong>超级账本首次将区块链技术引入到了分布式联盟账本的应用场景，这就为未来基于区块链技术打造高效的商业网络打下了坚实的基础。</p>
<p>超级账本项目的出现，实际上宣布区块链技术已经不仅局限在单一应用场景中，也不仅局限在完全开放的公有链模式下，区块链技术已经正式被主流企业市场认可并在实践中采用。同时，超级账本项目中提出和实现了许多创新的设计和理念，包括完备的权限和审查管理、细粒度隐私保护，以及可拔插、可扩展的实现框架，对于区块链相关技术和产业的发展都将产生深远的影响。</p>
<h1 id="社区组织结构"><a href="#社区组织结构" class="headerlink" title="社区组织结构"></a>社区组织结构</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>超级账本社区目前主要是三驾马车领导的结构：</p>
<ul>
<li>技术委员会（TSC）：负责技术相关的工作，下设多个工作组，具体带动各个项目和方向的发展；</li>
<li>管理董事会：负责社区组织的整体决策，由超级账本会员中推选出代表；</li>
<li>Linux 基金会（LF）：负责基金管理，协助 Hyperledger 社区在 Linux 基金会的支持下发展。</li>
</ul>
<h2 id="大中华区技术工作组"><a href="#大中华区技术工作组" class="headerlink" title="大中华区技术工作组"></a>大中华区技术工作组</h2><p>技术工作组的主要职责包括：</p>
<ul>
<li>带领和引导大中华区的技术相关活动，包括贡献代码、指南文档、项目提案等；</li>
<li>推动技术相关的交流，促进会员企业之间的合作和实践案例的落地；</li>
<li>通过邮件列表、RocketChat、论坛等方式促进社区开发者们的技术交流；</li>
<li>协助举办社区活动，包括 Meetuo、黑客松、Hackfest、技术分享、培训等。</li>
</ul>
<p>目前，工作组由来自 IBM、万达、华为等超级账本成员企业的数十名技术专家组成，并得到了社区众多志愿者的支持。工作组的各项会议和活动内容都是开放的，可以在 <a href="https://wiki.hyperledger.org/groups/tsc/technical-working-group-china">Wiki</a> 首页上找到相关参与方式。</p>
<h1 id="顶级项目介绍"><a href="#顶级项目介绍" class="headerlink" title="顶级项目介绍"></a>顶级项目介绍</h1><p>超级账本（Hyperledger）所有项目代码托管在 Gerrit 和 Github（只读，自动从 Gerrit 上同步）上。</p>
<p>目前，主要包括如下顶级项目：</p>
<ul>
<li>Fabric：包括 Fabric、Fabric CA、Fabric SDK（包括 Node.js、Python 和 Java 等语言）和 fabric-api 等，目标是区块链的基础核心平台，支持 PBFT 等新的共识机制，支持权限管理，最早由 IBM 和 DAH 发起；</li>
<li>Sawtooth：包括 arcade、core、dev-tools、validator、mktplace等，是 Intel 主要发起和贡献的区块链平台，支持全新的基于硬件芯片的共识机制 Proof of Elapsed Time（PoET）；</li>
<li>Iroha：账本平台项目，基于 C++ 实现，带有不少面向 Web 和 Mobile 的特性，主要由 Soramitsu 发起和贡献；</li>
<li>Blockchain Explorer：提供 Web 操作界面，通过界面快速查看查询绑定区块链的状态（区块个数、交易历史）信息等，由 DTCC、IBM、Intel 等开发支持；</li>
<li>Cello：提供区块链平台的部署和运行时管理功能。使用 Cello，管理员可以轻松部署和管理多条区块链；应用开发者可以无需关心如何搭建和维护区块链，由 IBM 团队发起；</li>
<li>Indy：根据基于分布式账本技术的数字身份管理机制，由 Sovrin 基金会发起；</li>
<li>Composer：提供面向链码（链码的概念参见后面介绍）开发的高级语言支持，自动生成链码等，由 IBM 团队发起并维护；</li>
<li>Burrow：提供以太坊虚拟机的支持，实现支持高效交易的带权限的区块链平台，由 Monax 公司发起支持。</li>
</ul>
<p>这些顶级项目相互协作，构成了完善的生态系统。</p>
<p>所有项目一般都需要经历提案（Proposal）、孵化（Incubation）、活跃（Active）、退出（Deprecated）。终结（End of Life）等 5 个生命周期。</p>
<p>任何希望加入到 Hyperledger 社区中的项目，必须首先由发起人编写提案。描述项目的目的、范围和开发计划等重要信息，并由技术委员会来进行评审投票，评审通过则可以进入到社区内进行孵化。项目成熟后可以申请进入到活跃状态，发布正式的版本，最后从社区中退出并结束。</p>
<h2 id="Fabric-项目"><a href="#Fabric-项目" class="headerlink" title="Fabric 项目"></a>Fabric 项目</h2><p>Fabric 是最早加入到超级账本项目中的顶级项目，由 IBM、DAH 等企业于 2015 年底提交到社区。<a href="https://github.com/hyperledger/fabric">项目地址</a></p>
<p>该项目的定位是面向企业的分布式账本平台，创新地引入了权限管理支持，设计上支持可拔插、可扩展，是首个面向联盟链场景的开源项目。</p>
<p>Fabric 基于 Go 语言实现，目前提交次数已超过 5000 次，核心代码超过 8 万行。</p>
<p>Fabric 项目目前处于活跃状态，已发布 1.3 正式版本，同时包括 Fabric CA、Fabric SDK 等多个相关的子项目。</p>
<h2 id="Sawtooth-项目"><a href="#Sawtooth-项目" class="headerlink" title="Sawtooth 项目"></a>Sawtooth 项目</h2><p>Sawtooth 项目由 Intel 等企业于 2016 年 4 月提交到社区。核心代码的<a href="https://github.com/hyperledger/sawtooth-core">项目地址</a></p>
<p>该项目的定位也是分布式账本平台，基于 Python 语言实现，目前提交次数已经超过 3000 次。</p>
<p>Sawtooth 项目利用 Intel 芯片的专属功能，实现了低功耗的 Proof of Elasped Time（PoET）共识机制，并支持交易族（Transaction Family），方便用户使用它来快速开发应用。</p>
<h2 id="Iroha-项目"><a href="#Iroha-项目" class="headerlink" title="Iroha 项目"></a>Iroha 项目</h2><p>Iroha 项目由 Soramitsu 等企业于 2016 年 10 月提交到社区。核心代码的<a href="https://github.com/hyperledger/iroha">项目地址</a></p>
<p>该项目的定位是分布式账本平台框架，基于 C++ 语言实现，目前提交辞树已经超过 2000 次。</p>
<p>Iroha 项目在设计上类似 Fabric，同时提供了基于 C++ 的区块链开发环境，并考虑了移动端和 Web 端的一些需求。</p>
<h2 id="Blockchain-Explorer-项目"><a href="#Blockchain-Explorer-项目" class="headerlink" title="Blockchain Explorer 项目"></a>Blockchain Explorer 项目</h2><p>Blockchain Explorer 项目由 Intel、DTCC、IBM 等企业于 2016 年 8 月提交到社区。核心代码的<a href="https://github.com/hyperledger/blockchain-explorer">项目地址</a></p>
<p>该项目的定位是区块链平台的浏览器，基于 Node.js 语言实现，提供 Web 操作界面。用户可以使用它来快速查看底层区块链平台的运行信息，如区块个数、交易情况。网络状况等。</p>
<h2 id="Cello-项目"><a href="#Cello-项目" class="headerlink" title="Cello 项目"></a>Cello 项目</h2><p>Cello 项目由 IBM 技术团队于 2017 年 1 月贡献到社区。<a href="https://github.com/hyperledger/cello">核心代码</a> &amp; <a href="https://github.com/hyperledger/cello-analytics">数据分析</a></p>
<p>该项目的定位为区块链管理平台，同时提供区块链即服务（Blockchain-as-a-Service），实现区块链环境的快速部署，以及对区块链平台的运行时管理。使用 Cello，可以让区块链应用人员专注到应用开发，而无需关心底层平台的管理和维护。</p>
<p>Cello 的主要开发语言为 Python 和 JavaScript 等，底层支持包括裸机、虚拟机、容器云（包括 Swarm、Kubernetes）等多种基础架构。</p>
<h2 id="Indy-项目"><a href="#Indy-项目" class="headerlink" title="Indy 项目"></a>Indy 项目</h2><p>Indy 项目由 Sovrin 基金会牵头进行开发，致力于打造一个基于区块链和分布式账本技术的数字中心管理平台。该平台支持去中心化，支持跨区块链和跨应用的操作，可实现全球化的身份管理。Indy 项目于 2017 年 3 月底正式加入到超级账本项目。</p>
<p>该项目主要由 Python 语言开发，包括服务节点、客户端和通用库等，目前已有超过 1000 次提交。</p>
<h2 id="Composer-项目"><a href="#Composer-项目" class="headerlink" title="Composer 项目"></a>Composer 项目</h2><p>Composer 项目由 IBM 团队于 2017 年 3 月底贡献到社区，试图提供一个 Hyperledger Fabric 的开发辅助框架。使用 Composer，开发人员可以使用 JavaScript 语言定义应用逻辑，再加上资源、参与者、交易等模型和访问规则，生成 Hyperledger Fabric 支持的链码。</p>
<p>该项目主要由 Node.js 语言开发，目前已经超过 4000 次提交。</p>
<h2 id="Burrow-项目"><a href="#Burrow-项目" class="headerlink" title="Burrow 项目"></a>Burrow 项目</h2><p>Burrow 项目由 Monax、Intel 等企业于 2017 年4 月提交到社区。核心代码的<a href="https://github.com/hyperledger/burrow">项目地址</a></p>
<p>该项目的前身为 eris-db，基于 Go 语言实现，目前提交次数已经超过 1000 次。</p>
<p>Burrow 项目提供了支持以太坊虚拟机的智能合约区块链平台，并支持 Proof-of-Stake 共识机制和权限管理，可以提供快速的区块链交易。</p>
<h1 id="开发必备工具"><a href="#开发必备工具" class="headerlink" title="开发必备工具"></a>开发必备工具</h1><h2 id="Linux-Foundation-ID"><a href="#Linux-Foundation-ID" class="headerlink" title="Linux Foundation ID"></a>Linux Foundation ID</h2><p><a href="https://identity.linuxfoundation.org/">注册地址</a></p>
<p>用户使用该 ID 即可访问到包括 Jira、Gerrit、RocketChat 等社区的开发工具。</p>
<h2 id="Jira——任务和进度管理"><a href="#Jira——任务和进度管理" class="headerlink" title="Jira——任务和进度管理"></a>Jira——任务和进度管理</h2><p>Jira 是 Atlassian 公司开发的一套任务管理和事项跟踪的追踪平台，提供 Web 操作界面，使用十分方便。</p>
<p><a href="jira.hyperledger.org">社区地址</a>，作为所有项目开发计划和任务追踪的入口。</p>
<h2 id="Gerrit——代码仓库和-Review-管理"><a href="#Gerrit——代码仓库和-Review-管理" class="headerlink" title="Gerrit——代码仓库和 Review 管理"></a>Gerrit——代码仓库和 Review 管理</h2><p>Gerrit 是一个负责代码协同的开源项目，很多企业和团队都使用它负责代码仓库管理和代码的审阅工作，同样提供了 Web 操作界面。</p>
<p><a href="gerrit.hyperledger.org">社区地址</a>，作为官方的代码仓库，并实时同步代码到 github.com/hyperledger 作为只读镜像。</p>
<h2 id="RocketChat——在线沟通"><a href="#RocketChat——在线沟通" class="headerlink" title="RocketChat——在线沟通"></a>RocketChat——在线沟通</h2><p><a href="chat.hyperledger.org">社区服务器</a>，包含 Web 版和 Client 版。</p>
<h1 id="贡献代码"><a href="#贡献代码" class="headerlink" title="贡献代码"></a>贡献代码</h1><p>超级账本的各个子项目都提供了十分丰富的开发和提交代码的指南和文档，一般可以在代码的 docs 目录下找到。大部分项目贡献代码的流程都是相似的，此处以 Fabric 项目为例进行讲解。</p>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>推荐在 Linux 或 MacOS 环境中开发 Hyperledger 项目代码。</p>
<p>不同项目会依赖不同的环境，均可从项目文档中找到。以 Fabric 为例，开发需要安装以下依赖：</p>
<ul>
<li>Git：获取代码并进行版本管理</li>
<li>Golang：安装并配置 $GOPATH 环境变量</li>
<li>Docker：用来支持容器环境</li>
</ul>
<h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ mkdir <span class="variable">$GOPATH</span>/src/github.com/hyperledger</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger</span><br><span class="line">$ git <span class="built_in">clone</span> http://gerrit.hyperledger.org/r/fabric</span><br></pre></td></tr></table></figure>
<p>关于 Git 的 SSH、用户名、邮箱等设置，此处就不讲了。</p>
<h2 id="编译和测试"><a href="#编译和测试" class="headerlink" title="编译和测试"></a>编译和测试</h2><p>大部分编译和安装过程都可以用 Makefile 来执行，具体以项目代码为准。</p>
<p>以 Fabric 项目为例，常见操作如下：</p>
<ul>
<li>安装 go tools</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ make gotools</span><br></pre></td></tr></table></figure>

<ul>
<li>语法格式检查</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ make linter</span><br></pre></td></tr></table></figure>

<ul>
<li>编译 peer</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ make peer</span><br><span class="line">会自动编译生成 Docker 镜像，并生成本地 peer 可执行文件。</span><br><span class="line">注意，有时候会因为获取安装包不稳定而报错，需要执行 make clean，然后再次执行。</span><br></pre></td></tr></table></figure>

<ul>
<li>生成 Docker 镜像</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ make image</span><br></pre></td></tr></table></figure>

<ul>
<li>执行所有的检查和测试</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ make checks</span><br></pre></td></tr></table></figure>

<ul>
<li>执行单元测试</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ make unit-test</span><br><span class="line">如果要运行某个特定单元测试，则可以通过类似如下格式：</span><br><span class="line">$ go <span class="built_in">test</span> -v -run=TestGetFoo</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 BDD 测试</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">需先生成本地 Docker 镜像。执行如下命令：</span><br><span class="line">$ nake behave</span><br></pre></td></tr></table></figure>

<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>Git 常规操作，就不多 BB 了。</p>
<h2 id="评审代码"><a href="#评审代码" class="headerlink" title="评审代码"></a>评审代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>超级账本项目是 Linux 基金会近些年来重点支持的面向企业的分布式账本平台。它同时也是开源界和工业界技术力量颇有历史意义的携手合作，共同为分布式账本技术提供了在代码实现、协议和规范标准上的技术参考。</p>
<p>超级账本社区重视技术研发的同时，也十分重视应用的落地。目前基于超级账本相关技术，已经出现了大量的企业应用案例。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链系列——浅谈比特币</title>
    <url>/articles/Blockchain-talk-about-BitCoin.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为区块链思想的源头，比特币项目值得区块链技术爱好者仔细研究。比特币网络是首个得到大规模部署的区块链技术应用，并且是首个得到实践检验的数字货币实现，无论在信息技术历史还是在金融学历史上都具有十分重要的意义。</p>
<p>虽然后来的区块链技术应用已经远超了数字货币的范畴，但探索比特币项目的发展历程和设计思路，对于深刻理解区块链技术的来龙去脉有着重要的价值。</p>
<p>本文将介绍比特币项目的来源、核心原理设计、相关工具，以及关键的技术话题。</p>
<span id="more"></span>

<h1 id="瞎扯淡一会儿先"><a href="#瞎扯淡一会儿先" class="headerlink" title="瞎扯淡一会儿先"></a>瞎扯淡一会儿先</h1><ul>
<li>关于“中心化”和“去中心化”……</li>
</ul>
<blockquote>
<p>都用过淘宝或者支付宝吧~</p>
</blockquote>
<h1 id="比特币项目简介"><a href="#比特币项目简介" class="headerlink" title="比特币项目简介"></a>比特币项目简介</h1><p>比特币（BitCoin，BTC） 是基于区块链技术的一种数字货币实现，比特币网络是历史上首个经过大规模、长时间检验的数字货币系统。</p>
<p>比特币网络在功能上具有如下特点：</p>
<ul>
<li><strong>去中心化</strong>：意味着没有任何独立个体可以对网络中的交易进行破坏，任何交易请求都需要大多数参与者的共识；</li>
<li><strong>匿名性</strong>：比特币网络中账户地址是匿名的，无法从交易信息关联到具体的个体，但这也意味着难以进行审计；</li>
<li><strong>通胀预防</strong>：比特币的发行需要通过挖矿计算来进行，发行量每四年减半，总量上限为 2100 万枚，无法被超发。</li>
</ul>
<h2 id="比特币大事记"><a href="#比特币大事记" class="headerlink" title="比特币大事记"></a>比特币大事记</h2><p><strong>Tips</strong>：通过 <a href="blockchain.info">blockchain.info</a> 网站可以实时查询比特币网络的状态信息，包括区块、交易等详细数据。</p>
<h2 id="其他数字货币"><a href="#其他数字货币" class="headerlink" title="其他数字货币"></a>其他数字货币</h2><p>比特币的成功，刺激了相关的生态和社区发展，大量类似的数字货币（超过 700 种）纷纷出现，比较有名的有以太币、莱特币等。</p>
<p>这些数字货币，要么建立在自己独立的区块链网络上，要么复用已有的区块链（例如比特币网络）系统。</p>
<h1 id="原理和设计"><a href="#原理和设计" class="headerlink" title="原理和设计"></a>原理和设计</h1><p>比特币网络是一个分布式的点对点（P2P）网络，网络中的矿工通过“挖矿”来完成对交易记录的记账过程，维护网络的正常运行。</p>
<p>比特币网络提供一个公共可见的记账本，该记账本并非记录每个账户的余额，而是用来记录发生过的交易的历史信息。该设计可以避免重放攻击，即某个合法交易被多次重新发送造成攻击。</p>
<h2 id="基本交易过程"><a href="#基本交易过程" class="headerlink" title="基本交易过程"></a>基本交易过程</h2><p>每次发生交易，用户需要将新交易记录写到比特币区块链网络中，等网络确认后即可认为交易完成。每个交易包括一些输入和一些输出，未经使用的交易的输出可以被新的交易引用作为合法的输入，呗使用过的交易的输出则无法被引用作为合法输入。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>BitCoin</tag>
      </tags>
  </entry>
  <entry>
    <title>Github &amp; Hexo 搭建个人博客</title>
    <url>/articles/Blog-Github-Hexo.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="忙……"><a href="#忙……" class="headerlink" title="忙……"></a>忙……</h1><p>最近真的是，各种事情缠在一起，虽然对于搭建博客满心欢喜，但是哦，这只在我的“重要但不紧急”的象限中，所以，以后会慢慢完善整个搭建，以及充实博客的内容。</p>
<span id="more"></span>

<h2 id="Github-Hexo-简介"><a href="#Github-Hexo-简介" class="headerlink" title="Github + Hexo 简介"></a>Github + Hexo 简介</h2><p>刚刚利用 Github + Hexo 搭建好了个人博客，并绑定了域名 <a href="http://www.chenzihao.me/">chenzihao.me</a>。</p>
<p>最近忙需求，没太多时间更新博客，暂时留个坑，以后会将搭建方式以及 NexT 主题配置完整展现在这里。</p>
<h2 id="What’s-more…"><a href="#What’s-more…" class="headerlink" title="What’s more…"></a>What’s more…</h2><p>当然，还会有一大堆东西，包括一些代码demo，信息安全相关内容包括CTF等，资源，随笔，杂谈，行摄……</p>
<h2 id="TODOList"><a href="#TODOList" class="headerlink" title="TODOList"></a>TODOList</h2><ul>
<li><del>公司两个需求，隐式转换优化，前端改动</del></li>
<li><del>CTF</del></li>
</ul>
<p><del>以上。</del></p>
<p><del>（逃~</del></p>
<p>好嘞，也算是忙完了 CTF，虽然又新接了两个需求，不过工作时间忙一下就算了，回来还是可以做自己想做的事情，学自己想玩的知识。</p>
<p>相信很多 Geek 和文艺青年，都希望拥有自己的博客，把自己的技术知识、文艺创作、生活经历和感想整理在上面，分享给大家。</p>
<p>一直纠结于在哪里写博客，小时候的 QQ 空间、新浪博客，曾经用过的豆瓣、乐乎、人人小站，技术博客中的 CSDN、CNBlogs，就连 Gitbook 也偶尔抽风……累觉不爱。再后来也通过自己搭建 WordPress，也弄过 Jekyll，蛋疼到极致。直到遇见了<a href="www.jianshu.com">简书</a>，可以使用 Markdown 语言，无需考虑乱七八糟的东西，专注于文字。只要你想写文章，插入各种各样的你想要的东西：代码段、图片、链接、引用……并使用各种格式，那么无疑简书是最好的地方。</p>
<p>但后来，不满足于那些博客网站千篇一律的外表，希望自定义页面风格，不想内容被审核所限制，动手能力强，有一定代码基础，想要拥有一个高大上的自定义域名，最终，多看了一眼 Hexo，这个逼格极高的程序猿写作方式，就连名字听起来都很 Geek&amp;Hack，最终选择了 Github + Hexo 搭建个人主页<del>.</del></p>
<p>Hexo 出自于台湾大学生<a href="">tommy351</a>之手，一个基于 Node.js 的静态博客程序，其编译上百篇文字只需要几秒。Hexo 生成的静态网页可以直接放到 Github Pages、BAE、SAE 等平台上。并且为了跳过国内服务器备案才能解析域名、部署网站的蛋疼操作，我选择直接通过 Github 服务器解析域名并将网站通过 Github Pages 部署，然后添加 CNAME 进行域名绑定，唯一要做的就是选择一个高大上的域名咯。最为适合作为个人主页的域名，无疑是.me，然而在国内已经被封禁，那么可以通过“扶墙（你懂的）”的方式在国外域名管理网站申请购买，或者选择其他顶级域名代替，例如 .info，.io 等，就看个人喜好了。</p>
<p>回归正题。</p>
<h1 id="Github-Hexo-搭建个人主页"><a href="#Github-Hexo-搭建个人主页" class="headerlink" title="Github + Hexo 搭建个人主页"></a>Github + Hexo 搭建个人主页</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a>安装 Node</h3><p>简单地说 Node.js 就是运行在服务器端的 JavaScript。</p>
<p>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
<p>以 Windows 系统为例，打开官网<a href="https://nodejs.org/en/download/">下载链接</a>，根据自己系统下载相应版本即可。然后一路默认点下去。</p>
<p>验证版本：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>



<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p><a href="https://git-for-windows.github.io/">下载链接</a>，然后一路默认安装点下去。</p>
<p>验证版本：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h3 id="安装-Markdown-编辑器"><a href="#安装-Markdown-编辑器" class="headerlink" title="安装 Markdown 编辑器"></a>安装 Markdown 编辑器</h3><p>Mac 和 Windows 系统的话，<del>推荐 <a href="http://markdownpad.com/download.html">MarkdownPad</a> 编辑器</del>。</p>
<blockquote>
<p>更新</p>
<p>时代变了大人，目前最好用的是 <strong>Typora</strong>。</p>
</blockquote>
<p>嗯，我觉得喜欢写博客的人都应该学会简单的 <a href="http://wowubuntu.com/markdown/">Markdown语法</a>。</p>
<p><a href="http://www.jianshu.com/p/q81RER">献给写作者的 Markdown 新手指南</a></p>
<p><a href="http://www.jianshu.com/p/qqGjLN">为什么作家应该用 Markdown 保存自己的文稿</a></p>
<p><a href="http://www.jianshu.com/p/PpDNMG">Markdown 写作浅谈</a></p>
<h2 id="账号准备"><a href="#账号准备" class="headerlink" title="账号准备"></a>账号准备</h2><p>以下整理一些必备的账号，通过账号提供 API，才能实现博客的多样化功能。</p>
<h3 id="Github-账号"><a href="#Github-账号" class="headerlink" title="Github 账号"></a>Github 账号</h3><p>这个不用多 BB，每个 Geek 都应该有，地位相当于 Facebook。</p>
<p><a href="https://github.com/">https://github.com</a></p>
<p>首先强调一点，名字最好起得好看一点，否则……</p>
<p>注册好之后，需要做一件事情就是，首先创建一个远程仓库，点击 Create a repository，在 Repository name 下的命名，一定要写成：<strong>username.github.io</strong>的形式，其中 username 就是自己的用户名。</p>
<p>之后选择 Initializie this repository with a README，创建即可。<strong>之后不需要任何 git 的操作了。</strong></p>
<p><strong>不要按照 Github 创建项目之后的提示做！！！</strong></p>
<h3 id="友言账号"><a href="#友言账号" class="headerlink" title="友言账号"></a>友言账号</h3><p>第三方评论系统。</p>
<p><a href="http://www.uyan.cc/">http://www.uyan.cc</a></p>
<p>并不是说它有多好= =而是，喵的只剩下它了。从前最经典的老牌评论系统 Disqus 被墙，网易云跟帖被封，多说下线，畅言被封，韩国的来必力验证码被墙。没辙。你自己扶了墙，或者肉身翻墙，国内的小伙伴就很蛋疼，也没啥卵用。</p>
<h3 id="百度站长统计账号"><a href="#百度站长统计账号" class="headerlink" title="百度站长统计账号"></a>百度站长统计账号</h3><p>用于统计站点访问量和流量分析，很有用的站长管理系统。</p>
<p><a href="https://tongji.baidu.com/web/welcome/login">注册地址</a></p>
<h3 id="LeanCloud-账号"><a href="#LeanCloud-账号" class="headerlink" title="LeanCloud 账号"></a>LeanCloud 账号</h3><p>用于统计文章阅览量，也不错哦。</p>
<p><a href="https://leancloud.cn/">注册地址</a></p>
<h2 id="Hexo-安装配置"><a href="#Hexo-安装配置" class="headerlink" title="Hexo 安装配置"></a>Hexo 安装配置</h2><h3 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h3><p>Node 和 Git 都安装好后，可执行如下命令安装 Hexo：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<h3 id="Hexo-初始化"><a href="#Hexo-初始化" class="headerlink" title="Hexo 初始化"></a>Hexo 初始化</h3><p>创建一个本地文件夹，命名随意，但是如果是 myBlog 会很舒服。</p>
<p>然后进入目录执行 init 命令初始化 hexo 到目录。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>至此，全部安装工作已经完成。</p>
<h3 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h3><p>进入 myBlog，执行如下命令，会生成静态页面到 hexo/public。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>或者简写：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h3 id="Hexo-启动本地服务器"><a href="#Hexo-启动本地服务器" class="headerlink" title="Hexo 启动本地服务器"></a>Hexo 启动本地服务器</h3><p>启动本地服务器，可以在浏览器预览、调试。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>或者简写：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>打开浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到部署效果。</p>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;新建文章名&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果希望修改默认模板，可以去 scaffolds 文件夹下查看，比如 post 的 layout 默认是 hexo/scaffolds/post.md</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，大括号与大括号之间多加了空格，否则会被转义，不能正常显示。</strong></p>
<p>例如，我想添加分类 categories，以避免每次新建文章时手工输入，则只需要修改这个文件，添加一行即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">categories:</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>每次提交前，有三个固定语句。</p>
<h4 id="清除配置"><a href="#清除配置" class="headerlink" title="清除配置"></a>清除配置</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>或简写</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo c</span><br></pre></td></tr></table></figure>

<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>或简写</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h4 id="提交-1"><a href="#提交-1" class="headerlink" title="提交"></a>提交</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>或简写</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="Hexo-站点配置"><a href="#Hexo-站点配置" class="headerlink" title="Hexo 站点配置"></a>Hexo 站点配置</h3><p>打开站点配置文件，位于文件夹根目录，_config.yml。</p>
<p>主题、git 提交配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/MrShadowalker/MrShadowalker.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>theme 后的 next 为我选用的主题，下一节会有介绍。</p>
<p>deploy 提交这部分，因为我的 Github 用户名是 MrShadowalker，这里将 MrShadowalker 改成自己的用户名即可。</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>个人最推荐的主题是 <a href="http://theme-next.iissnan.com/getting-started.html">NexT</a>。</p>
<p>所有安装配置相关的都有，按照指示一步步做就好。</p>
<p>嗯，有问题在下面留言就好，我会一条条讲解。</p>
]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF 干货系列——题目类型</title>
    <url>/articles/CTF-Problem-types.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈哈这里继续挖坑。</p>
<p>等不及的小伙伴可以先去我个人很喜欢的一个<a href="http://www.bugku.com/">论坛</a>上随便找找帖子哈。</p>
<p>链接扔在这里：<a href="http://www.bugku.com/">CTF社区</a></p>
<p>当然了，这里面也有不少<a href="http://tool.bugku.com/">在线工具</a>和<a href="http://123.206.31.85/challenges">习题</a>，方便大家实战练习。</p>
<p>废话说到这里，下面开始正经的。</p>
<span id="more"></span>

<p>当然，以后有时间补齐，哈哈~</p>
<h1 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul>
<li><p>爆破，包括包括 md5、爆破随机数、验证码识别等</p>
</li>
<li><p>绕WAF，包括花式绕Mysql、绕文件读取关键词检测之类拦截</p>
<ul>
<li><a href="http://103.238.227.13:10087/">注入</a></li>
<li><a href="http://ctf5.shiyanbar.com/web/wonderkun/index.php">盲注</a></li>
<li><a href="http://a.sql.bugku.com/web2/">注入绕过1</a>：<strong>提示</strong>!,!=,=,+,-,^,%</li>
<li><a href="http://web.jarvisoj.com:32787/">注入绕过2</a></li>
</ul>
</li>
<li><p>花式玩弄几个 PHP 特性，包括弱类型，strpos 和 ===，反序列化+destruct、\0截断、iconv截断</p>
</li>
<li><p>PHP 伪协议，zip://、phar://、php://filter/read等</p>
<ul>
<li><a href="http://web.jarvisoj.com:32768/">练习</a></li>
</ul>
</li>
<li><p>各种找源码技巧，包括 git、svn、xxx.php.swp、<em>www</em>.(zip|tar.gz|rar|7z)、xxx.php.bak</p>
</li>
<li><p>文件上传，包括花式文件后缀，包括 .php345、.inc、.phtml、.phpt、.phps、各种文件内容检测&lt;?php &lt;? &lt;% 、花式解析漏洞</p>
<ul>
<li><a href="http://c.bugku.com/web9/">练习1</a></li>
<li><a href="http://web.jarvisoj.com:32790/">练习2</a></li>
<li><a href="http://web.jarvisoj.com:32785/index.php#">练习3</a></li>
</ul>
</li>
<li><p>MySQL 类型差异，包括和PHP弱类型类似的特性，0x、0b、1e之类，varchar和integer相互转换</p>
</li>
<li><p>open_basedir、disable_functions花式绕过技巧，包括dl、mail、imagick、bash漏洞、DirectoryIterator及各种二进制选手插足的方法</p>
</li>
<li><p>条件竞争，包括竞争删除前生成shell、竞争数据库无锁多扣钱</p>
</li>
<li><p>windows特性，包括短文件名、IIS解析漏洞、NTFS文件系统通配符、:DATA，冒号截断</p>
</li>
<li><p>SSRF，包括花式探测端口，302跳转、花式协议利用、gophar直接取shell等</p>
</li>
<li><p>XSS，各种浏览器auditor绕过、富文本过滤黑白名单绕过、flash xss、CSP绕过</p>
<ul>
<li><a href="http://103.238.227.13:10089/">XSS</a></li>
</ul>
</li>
<li><p>XXE，各种XML存在地方（rss/word/流媒体）、各种XXE利用方法（SSRF、文件读取）</p>
<ul>
<li><a href="http://web.jarvisoj.com:9882/">XXE</a>：<strong>提示</strong> 请设法获得目标机器/home/ctf/flag.txt中的flag值。</li>
</ul>
</li>
<li><p>协议，花式IP伪造 X-Forwarded-For/X-Client-IP/X-Real-IP/CDN-Src-IP、花式改UA，花式藏FLAG、花式分析数据包</p>
</li>
<li><p>python脚本，盲注脚本、POST提交脚本等，常见python库</p>
<ul>
<li>urllib、urllib2、requests   # 发送 HTTP 请求的</li>
<li>urlparse    # 处理 url </li>
<li>re             # 正则表达式</li>
<li>random    # 生成随机数的</li>
<li>hashlib    # 集成md5算法</li>
<li>base64    # base64编码</li>
<li>socket     # 套接字</li>
<li>os/sys</li>
<li><a href="http://c.bugku.com/web6/">练习</a></li>
</ul>
</li>
</ul>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><ul>
<li><p>压缩包加密，伪加密、暴力破解、明文攻击、CRC32 碰撞</p>
</li>
<li><p>图片隐写，LSB、Stegsolve、binwalk、foremost、JPHS、文件头部属性、RGB图片像素点还原</p>
</li>
<li><p>音频隐写，MP3Stego、分析频谱</p>
</li>
<li><p>流量包分析，追踪流、直接导出、binwalk、foremost</p>
<ul>
<li><a href="http://ctf5.shiyanbar.com/misc/misc300.zip">练习</a> </li>
</ul>
</li>
<li><p>社工，包括花式查社工库、微博、QQ签名、whois</p>
</li>
</ul>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><ul>
<li><p>古典密码</p>
</li>
<li><p>现代密码，RSA、hash 长度扩展、异或、移位加密各种变形、32 位随机数过小、唯密文攻击</p>
<ul>
<li><a href="http://ctf5.shiyanbar.com/crypto/RSA">RSA</a></li>
<li><a href="http://ctf5.shiyanbar.com/crypto/ciphertext.zip">唯密文攻击</a>：<strong>提示</strong>试试看破解这个 1024 位 RSA 系统。flag 的形式是 CTF{USTC-X}，X 是 RSA 的两个素数中较小的那个（取其大写 MD5 的前 6 位）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的自己</title>
    <url>/articles/Essay-About-Me.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>也许是由于我性格上的某种原因，</p>
<p>我的朋友不多。</p>
<p>或者说，</p>
<p>愿意和我交朋友的人很多但其实很孤独。</p>
<p>平日里总是显得落落寡合的样子。</p>
<p>常常一个人，想些不着边际的事情。</p>
<span id="more"></span>

<p>在脑子里营造出另一个世界——</p>
<p>一个属于自己的小天地，</p>
<p>每日便幽游于这心造的封闭的世界中，浑然无察。</p>
<p>大概是因为这样，</p>
<p>才有了这样的一个个人博客——</p>
<p>静态的，没有交互的。</p>
<p>不知道为什么，其实把自己展现给别人，也是不错的。</p>
<p>少了社交网络上的忧心忡忡，不用在意别人的看法。</p>
<p>只是让大家看到我。</p>
<p>仅此而已。</p>
]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF干货系列——题目类型——Web</title>
    <url>/articles/CTF-Web.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><p>CTF 中主攻 Web 题的大（Web）佬（狗）们，通常需要点亮以下技能：</p>
<span id="more"></span>

<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>编程语言黑魔法才是关键。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h3 id="……"><a href="#……" class="headerlink" title="……"></a>……</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>各种数据库的特性与差别，也包括黑魔法。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h3 id="msSQL"><a href="#msSQL" class="headerlink" title="msSQL"></a>msSQL</h3><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><h3 id="……-1"><a href="#……-1" class="headerlink" title="……"></a>……</h3><h2 id="CVE-漏洞"><a href="#CVE-漏洞" class="headerlink" title="CVE 漏洞"></a>CVE 漏洞</h2><p>利用与分析。</p>
<p>这个需要多去看看近期漏洞。</p>
<h2 id="……-2"><a href="#……-2" class="headerlink" title="……"></a>……</h2><hr>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="网站运行原理"><a href="#网站运行原理" class="headerlink" title="网站运行原理"></a>网站运行原理</h2><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><ul>
<li>概述</li>
</ul>
<p>在传输层基于 TCP/IP 协议进行传输，本身属于 OSI 七层模型中的应用层。</p>
<p>HTTP 协议工作于 Client-Server 架构之上。例如，最常见的 client 是 Browser，浏览器作为 HTTP client 通过 URL 想 HTTP server 即 Web 服务器发送 HTTP 请求包，Web 服务器根据 HTTP 协议解析请求后，向 client 发送相应信息。</p>
<ul>
<li>特点</li>
</ul>
<p><strong>简单，快速。</strong>几个字段就可以完整地描述所要请求的资源和数据内容。</p>
<p><strong>灵活性。</strong>客户端以及服务器只需要使用Content-type字段来指定当前数据内容的MIME类型。</p>
<p><strong>无连接。</strong>限制每次连接只处理一个请求。服务器处理完客户端请求并收到客户端应答后，即断开连接。</p>
<p><strong>无状态。</strong>对于事物处理没有记忆能力。如果后续处理需要前面的信息，则必须重传，可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时应答较快。</p>
<ul>
<li>消息结构</li>
</ul>
<p><strong>前置术语</strong></p>
<p>URI：统一资源标识符</p>
<p>回车符：%0d</p>
<p>换行符：%0a</p>
<p><strong>请求数据包结构</strong></p>
<p>client 发送一个 HTTP 请求到 server 的请求报文包括以下格式：</p>
<p>请求行（request line）、请求头部（header）、空行、请求数据。</p>
<p><strong>响应数据包结构</strong></p>
<p>HTTP 相应也由四个部分组成：</p>
<p>状态行、消息报头、空行、响应正文。</p>
<ul>
<li>请求方法</li>
</ul>
<p><strong>HTTP1.0</strong></p>
<p>GET，请求指定的页面信息，并返回实体主体。</p>
<p>POST，向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中，POST请求可能会导致新的资源的建立、已有资源的修改。</p>
<p>HEAD，类似于GET请求，只不过返回的响应中没有具体内容，用于获取报头。</p>
<p><strong>HTTP1.1 新增</strong></p>
<p>OPTIONS，</p>
<p>PUT，</p>
<p>DELETE，</p>
<p>TRACE，</p>
<p>CONNECT，</p>
<h3 id="Web-语言与容器"><a href="#Web-语言与容器" class="headerlink" title="Web 语言与容器"></a>Web 语言与容器</h3><h3 id="实验：抓包与重放"><a href="#实验：抓包与重放" class="headerlink" title="实验：抓包与重放"></a>实验：抓包与重放</h3><hr>
<h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><p>以下常见套路，应该都熟悉才好。</p>
<h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><h3 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h3><h3 id="爆破随机数"><a href="#爆破随机数" class="headerlink" title="爆破随机数"></a>爆破随机数</h3><h3 id="验证码识别"><a href="#验证码识别" class="headerlink" title="验证码识别"></a>验证码识别</h3><h3 id="……-3"><a href="#……-3" class="headerlink" title="……"></a>……</h3><h2 id="绕-WAF"><a href="#绕-WAF" class="headerlink" title="绕 WAF"></a>绕 WAF</h2><p>绕过拦截。</p>
<h3 id="花式绕-MySQL"><a href="#花式绕-MySQL" class="headerlink" title="花式绕 MySQL"></a>花式绕 MySQL</h3><h3 id="绕文件读取关键词检测"><a href="#绕文件读取关键词检测" class="headerlink" title="绕文件读取关键词检测"></a>绕文件读取关键词检测</h3><h3 id="……-4"><a href="#……-4" class="headerlink" title="……"></a>……</h3><h2 id="PHP-特性"><a href="#PHP-特性" class="headerlink" title="PHP 特性"></a>PHP 特性</h2><p>花式玩弄 PHP。</p>
<h3 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h3><h3 id="strpos-和"><a href="#strpos-和" class="headerlink" title="strpos 和==="></a>strpos 和===</h3><h3 id="反序列化-destruct"><a href="#反序列化-destruct" class="headerlink" title="反序列化 destruct"></a>反序列化 destruct</h3><h3 id="0-截断"><a href="#0-截断" class="headerlink" title="\0 截断"></a>\0 截断</h3><h3 id="iconv-截断"><a href="#iconv-截断" class="headerlink" title="iconv 截断"></a>iconv 截断</h3><h3 id="……-5"><a href="#……-5" class="headerlink" title="……"></a>……</h3><h2 id="密码题"><a href="#密码题" class="headerlink" title="密码题"></a>密码题</h2><h3 id="hash-长度扩展"><a href="#hash-长度扩展" class="headerlink" title="hash 长度扩展"></a>hash 长度扩展</h3><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><h3 id="移位加密各种变形"><a href="#移位加密各种变形" class="headerlink" title="移位加密各种变形"></a>移位加密各种变形</h3><h3 id="32-位随机数过小"><a href="#32-位随机数过小" class="headerlink" title="32 位随机数过小"></a>32 位随机数过小</h3><h2 id="找源码"><a href="#找源码" class="headerlink" title="找源码"></a>找源码</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><h3 id="xxx-php-swp"><a href="#xxx-php-swp" class="headerlink" title="xxx.php.swp"></a>xxx.php.swp</h3><h3 id="www-zip-tar-gz-rar-7z"><a href="#www-zip-tar-gz-rar-7z" class="headerlink" title="www.(zip|tar.gz|rar|7z)"></a>www.(zip|tar.gz|rar|7z)</h3><h3 id="xxx-php-bak"><a href="#xxx-php-bak" class="headerlink" title="xxx.php.bak"></a>xxx.php.bak</h3><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="文件后缀"><a href="#文件后缀" class="headerlink" title="文件后缀"></a>文件后缀</h3><h3 id="php345"><a href="#php345" class="headerlink" title=".php345"></a>.php345</h3><h3 id="inc"><a href="#inc" class="headerlink" title=".inc"></a>.inc</h3><h3 id="phtml"><a href="#phtml" class="headerlink" title=".phtml"></a>.phtml</h3><h3 id="phpt"><a href="#phpt" class="headerlink" title=".phpt"></a>.phpt</h3><h3 id="phps"><a href="#phps" class="headerlink" title=".phps"></a>.phps</h3><h3 id="文件内容检测"><a href="#文件内容检测" class="headerlink" title="文件内容检测"></a>文件内容检测</h3><?php <? <% <scriptlanguage=php>

### 花式解析漏洞

## MySQL

### SQL注入攻击



### 和PHP弱类型类似的特性

### 0x，0b，1e之类

### 隐式转换

## open_basedir&disable_functions花式绕过技巧

### dl

### mail

### imagick

### bash漏洞

### DirectoryIterator

### 各种二进制选手插足的方法

## 条件竞争

### 竞争删除前生成shell

### 竞争数据库无锁多扣钱

## 社工

### 花式查社工库，微博、QQ

### whois

## Windows特性

### 短文件名

### IIS解析漏洞

### NTFS文件系统通配符

### ::$DATA

### 冒号截断

## SSRF

### 花式探测端口

### 302跳转

### 花式协议利用

### gophar直接取shell

## XSS

### 各种浏览器auditor绕过

### 富文本过滤黑白名单绕过

### flash XSS

### CSP绕过

## XXE

### 各种XML存在地方

rss/word/流媒体

### 各种XXE利用方法

SSRF，文件读取

## 协议

### 花式IP伪造

X-Forwarded-For，X-Client-IP，X-Real-IP，CDN-Src-IP

### 花式改UA

### 花式藏Flag

### 花式分析数据包


---

# 练习地址

- [We Chall](http://www.wechall.net/)

- [RedTiger's Hackit](http://redtiger.labs.overthewire.org)

- [prompt](http://prompt.ml/0)

- [CTF社区](http://123.206.31.85)

- ……]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链系列——浅谈区块链</title>
    <url>/articles/Blockchain-talk-about-Blockchain.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>据中新网消息，2018 年 1 月 12 日，第二届厦门国际区块链创业高峰论坛在厦门大学举行。</p>
<p>中国社科院金融专业特聘教授王彬生则在其主题演讲《区块链技术的经济学逻辑》中称</p>
<ul>
<li><p>信息传递成本接近零是这场区块链运动的时代前提</p>
</li>
<li><p>区块链技术的普及把传统信息互联网转变成了价值互联网</p>
</li>
<li><p>传统经济状态映射到虚拟世界，现实和虚拟将进一步融合</p>
</li>
</ul>
<p>王彬生认为，区块链普及的经济本质宏观上是一场资产转移运动，传统的金融资产将逐步转移到链上。<br>近现代工业化的特征是生产、经营、消费分离，行业分工细化，而区块链人工智能时代将是三者新的融合，未来没有纯粹的金融。</p>
</blockquote>
<h1 id="区块链思想的诞生"><a href="#区块链思想的诞生" class="headerlink" title="区块链思想的诞生"></a>区块链思想的诞生</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>分布式容错性：分布式网络极其鲁棒，能够容忍部分节点的异常状态</li>
<li>不可篡改性：一致提交后的数据会一直存在，不可被销毁或修改</li>
<li>隐私保护性：密码学保证了数据隐私，即使数据泄露，也无法解析</li>
<li><strong>可信任性</strong>：区块链技术可以提供天然可信的分布式账本平台，不需要额外第三方中介机构参与</li>
<li><strong>降低成本</strong>：跟传统技术相比，区块链技术可能需要的时间、人力和维护成本更少</li>
<li><strong>增强安全</strong>：区块链技术将有利于安全、可开的审计管理和账目清算，减少犯罪风险</li>
</ul>
<span id="more"></span>

<h1 id="核心技术概览"><a href="#核心技术概览" class="headerlink" title="核心技术概览"></a>核心技术概览</h1><h2 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h2><ul>
<li>交易（transaction）：一次对账本的操作，导致账本状态的一次改变</li>
<li>区块（block）：记录一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识</li>
<li>链（chain）：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录</li>
</ul>
<p>如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中交易导致状态改变的结果进行确认。</p>
<h2 id="技术的演化与分类"><a href="#技术的演化与分类" class="headerlink" title="技术的演化与分类"></a>技术的演化与分类</h2><h3 id="演化"><a href="#演化" class="headerlink" title="演化"></a>演化</h3><ul>
<li>比特币：数字货币系统，公信的数字货币，区块链 1.0。</li>
<li>以太坊：智能合约，公信的交易处理，区块链 2.0。</li>
<li>超级账本：商业处理，带权限的分布式账本处理，区块链 3.0。</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>公有链：任何人都可以参与使用和维护，信息完全公开。</li>
<li>私有链：由集中管理者进行管理限制，只有内部少数人可以使用，信息不公开。</li>
<li>联盟链：由若干组织一起合作维护一条区块链，该区块链的使用必须是带有权限的限制访问，相关信息会得到保护。</li>
</ul>
<p>目前来看，公有链更容易吸引市场和媒体的眼球，但更多的商业价值会在联盟链和私有链上落地。</p>
<h2 id="关键问题和挑战"><a href="#关键问题和挑战" class="headerlink" title="关键问题和挑战"></a>关键问题和挑战</h2><ul>
<li>抗抵赖与隐私保护</li>
</ul>
<blockquote>
<ul>
<li><p>怎么防止交易记录被篡改？</p>
</li>
<li><p>怎么证明交易双方的身份？</p>
</li>
<li><p>怎么保护交易双方的隐私？</p>
</li>
</ul>
<p>密码学的发展为解决这些问题提供了不少手段。传统方案包括 Hash 算法、加解密算法、数字证书和签名（盲签名、换签名）等。</p>
<p>随着区块链技术的应用，新出现的需求将刺激密码学的进一步发展，包括更高效的随机数产生、更高强度的加密、更快速的加解密处理等。</p>
<p>同时，量子计算等新技术的出现，也会带来更多的挑战，例如，RSA 算法等目前商用的加密算法，在未来可能无法提供足够的安全性。</p>
<p>能否满足这些新的需求，将依赖于数学科学的进一步发展和新一代计算技术的突破。</p>
</blockquote>
<ul>
<li>分布式共识</li>
</ul>
<blockquote>
<p>问题的核心在于如何解决某个变更在分布式网络中得到一致的执行结果，是被参与多方都承认的，同时这个信息是被确定的，不可推翻的。</p>
<p>该问题在公开匿名场景下和带权限管理的场景下需求差异较大，从而导致了基于概率的算法和确定性算法两类思想。</p>
<p>比特币：PoW，工作量证明，通过概率模型。</p>
<p>超级账本：PBFT，拜占庭算法，确定性的共识机制，解决快速确认的问题。</p>
</blockquote>
<ul>
<li>交易性能</li>
</ul>
<blockquote>
<p>虽然一般来说，区块链不适用于高频交易的场景，但由于金融系统的需求，业界目前十分关心如何提高区块链系统交易的吞吐量，同时降低交易的确认延迟。</p>
<p>目前，公开的比特币区块链只能支持平均每秒约7笔的吞吐量，一般认为对于大额交易来说，安全的交易确认时间为一个小时左右。</p>
<p>以太坊区块链的吞吐量略高一些，但交易性能也被认为是较大的瓶颈。</p>
<p>总之，高性能、安全、稳定性、硬件辅助加解密能力，都将是考察节点性能的核心要素。</p>
<p>为了提高处理性能，一方面可以提升单个节点的性能（如采用高配置的硬件），同时设计优化的策略和算法；另一方面试图将大量高频的交易放到链外来，只用区块链记录最终交易信息，如比特币社区提出的“闪电网络”等设计。</p>
<p>类似地，侧链（side chain）、影子链（shadow chain）等思路在当前阶段也有一定的借鉴意义。</p>
</blockquote>
<ul>
<li>扩展性</li>
</ul>
<blockquote>
<p>常见的分布式系统可以通过增加节点来横向扩展整个系统的处理能力。</p>
<p>对于区块链网络系统来说，根据共识机制的不同，这个问题往往并非那么简单。</p>
<p>例如，对于比特币和以太坊区块链而言，网络中每个参与维护的核心节点都要保持一份完整的存储，并且进行智能合约的处理。此时，整个网络的总存储量和计算能力取决于单个节点的能力。甚至当网络中节点数过多时，可能会因为一致性的达成过程延迟降低整个网络的性能。尤其在公有网络中，由于存在大量低性能处理节点，导致这个问题将更加明显。</p>
<p>要解决这个问题，根本上是放松对每个节点都必须参与完整处理的限制，这个思路已经在超级账本中得到应用；同时尽量减少核心层的处理工作。</p>
<p>在联盟链模式下，还可以专门采用高性能的节点作为核心节点，相对较弱的节点仅作为代理访问节点。</p>
</blockquote>
<ul>
<li>安全防护</li>
</ul>
<blockquote>
<p>世界上没有绝对安全的系统。</p>
<p>系统是由人设计的，也是由人来运营的。只要有人参与的系统，就难免出现漏洞。</p>
<p>如下几个方面很难避免。</p>
<ul>
<li>立法：对区块链系统如何进行监管？攻击区块链系统是否属于犯罪？目前还没有任何法律保护区块链（特别是公有链）以及基于它的实现。</li>
<li>软件实现的潜在漏洞：源代码完全开放，是否更容易被人找到漏洞呢？</li>
<li>隐私保护：公有链所有交易记录都是公开可见的，这意味着所有的交易几十被匿名化和加密处理，但总会在未来某天被破解。安全界一般认为，只要物理上可接触就不是彻底的安全。</li>
<li>系统维护：作为一套完全分布式的系统，公有区块链缺乏有效的调整机制，一旦运行起来，出现问题难以修正以及升级；即使是让它变得更高效、更完善的修改，只要部分既得利益者联合起来反对，就无法得到实施。</li>
<li>监管审核：智能合约应用五花八门，有些可能存在潜在的漏洞，但是无法进行有效安全管控。</li>
</ul>
</blockquote>
<ul>
<li>数据库和存储系统</li>
</ul>
<blockquote>
<p>“块数据库”（BlockDB），专门服务类似于区块链这样的新型数据业务，其中每条记录将包括一个完整的区块信息，并天然地跟历史信息进行关联，一旦写入确认则无法修改。所有操作的最小单位将是一个块。为了实现这种结构，需要原生支持高效的签名和加解密处理。</p>
</blockquote>
<ul>
<li>集成和运营</li>
</ul>
<blockquote>
<p>即便大量企业系统准备迁移到区块链平台上，但在相当长的一段时间内，基于区块链的新业务系统必将与已有的中心化系统集成共存。</p>
<p>两种系统如何共存，如何分工，彼此的业务交易如何进行合理传递？出现故障如何排查和隔离？已有数据如何在不同系统之间进行迁移和灾备？区块链系统自身又该如何进行运营（如网络的设计选择、状态监控、灾备等）？</p>
<p>这些都是迫切需要解决的实际问题。若解决不好，将是区块链技术落地的不小阻碍。</p>
</blockquote>
<h2 id="认识上的误区"><a href="#认识上的误区" class="headerlink" title="认识上的误区"></a>认识上的误区</h2><p>目前，由于区块链自身仍是一种相对年轻的技术，不少人对区块链的认识还存在一些误区。<br>下面是需要注意的一些问题：</p>
<p><strong>区块链不等于比特币。</strong>虽说区块链的基本思想诞生于比特币的设计中，但发展至今日，比特币和区块链已经俨然成为了两个不太相关的技术。前者更侧重从数字货币角度发掘比特币的实验性意义；后者则从技术层面探讨和研究可能带来的商业系统价值，试图在更多的场景下释放智能合约和分分布式账本带来的科技潜力。</p>
<p><strong>区块链不等于数据库。</strong>虽然区块链也可以用来存储数据，但它要解决的核心问题是多方的互信问题。单纯从存储数据角度，它的效率可能不高，也不推荐把大量的原始数据放到区块链系统上。当然，现在已有的区块链系统中，数据库相关的技术十分关键，直接决定了区块链系统的吞吐性能。</p>
<p><strong>区块链并非一门万能的颠覆性技术。</strong>作为融合多项已有技术而出现的新事物，区块链跟现有技术的关系是一脉相承的。它在解决多方合作和可信处理上向前多走了一步，但并不意味着它是万能的，更不会彻底颠覆已有的商业模式。很长一段时间里，区块链所适用的场景仍需不断摸索，并且跟已有系统也必然是长期合作共存的关系。</p>
<h1 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h1><h2 id="应用场景概览"><a href="#应用场景概览" class="headerlink" title="应用场景概览"></a>应用场景概览</h2><p>区块链技术已经从单纯的技术讨论走向了应用落地的阶段。</p>
<p>实际上，要找到合适的应用场景，还是要从区块链自身的特性出发进行分析。</p>
<p>区块链在不引入第三方中介机构的前提下，可以提供去中心化、不可篡改、安全可靠等特性保证。因此，所有直接或间接依赖于第三方担保机构的活动，均可能从区块链技术中获益。</p>
<p>区块链自身维护着一个按时间顺序持续增长、不可篡改的数据记录，当现实或数字世界中的资产可以生成数字摘要时，区块链便成为确权类应用的完美载体，提供包含所属权和时间戳的数字证据。</p>
<p>可编程的智能合约使得在区块链上登记的资产可以获得在现实世界中难以提供的流动性，并能够保证合约规则的透明和不可篡改。这就为区块链上诞生更多创新的经济活动提供了土壤，为社会资源价值提供更加高效且安全的流动渠道。</p>
<p>此外，还需要思考区块链解决方案的合理辩解。面向大众消费者的区块链应用需要做到公开、透明、可审计，既可以部署在无边界的公有链，也可以部署在应用生态内多中心节点共同维护的区块链；面向企业内部或多个企业间的商业区块链场景，则可将区块链的维护节点和可见性限制在联盟内部，并用智能合约重点解决联盟成员间的信任或信息不对等问题，以提高经济活动效率。</p>
<h2 id="金融服务"><a href="#金融服务" class="headerlink" title="金融服务"></a>金融服务</h2><p>区块链带来的潜在优势包括降低交易成本、减少跨组织交易风险等。该领域的区块链应用目前最受关注，全球不少银行和金融交易机构都是主力推动者。部分投资机构也在应用区块链技术降低管理成本和管控风险。从另一方面，要注意可能引发的问题和风险。</p>
<h3 id="银行业金融管理"><a href="#银行业金融管理" class="headerlink" title="银行业金融管理"></a>银行业金融管理</h3><p>银行从角色上一般可分为中央银行（央行）和普通银行。</p>
<p>中央银行的两大职能是“促进宏观经济稳定”和“维护金融稳定”，主要手段就是管理各种证券和利率。中央银行，为整个社会的金融体系提供了最终的信用担保。</p>
<p>普通银行业则往往基于央行的信用，作为中介和担保方，来协助完成多方的金融交易。</p>
<p>银行活动主要包括发行货币、完成存贷款等功能。银行必须确保交易的确定性，必须确立自身的可靠信用地位。传统的金融系统为了完成上述功能，采用了极为复杂的软件和硬件方案，建设和维护成本都十分昂贵。即便如此，这些系统仍然存在诸多缺陷，例如某些场景下交易时延过大；难以避免利用系统漏洞进行的攻击和金融欺诈等。</p>
<p>此外，在目前金融系统流程中，商家为了完成交易，还常常需要经由额外的支付企业进行处理。这些实际上都极大增加了现有金融交易的成本。</p>
<p>区块链技术的出现，被认为是有可能促使这一行业发生革命性变化的“奇点”。除了众所周知的比特币等数字货币实验之外，还有诸多金融机构进行了有意义的尝试。</p>
<h4 id="欧洲央行评估区块链在证券交易后结算的应用"><a href="#欧洲央行评估区块链在证券交易后结算的应用" class="headerlink" title="欧洲央行评估区块链在证券交易后结算的应用"></a>欧洲央行评估区块链在证券交易后结算的应用</h4><p>目前，全球证券交易后的处理过程十分复杂，清算行为成本约 50 亿 ～ 100 亿美元，交易后分析、对账和处理费用超过 200 亿美元。</p>
<p>来自欧洲央行的一份报告显示，区块链作为分布式账本技术，可以很好地节约对账的成本，同时简化交易过程。相对原先的交易过程，可以近乎实时地变更证券的所有权。</p>
<h4 id="中国人民银行投入区块链研究"><a href="#中国人民银行投入区块链研究" class="headerlink" title="中国人民银行投入区块链研究"></a>中国人民银行投入区块链研究</h4><p>前不久，中国人民银行对外发布消息，称深入研究了数字货币涉及的相关技术，包括区块链技术、移动支付、可信可控云计算、密码算法、安全芯片等，是积极关注区块链技术的发展的。实际上，央行对于区块链技术的研究很早便已开展。</p>
<p>2014 年，央行成立发行数字货币的专门研究小组对基于区块链的数字货币进行研究，次年形成研究报告。</p>
<p>2016 年 1 月 20 日，央行专门组织了“数字货币研讨会”，邀请了业内的区块链技术专家就数字货币发行的总体框架、演进以及国家加密货币等话题进行了研讨。会后，发布对我国银行业数字货币的战略性发展思路，提出要早日发行数字货币，并利用数字货币相关技术来打击金融犯罪活动。</p>
<p>2016 年 12 月，央行成立数字货币研究所。初步公开设计为由央行主导，在保持实物现金发行的同时发行以加密算法为基础的数字货币，M0（流通中的现金）的一部分由数字货币构成。为充分保障数字货币的安全性，发行者可采用安全芯片为载体来保护密钥和算法运算过程的安全。</p>
<h4 id="加拿大银行提出新的数字货币-CAD"><a href="#加拿大银行提出新的数字货币-CAD" class="headerlink" title="加拿大银行提出新的数字货币 CAD"></a>加拿大银行提出新的数字货币 CAD</h4><p>2016 年 6 月，加拿大央行公开了正在开发基于区块链技术的数字版加拿大元（名称为CAD币），以允许用户使用加元来兑换该数字货币。经过验证的对手方将会处理货币交易；另外，如果需要，银行将保留销毁 CAD 币的权利。</p>
<p>发行 CAD 币是更大的一个探索型科技项目 Jasper 的一部分。除了加拿大央行外，蒙特利尔银行、加拿大帝国商业银行、加拿大皇家银行、加拿大丰业银行、多伦多道明银行等多家机构也都参与了该项目。</p>
<h4 id="英国央行实现-RSCoin"><a href="#英国央行实现-RSCoin" class="headerlink" title="英国央行实现 RSCoin"></a>英国央行实现 RSCoin</h4><p>英国央行在数字化货币方面进展十分突出，已经实现了基于分布式账本平台的数字化货币系统，RSCoin。旨在强化本国经济及国际贸易。</p>
<p>RSCoin 目标是提供一个由中央银行控制的数字货币，采用了双层链架构、改进版的两阶段提交（Two Phase Commitment，2PC）提交，以及多链之间的交叉验证机制。该货币具备防篡改和伪造的特性。</p>
<p>因为该系统主要是央行和下属银行之间使用，通过提前建立一定的信任基础，可以提供较好的处理性能。</p>
<p>英国央行对 RSCoin 进行了推广，希望能尽快普及该数字货币，以带来节约经济成本、促进经济发展的效果。同时，英国央行认为，数字货币相对于传统货币更适合国际贸易等场景。</p>
<h4 id="日本政府取消比特币消费税"><a href="#日本政府取消比特币消费税" class="headerlink" title="日本政府取消比特币消费税"></a>日本政府取消比特币消费税</h4><p>2017 年 3 月 27 日，日本国会通过《2017 税务改革法案》，该法案将比特币等数字货币定义为货币等价物，可以用于数字支付和转账。</p>
<p>法案于 2017 年 7 月 1 日生效，销售数字货币不必再缴纳 8% 的消费税。</p>
<h4 id="中国邮储银行将区块链技术应用到核心业务系统"><a href="#中国邮储银行将区块链技术应用到核心业务系统" class="headerlink" title="中国邮储银行将区块链技术应用到核心业务系统"></a>中国邮储银行将区块链技术应用到核心业务系统</h4><p>2016 年 10 月，中国邮储银行宣布携手IBM推出基于区块链技术的资产托管系统，是中国银行业首次将区块链技术成功应用于核心业务系统。</p>
<p>新的业务系统免去了重复的信用校验过程，将原有业务环节缩短了约 60% ～ 80% 的时间，提高了信用交易的效率。</p>
<h4 id="各种新型支付业务"><a href="#各种新型支付业务" class="headerlink" title="各种新型支付业务"></a>各种新型支付业务</h4><p>基于区块链技术，出现了大量的创新支付企业，这些支付企业展示了利用区块链技术带来的巨大商业优势。</p>
<ul>
<li><p>Abra：区块链数字钱包，以近乎实时的速度进行跨境支付，无需银行账户和手续费，融资超过千万美元；</p>
</li>
<li><p>Bitwage：基于比特币区块链的跨境工资支付平台，可以实现每小时的工资支付，方便跨国企业进行工资管理；</p>
</li>
<li><p>BitPOS：澳大利亚创业企业，提供基于比特币的低成本的快捷线上支付；</p>
</li>
<li><p>Circle：由区块链充当支付网络，允许用户进行跨币种、跨境的快速汇款。Circle 获得了来自 IDG、百度的超过 6000 万美元的 D 轮投资；</p>
</li>
<li><p>Ripple：实现跨境的多币种、低成本、实时交易，引入了网关概念（类似于银行），结构偏中心化。</p>
</li>
</ul>
<h3 id="证券交易"><a href="#证券交易" class="headerlink" title="证券交易"></a>证券交易</h3><p>证券交易包括交易执行环节和交易后处理环节。</p>
<p>交易环节本身相对简单，主要是由交易系统（高性能实时处理系统）完成电子数据库中内容的变更。中心化的验证系统往往极为复杂和昂贵。交易指令执行后的结算和清算环节也十分复杂，需要大量的人力成本和时间成本，并且容易出错。</p>
<p>目前来看，基于区块链的处理系统还难以实现海量交易系统所需要的性能（典型性能为每秒一万笔以上成交，日处理能力超过五千万笔委托、三千万笔成交）。但在交易的审核和清算环节，区块链技术存在诸多的优势，可以极大降低处理时间，同时减少人工的参与。</p>
<p>咨询公司 Oliver Wyman 在给 SWIFT（环球同业银行金融电讯协会）提供的研究报告中预计，全球清算行为成本约 50 亿 ～ 100 亿美元，结算成本、托管成本和担保物管理成本 400 亿 ～ 450 亿美元（390亿美元为托管链的市场主体成本），而交易后流程数据及分析花费200亿～250亿美元。</p>
<p>2015 年 10 月，美国纳斯达克（Nasdaq）证券交易所推出区块链平台 Nasdaq Linq，实现主要面向一级市场的股票交易流程。通过该平台进行股票发行的发行者将享有“数字化”的所有权。</p>
<p>其他相关案例还包括：</p>
<ul>
<li><p>BitShare 推出基于区块链的证券发行平台，号称每秒达到 10 万笔交易；</p>
</li>
<li><p>DAH 为金融市场交易提供基于区块链的交易系统。获得澳洲证交所项目；</p>
</li>
<li><p>Symbiont 帮助金融企业创建存储于区块链的智能债券，当条件符合时，清算立即执行；</p>
</li>
<li><p>Overstock.com 推出基于区块链的私有和公开股权交易“T0”平台，提出“交易即结算”（The trade is the settlement）的理念，主要目标是建立证券交易实时清算结算的全新系统；</p>
</li>
<li><p>高盛为一种叫做“SETLcoin”的新虚拟货币申请专利，用于为股票和债券等资产交易提供“近乎立即执行和结算”的服务。</p>
</li>
</ul>
<h3 id="众筹投资"><a href="#众筹投资" class="headerlink" title="众筹投资"></a>众筹投资</h3><p>作为去中心化的众筹管理的代表，DAO（Decentralized Autonomous Organization）曾创下历史最高的融资记录，数额超过 1.6 亿美元。</p>
<p>值得一提的是，DAO 的组织形式十分创新，也造成其在受到攻击后的应对缺乏经验。项目于 2016 年 4 月 30 日开始正式上线。6 月 12 日，有技术人员报告合约执行过程中存在软件漏洞，但很遗憾并未得到组织的重视和及时修复。四天后，黑客利用漏洞转移了 360 万枚以太币，当时价值超过 5000 万美元。</p>
<p>虽然，最后相关组织采用了一些技术手段来挽回损失，但该事件毫无疑问给以太币带来了负面影响，也给新兴技术在新模式下的业务流程管理敲响了警钟。</p>
<p>除了 DAO 这种创新组织形式之外，传统风投基金也开始尝试用区块链募集资金。Blockchain Capital 在 2017 年发行的一支基金创新地采用了传统方式加 ICO（Initial Coin Offering）方式进行募资，其中传统部分规模 4000 万美元，ICO 部分规模 1000 万美元。4 月 10 日，ICO 部分 1000 万美元的募集目标在启动后六小时内全部完成。</p>
<p>用 ICO 方式进行众筹可以降低普通投资者对早期项目的参与门槛，并提高项目资产流动性。目前对于 ICO 的众筹模式缺少明确的法律法规，对项目的商业模式也很难按照传统方法进行估值与代币定价。但随着项目发起人开始重视对底层技术、资金使用和项目发展的信息披露，大众投资者开始加深理解区块链技术及其可行的应用场景，将有助于促进这种新兴模式的健康发展。</p>
<h2 id="征信和权属管理"><a href="#征信和权属管理" class="headerlink" title="征信和权属管理"></a>征信和权属管理</h2><p>征信和权属的数字化管理师大型社交平台和保险公司都梦寐以求的。目前该领域的主要问题包括缺乏足够的数据和分析能力；缺乏可靠的平台支持以及有效的数据整合管理等。区块链被认为可以促进数据交易和流动，提供安全可靠的支持。征信行业的门槛比较高，需要多方资源共同推动。</p>
<h3 id="征信管理"><a href="#征信管理" class="headerlink" title="征信管理"></a>征信管理</h3><p>征信管理是一个巨大的潜在市场，据称超过千亿规模，也是目前大数据应用领域最有前途的方向之一。</p>
<p>目前，与征信相关的大量有效数据集中在少数机构手中。由于这些数据太过敏感，并且具备极高的商业价值，往往会被严密保护起来，形成很高的行业门槛。</p>
<p>虽然现在大量的互联网企业（包括各类社交网站）尝试从各种维度获取了海量的用户信息，但从征信角度看，这些数据仍然存在若干问题。这些问题主要包括：</p>
<ul>
<li><p>数据量不足：数据量越大，能获得的价值自然越高，数据量过少则无法产生有效价值；</p>
</li>
<li><p>相关度较差：最核心的数据也往往是最敏感的。在隐私高度敏感的今天，用户都不希望暴露过多数据给第三方，因此企业获取到数据中有效成分往往很少；</p>
</li>
<li><p>时效性不足：企业可以从明面上获取到的用户数据往往是过时的，甚至存在虚假信息，对相关分析的可信度造成严重干扰；</p>
</li>
<li><p>数据孤岛：数据过于分散，没有能将不同类型数据联系在一起的纽带。</p>
</li>
</ul>
<p>区块链天然存在着无法篡改、不可抵赖的特性。同时，区块链平台将可能提供前所未有规模的相关性极高的数据，这些数据可以在时空中准确定位，并严格关联到用户。因此，基于区块链提供数据进行征信管理，将大大提高信用评估的准确率，同时降低评估成本。</p>
<p>另外，跟传统依靠人工的审核过程不同，区块链中交易处理完全遵循约定自动化执行。基于区块链的信用机制将天然具备稳定性和中立性。</p>
<p>目前，包括 IDG、腾讯、安永、普华永道等都已投资或进入基于区块链的征信管理领域，特别是跟保险和互助经济相关的应用场景。</p>
<p>2016 年 7 月，德勤、Stratumn 和 LemonWay 共同推出一个为共享经济场景设计的“微保险”概念平台，称为 LenderBot。针对共享经济活动中临时交换资产可能产生的风险，LenderBot 允许用户在区块链上注册定制的微保险，并为共享的资产（如相机、手机、电脑）投保。区块链在其中扮演了可信第三方的角色。</p>
<h3 id="权属管理"><a href="#权属管理" class="headerlink" title="权属管理"></a>权属管理</h3><p>区块链技术可以用于产权、版权等所有权的管理和追踪。其中包括汽车、房屋、艺术品等各种贵重物品的交易等，也包括数字出版物，以及可以标记的数字资源。</p>
<p>目前权属管理领域存在的几个难题是：</p>
<ul>
<li><p>所有权的确认和管理；</p>
</li>
<li><p>交易的安全性和可靠性保障；</p>
</li>
<li><p>必要的隐私保护机制。</p>
</li>
</ul>
<p>以房屋交易为例。买卖双方往往需要依托中介机构来确保交易的进行，并通过纸质的材料证明房屋所有权。但实际上，很多时候中介机构也无法确保交易的正常进行。</p>
<p>而利用区块链技术，物品的所有权是写在数字链上的，谁都无法修改。并且一旦出现合同中约定情况，区块链技术将确保合同能得到准确执行。这能有效减少传统情况下纠纷仲裁环节的人工干预和执行成本。</p>
<p>例如，公正通（Factom）尝试使用区块链技术来革新商业社会和政府部门的数据管理和数据记录方式。包括审计系统、医疗信息记录、供应链管理、投票系统、财产契据、法律应用、金融系统等。它将待确权数据的指纹存放到基于区块链的分布式账本中，可以提供资产所有权的追踪服务。</p>
<p>区块链账本共享、信息可追踪溯源且不可篡改的特性同样可用于打击造假和防范欺诈。Everledger 自 2016 年起就研究基于区块链技术实现贵重资产检测系统，将钻石或者艺术品等的权属信息记录在区块链上，并于 2017 年宣布与 IBM 合作，实现生产商、加工商、运送方、零售商等多方之间的可信高效协作。</p>
<h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><p>在人力资源和教育领域，MIT研究员朱莉安娜·纳扎雷（Juliana Nazaré）和学术创新部主管菲利普·施密特（Philipp Schmidt）发表了文章《MIT Media Lab Uses the Bitcoin Blockchain for Digital Certificates》，介绍基于区块链的学历认证系统。基于该系统，用人单位可以确认求职者的学历信息是否真实可靠。</p>
<p>此外，还包括一些其他相关的应用项目：</p>
<ul>
<li><p>Chronicled：基于区块链的球鞋鉴定方案，为正品球鞋添加电子标签，记录在区块链上；</p>
</li>
<li><p>Mediachain：通过metadata协议，将内容创造者与作品唯一对应。</p>
</li>
<li><p>Monegraph：通过区块链保障图片版权的透明交易；</p>
</li>
<li><p>Mycelia：区块链产权保护项目，为音乐人实现音乐的自由交易；</p>
</li>
<li><p>Tierion：将用户数据锚定在比特币区块链上，并生成“区块链收据”。</p>
</li>
</ul>
<h2 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h2><p>当前，以 Uber、Airbnb 为代表的共享经济模式正在多个垂直领域冲击传统行业。这一模式鼓励人们通过互联网的方式共享闲置资源。资源共享目前面临的问题主要包括：</p>
<ul>
<li><p>共享过程成本过高；</p>
</li>
<li><p>用户行为评价难；</p>
</li>
<li><p>共享服务管理难。</p>
</li>
</ul>
<p>区块链技术为解决上述问题提供了更多的可能性。相比于依赖于中间方的资源共享模式，基于区块链的模式有潜力更直接地连接资源的供给方和需求方，其透明、不可篡改的特性有助于减小摩擦。</p>
<p>有人认为区块链技术会成为新一代共享经济的基石。笔者认为，区块链在资源共享领域是否存在价值，还要看能否比传统的专业供应者或中间方形式实现更高的效率和更低的成本，同时不能损害用户体验。以 Airbnb 为代表的分享经济公司将欢迎去中心化应用，可以降低管理成本。该领域主题相对集中，设计空间大，受到大量的投资关注。</p>
<h3 id="短租共享"><a href="#短租共享" class="headerlink" title="短租共享"></a>短租共享</h3><p>大量提供短租服务的公司已经开始尝试用区块链来解决共享中的难题。高盛在报告《Blockchain：Putting Theory into Practice》中宣称：</p>
<p>Airbnb 等 P2P 住宿平台已经开始通过利用私人住所打造公开市场来变革住宿行业，但是这种服务的接受程度可能会因人们对人身安全以及财产损失的担忧而受到限制。而如果通过引入安全且无法篡改的数字化资质和信用管理系统，我们认为区块链就能有助于提升 P2P 住宿的接受程度。</p>
<p>该报告还指出，可能采用区块链技术的企业包括 Airbnb、HomeAway 以及 OneFineStay 等，市场规模为 30 亿 ～ 90 亿美元。</p>
<h3 id="社区能源共享"><a href="#社区能源共享" class="headerlink" title="社区能源共享"></a>社区能源共享</h3><p>在纽约布鲁克林的一个街区，已有项目尝试将家庭太阳能发的电通过社区的电力网络直接进行买卖。具体的交易不再经过电网公司，而是通过区块链执行。</p>
<p>与之类似，ConsenSys 和微电网开发商 LO3 提出共建光伏发电交易网络，实现点对点的能源交易。</p>
<p>这些方案的主要难题包括：</p>
<ul>
<li><p>太阳能电池管理；</p>
</li>
<li><p>太阳能电池管理；</p>
</li>
<li><p>电力储备系统搭建；</p>
</li>
<li><p>低成本交易系统支持。</p>
</li>
</ul>
<p>现在已经有大量创业团队在解决这些问题，特别是硬件部分已经有了不少解决方案。而通过区块链技术打造的平台可以解决最后一个问题，即低成本地实现社区内的可靠交易系统。</p>
<h3 id="电商平台"><a href="#电商平台" class="headerlink" title="电商平台"></a>电商平台</h3><p>传统情况下，电商平台起到了中介的作用。一旦买卖双方发生纠纷，电商平台会作为第三方机构进行仲裁。这种模式存在着周期长、缺乏公证、成本高等缺点。OpenBazaar 试图在无中介的情形下，实现安全电商交易。OpenBazaar 提供的分布式电商平台，通过多方签名机制和信誉评分机制，让众多参与者合作进行评估，实现零成本解决纠纷问题。</p>
<h3 id="大数据共享"><a href="#大数据共享" class="headerlink" title="大数据共享"></a>大数据共享</h3><p>大数据时代里，价值来自于对数据的挖掘，数据维度越多，体积越大，潜在价值也就越高。一直以来，比较让人头疼的问题是如何评估数据的价值，如何利用数据进行交换和交易，以及如何避免宝贵的数据在未经许可的情况下泄露出去。</p>
<p>区块链技术为解决这些问题提供了潜在的可能。利用共同记录的共享账本，数据在多方之间的流动将得到实时的追踪和管理。通过对敏感信息的脱敏处理和访问权限的设定，区块链可以对大数据的共享授权进行精细化管控、规范，促进大数据的交易与流通。</p>
<h3 id="减小共享风险"><a href="#减小共享风险" class="headerlink" title="减小共享风险"></a>减小共享风险</h3><p>传统的资源共享平台在遇到经济纠纷时会充当调解和仲裁者的角色。对于区块链共享平台，目前还存在线下复杂交易难以数字化等问题。除了引入信誉评分、多方评估等机制，也有方案提出引入保险机制来对冲风险。</p>
<p>2016 年 7 月，德勤、Stratumn 和 LemonWay 共同推出一个为共享经济场景设计的“微保险”概念平台，称为 LenderBot。针对共享经济活动中临时交换资产可能产生的风险，LenderBot 允许用户在区块链上注册定制的微保险，并为共享的资产（如相机、手机、电脑）投保。区块链在其中扮演了可信第三方和条款执行者的角色。</p>
<h2 id="贸易管理"><a href="#贸易管理" class="headerlink" title="贸易管理"></a>贸易管理</h2><p>区块链技术可以帮助自动化国际贸易和物流供应链领域中繁琐的手续和流程。基于区块链设计的贸易管理方案回味参与的多方企业带来极大的便利。另外，贸易中小手和法律合同的数字化、货物监控与检测、实时支付等方向都可能成为创业公司的突破口。</p>
<h3 id="跨境贸易"><a href="#跨境贸易" class="headerlink" title="跨境贸易"></a>跨境贸易</h3><p>在国际贸易活动中，买卖双方可能互不信任。因此需要银行作为买卖双方的保证人，代为收款交单，并以银行信用代替商业信用。</p>
<p>区块链可以为信用证交易参与方提供共同账本，允许银行和其他参与方拥有经过确认的共同交易记录并据此履约，从而降低风险和成本。</p>
<p>巴克莱银行用区块链进行国际贸易结算—— 2016 年 9 月，英国巴克莱银行用区块链技术完成了一笔国际贸易的结算，贸易金额 10 万美元，出口商品是爱尔兰农场出产的芝士和黄油，进口商是位于离岸群岛塞舌尔的一家贸易商。结算用时不到 4 小时，而传统采用信用证方式做此类结算需要 7 到 10 天。</p>
<p>在这笔贸易背后，区块链提供了记账和交易处理系统，替代了传统信用证结算过程中占用大量人力和时间的审单、制单、电报或邮寄等流程。</p>
<h3 id="物流供应链"><a href="#物流供应链" class="headerlink" title="物流供应链"></a>物流供应链</h3><p>物流供应链是区块链一个很有前景的应用方向。供应链行业往往涉及诸多实体，包括物流、资金流、信息流等，这些实体之间存在大量复杂的协作和沟通。传统模式下，不同实体各自保存各自的供应链信息，严重缺乏透明度，造成了较高的时间成本和金钱成本，而且一旦出现问题（冒领、货物假冒等），难以追查和处理。</p>
<p>通过区块链，各方可以获得一个透明可靠的统一信息平台，可以实时查看状态，降低物流成本，追溯物品的生产和运送整个过程，从而提高供应链管理的效率。当发生纠纷时，举证和追查也变得更加清晰和容易。</p>
<p>例如，运送方通过扫描二维码来证明货物到达指定区域，并自动收取提前约定的费用；冷链运输过程中通过温度传感器实时检测货物的温度信息并记录在链等。来自美国加州的Skuchain公司创建基于区块链的新型供应链解决方案，实现商品流与资金流的同步，同时缓解假货问题。</p>
<p>马士基推出基于区块链的跨境供应链解决方案—— 2017 年 3 月，马士基和IBM宣布，计划与由货运公司、货运代理商、海运承运商、港口和海关当局构成的物流网络合作构建一个新型全球贸易数字化解决方案。该方案利用区块链技术在各方之间实现信息透明性，降低贸易成本和复杂性，旨在帮助企业减少欺诈和错误，缩短产品在运输和海运过程中所花的时间，改善库存管理，最终减少浪费并降低成本。马士基在 2014 年发现，仅仅是将冷冻货物从东非运到欧洲，就需要经过近 30 个人员和组织进行超过 200 次的沟通和交流。类似这样的问题都有望借助区块链进行解决。</p>
<h3 id="一带一路"><a href="#一带一路" class="headerlink" title="一带一路"></a>一带一路</h3><p>类似“一带一路”这样创新的投资建设模式，会碰到来自地域、货币、信任等各方面的挑战。</p>
<p>现在已经有一些参与到一带一路中的部门，对区块链技术进行探索应用。区块链技术可以让原先无法交易的双方（例如，不存在多方都认可的国际货币储备的情况下）顺利完成交易，并且降低贸易风险、减少流程管控的成本。</p>
<h2 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h2><p>曾经有人认为，物联网是大数据时代的基础。</p>
<p>笔者认为，区块链技术是物联网时代的基础。</p>
<p>物联网也是很适合应用区块链技术的一个领域，预计未来几年会有大量应用出现，特别是租赁。物流等特定场景，都是很适合区块链技术的场景。但目前阶段，物联网自身的技术局限将造成短期内不会出现大规模应用。</p>
<h3 id="典型应用场景分析"><a href="#典型应用场景分析" class="headerlink" title="典型应用场景分析"></a>典型应用场景分析</h3><p>一种可能的应用场景为：物联网络中每一个设备分配地址，给该地址关联一个账户，用户通过向账户中支付费用可以租借设备，以执行相关动作，从而达到租借物联网的应用。</p>
<p>典型的应用包括 PM2.5 监测点的数据获取、温度检测服务、服务器租赁、网络摄像头数据调用，等等。</p>
<p>另外，随着物联网设备的增多、边沿计算需求的增强，大量设备之间形成分布式自组织的管理模式，并且对容错性要求很高。区块链技术所具备的分布式和抗攻击特点可以很好地融合到这一场景中。</p>
<h3 id="IBM"><a href="#IBM" class="headerlink" title="IBM"></a>IBM</h3><p>IBM 在物联网领域已经持续投入了几十年的研发，目前正在探索使用区块链技术来降低物联网应用的成本。2015 年的年初，IBM 与三星宣布合作研发“去中心化的 P2P 自动遥测系统”（Autonomous Decentralized Peer-to-Peer Telemetry）系统，使用区块链作为物联网设备的共享账本，打造去中心化的物联网。</p>
<h3 id="Filament"><a href="#Filament" class="headerlink" title="Filament"></a>Filament</h3><p>美国的 Filament 公司以区块链为基础提出了一套去中心化的物联网软件堆栈。通过创建一个智能设备目录，Filament 的物联网设备可以进行安全沟通、执行智能合约以及发送小额交易。</p>
<p>基于上述技术，Filament 能够通过远程无线网络将辽阔范围内的工业基础设备沟通起来，其应用包括追踪自动售货机的存货和机器状态、检测铁轨的损耗、基于安全帽或救生衣的应急情况监测等。</p>
<h3 id="NeuroMesh"><a href="#NeuroMesh" class="headerlink" title="NeuroMesh"></a>NeuroMesh</h3><p>2017 年 2 月，源自 MIT 的 NeuroMesh 物联网安全平台获得了 MIT 100K Accelerate竞赛的亚军。该平台致力于成为“物联网疫苗”，能够检测和消除物联网中的有害程序，并将攻击源打入黑名单。</p>
<p>所有运行NeuroMesh软件的物联网设备都通过访问区块链账本来识别其他节点和辨认潜在威胁。如果一个设备借助深度学习功能检测出可能的威胁，可通过发起投票的形式告知全网，由网络进一步对该威胁进行检测并做出处理。</p>
<h3 id="公共网络服务"><a href="#公共网络服务" class="headerlink" title="公共网络服务"></a>公共网络服务</h3><p>现有的互联网能正常运行，离不开很多近乎免费的网络服务，例如域名服务（DNS）。任何人都可以免费查询到域名，没有 DNS，现在的各种网站将无法访问。因此，对于网络系统来说，类似的基础服务必须要能做到安全可靠，并且低成本。</p>
<p>区块链技术恰好具备这些特点，基于区块链打造的分布式DNS系统，将减少错误的记录和查询，并且可以更加稳定可靠地提供服务。</p>
<h2 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h2><p>区块链还有一些很有趣的应用场景，包括但不限于云存储、医疗、社交、游戏等多个方面。</p>
<h3 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h3><p>Storj 项目提供了基于区块链的安全分布式云存储服务。服务保证只有用户自己能看到自己的数据，并号称提供高速的下载速度和 99.99999% 的高可用性。用户还可以“出租”自己的额外硬盘空间来获得报酬。</p>
<p>协议设计上，Storj 网络中的节点可以传递数据、验证远端数据的完整性和可用性、复原数据，以及商议合约和向其他节点付费。数据的安全性由数据分片（data sharding）和端到端加密提供，数据的完整性由可复原性证明（proof of retrievability）提供。</p>
<h3 id="医疗"><a href="#医疗" class="headerlink" title="医疗"></a>医疗</h3><p>医院与医保医药公司，不同医院之间，甚至医院里不同部门之间的数据流动性往往很差。考虑到医疗健康数据的敏感性，笔者认为，如果能够满足数据访问权、使用权等规定的基础上促进医疗数据的提取和流动，区块链将在医疗行业获得一定的用武之地。</p>
<p>GemHealth 项目由区块链公司 Gem 于 2016 年 4 月提出，其目标除了用区块链存储医疗记录或数据，还包括借助区块链增强医疗健康数据在不同机构不同部门间的安全可转移性、促进全球病人身份识别、医疗设备数据安全收集与验证等。项目已与医疗行业多家公司签订了合作协议。</p>
<h3 id="通信和社交"><a href="#通信和社交" class="headerlink" title="通信和社交"></a>通信和社交</h3><p>BitMessage 是一套去中心化通信系统，在点对点通信的基础上保护用户的匿名性和信息的隐私。BitMessage 协议在设计上充分参考了比特币，二者拥有相似的地址编码机制和消息传递机制。BitMessage 也用“工作量证明”机制防止通信网络受到大量垃圾信息的冲击。</p>
<p>类似的，Twister 是一套去中心化的“微博”系统，Dot-Bit 是一套去中心化的 DNS 系统。</p>
<h3 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h3><p>Follow My Vote 项目致力于提供一个安全、透明的在线投票系统。通过使用该系统进行选举投票，投票者可以随时检查自己选票的存在和正确性，看到实时记票结果，并在改变主意时修改选票。</p>
<p>该项目使用区块链进行记票，并开源其软件代码供社区用户审核。项目也为投票人身份认证、防止重复投票、投票隐私等难点问题提供了解决方案。</p>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>Augur 是一个运行在以太坊上的预测市场平台。使用 Augur，来自全球不同地方的任何人都可发起自己的预测话题市场，或随意加入其他市场，来预测一些事件的发展结果。预测结果和奖金结算由智能合约严格控制，使得在平台上博弈的用户不用为安全性产生担忧。</p>
<h3 id="电子游戏"><a href="#电子游戏" class="headerlink" title="电子游戏"></a>电子游戏</h3><p>2017年3月，来自马来西亚的电子游戏工作室Xhai Studios宣布将区块链技术引入其电子游戏平台。工作室旗下的一些游戏将支持与NEM区块链的代币XEM整合。通过这一平台，游戏开发者可以在游戏架构中直接调用支付功能，消除对第三方支付的依赖；玩家则可以自由地将XEM和游戏内货币、点数等进行双向兑换。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了大量基于区块链技术的应用案例和场景，展现了区块链以及基于区块链的分布式账本技术所具有的巨大市场潜力。</p>
<p>当然，任何事物的发展都不是一帆风顺的。目前来看，制约区块链技术进一步落地的因素有很多。比如如何来为区块链上的合同担保？特别在金融、法律等领域，实际执行的时候往往还需要线下机制来配合；另外就是基于区块链系统的价值交易，必须要实现物品价值的数字化，非数字化的物品很难直接放到数字世界中进行管理。</p>
<p>这些问题看起来都不容易很快得到解决。但笔者相信，一门新的技术能否站住脚，根本在于它能否最终提高生产力，而区块链技术已经证明了这一点。随着生态的进一步成熟，区块链技术必将在更多领域获得用武之地。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>秋·上海</title>
    <url>/articles/Essay-Autumn-in-Shanghai.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="怀念"><a href="#怀念" class="headerlink" title="怀念"></a>怀念</h3><p>上海的秋，</p>
<p>太过于委婉漫长，太过于伊人缠绵，</p>
<p>总不能触碰我的肌肤，</p>
<p>它若有若无又含糊其辞地说不清夏末秋初的界限。</p>
<span id="more"></span>

<p>想念北方的秋——</p>
<p>那种秋高气爽，那种秋的气息，</p>
<p>就算隔着窗户都能感受到侵入骨子的寒意和残酷，</p>
<p>会卷起满地落叶呼啸着让行人裹紧衣服。</p>
<p>这般肃杀无情的震慑力，促使我开始一年中最深沉的自我审视。</p>
<p>就像秋天雪藏一年的枯枝败叶一样，</p>
<p>将记忆力的五味杂陈，密封保存，加上酒曲，</p>
<p>等时光慢慢发酵香醇。</p>
<p>可是，上海的秋，</p>
<p>看不到四季转变的痕迹，</p>
<p>看不到长雁排空的旷大，</p>
<p>看不到无限延长的霞光，</p>
<p>更看不到万物凋零的衰败，</p>
<p>而我是通过这衰败和寂寥，才看得到明年的花开似锦。</p>
<p>我只是，</p>
<p>一个思秋的<del>少年</del>大叔。</p>
<h3 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h3><p>感觉过了很久，仿佛短短的三个月比过去的四年时间还要漫长。</p>
<p>仿佛一直生存在困惑中，看着眼前的光明，顾虑着身后的灯光。</p>
<p>怀着对光明的憧憬，又期待着灯光的熄灭。</p>
<p>似乎没有了太多的牵挂，永远将感情置于了第二位。</p>
<p>出奇地努力，有时要鏖战到凌晨。</p>
<p>想起从前大学的时光，有那么一阵子，沉迷游戏的阶段，</p>
<p>要学习时，出奇地困乏，</p>
<p>却清晰地知道，所有的努力，都是为了让自己过得无忧无虑。</p>
<p>只是缺了要刻苦的自制力。</p>
<p>独倚阑珊，或单车夜行。</p>
<p>每天过得像Espresso一样浓烈。</p>
<p>内心火一样的热望，却能轻易地隐藏。</p>
<p>只是心里总是泛起不甘的呐喊。</p>
<p>最好的防御就是进攻。</p>
<p>一直不顾一切地去进攻，奋不顾身地去战斗，</p>
<p>去沉思，去默想，</p>
<p>去奋进，去拼搏，</p>
<p>拿回自己本该拥有的一切。</p>
]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF 盘点系列——脑洞大开的编码和加密</title>
    <url>/articles/CTF-Coding-and-Encryption.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>玩过 CTF 的小伙伴会经常遇到类似这样的问题：dalao 这是啥编码方式啊？怎么解密啊？</p>
<p>其实 CTF 中的脑洞密码题，通常是费现代加密方式，一般都是各种古典密码的变形，一般出题者会对密文进行一些处理，但都会留下不少线索，当然也需要参赛者对于各种编码方式有所了解，这样更有利于快速入手解密，结合一定的脑洞，拿到 Flag 就 so easy 了~</p>
<span id="more"></span>

<h1 id="编码方式汇总"><a href="#编码方式汇总" class="headerlink" title="编码方式汇总"></a>编码方式汇总</h1><h2 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h2><p>ASCii 编码</p>
<p>Base64/32/16 编码</p>
<p>shellcode 编码</p>
<p>Quoted-printable 编码</p>
<p>XXencode 编码</p>
<p>UUencode 编码</p>
<p>URL 编码</p>
<p>Unicode 编码</p>
<p>Escape/Unescape 编码</p>
<p>HTML 实体编码</p>
<p>Tap Code 敲击码</p>
<p>Morse Code 摩尔斯电码</p>
<h2 id="各种文本加密"><a href="#各种文本加密" class="headerlink" title="各种文本加密"></a>各种文本加密</h2><h3 id="换位加密"><a href="#换位加密" class="headerlink" title="换位加密"></a>换位加密</h3><p>Rail-fence Cipher 栅栏密码</p>
<p>Curve Cipher 曲路密码</p>
<p>Columnar Transposition Cipher 列位移加密</p>
<h3 id="替换加密"><a href="#替换加密" class="headerlink" title="替换加密"></a>替换加密</h3><p>Atbash Cipher 埃特巴什码</p>
<p>Caesar Cipher 凯撒密码</p>
<p>ROT5/13/18/47</p>
<p>Simple Substitution Cipher 简单换位密码</p>
<p>Hill Cipher 希尔密码</p>
<p>Pigpen Cipher 猪圈密码</p>
<p>Polybius Square Cipher 波利比奥斯方阵密码</p>
<p>夏多密码（曲折加密）</p>
<p>Playfair Cipher 普莱费尔密码</p>
<p>Vigenere Cipher 维吉尼亚密码</p>
<p>Autokey Cipher 自动密钥密码</p>
<p>Beaufort Cipher 波弗特密码</p>
<p>Running Key Cipher 滚动密钥密码</p>
<p>Porta Cipher</p>
<p>Homophonic Substitution Cipher 同音替换密码</p>
<p>Affine Cipher 仿射密码</p>
<p>Baconian Cipher 培根密码</p>
<p>ADFG/VX Cipher ADFG 和 ADFGVX 密码</p>
<p>Bifid Cipher 双密码</p>
<p>Trifid Cipher 三分密码</p>
<p>Four-Square Cipher 四方密码</p>
<p>Checkerboard Cipher 棋盘密码</p>
<h3 id="其他有趣的机械密码"><a href="#其他有趣的机械密码" class="headerlink" title="其他有趣的机械密码"></a>其他有趣的机械密码</h3><p>恩尼格玛密码</p>
<p>代码混淆加密</p>
<p>asp 混淆加密</p>
<p>php 混淆加密</p>
<p>css/js 混淆加密</p>
<p>VBScript.Encode 混淆加密</p>
<p>ppencode</p>
<p>rrencode</p>
<p>jjencode/aaencode</p>
<p>JSfuck</p>
<p>jother</p>
<p>brainfuck</p>
<h2 id="常见编码-1"><a href="#常见编码-1" class="headerlink" title="常见编码"></a>常见编码</h2><h3 id="ASCII-编码"><a href="#ASCII-编码" class="headerlink" title="ASCII 编码"></a>ASCII 编码</h3><p>ASCII 编码大致可以分作三部分组成：</p>
<p>第一部分是：ASCII 非打印控制字符（参详 ASCII 码表中 0-31）；</p>
<p>第二部分是：ASCII 打印字符，也就是 CTF 中常用到的转换；</p>
<p>第三部分是：扩展 ASCII 打印字符(第一第三部分详见 <a href="http://www.asciima.com/" rel="nofollow,noindex" target="_blank">ASCII码表</a> 解释)。</p>
<p>编码转换示例</p>
<p>源文本：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">The quick <span class="keyword">brown </span>fox <span class="keyword">jumps </span>over the lazy dog</span><br></pre></td></tr></table></figure>

<p>ASCII编码对应十进制：</p>
<pre>#!shell
84 104 101 32 113 117 105 99 107 32 98 114 111 119 110 32 102 111 120 32 106 117 109 112 115 32 111 118 101 114 32 116 104 101 32 108 97 122 121 32 100 111 103</pre>

<p>对应可以转换成二进制，八进制，十六进制等。</p>
<h3 id="Base64-32-16-编码"><a href="#Base64-32-16-编码" class="headerlink" title="Base64/32/16 编码"></a>Base64/32/16 编码</h3><p>base64、base32、base16 可以分别编码转化 8 位字节为 6 位、5 位、4 位。16，32，64 分别表示用多少个字符来编码，这里我注重介绍 base64。</p>
<p>Base64 常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括 MIME 的 email，email via MIME，在 XML 中存储复杂数据。</p>
<p>编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表，如下：</p>
<p>举个例子(base64)：</p>
<p>源文本：T h e</p>
<p>对应ascii码:84 104 101</p>
<p>8位binary：01010100 01101000 01100101</p>
<p>6位binary：010101 000110 100001 100101</p>
<p>高位补0：000010101 00000110 00100001 00100101</p>
<p>对应ascii码：21 6 33 37</p></p>
<p>查表：V G h l</p>
</div>
<p>利用Python base64模块，我们分别可以这样加密解密base64 32 16：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_4"> </p>
<h3>3.shellcode编码</h3>
<p> 源文本： <code>The quick brown fox jumps over the lazy dog</code> </p>
<p>编码后：</p>
<pre>#!shell
\x54\x68\x65\x7f\x71\x75\x69\x63\x6b\x7f\x62\x72\x6f\x77\x6e\x7f\x66\x6f\x78\x7f\x6a\x75\x6d\x70\x73\x7f\x6f\x76\x65\x72\x7f\x74\x68\x65\x7f\x6c\x61\x7a\x79\x7f\x64\x6f\x67</pre>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_5"> </p>
<h3>4.Quoted-printable 编码</h3>
<p> 它是多用途互联网邮件扩展（MIME) 一种实现方式。有时候我们可以邮件头里面能够看到这样的编码，编码原理 <a href="http://blog.chacuo.net/494.html" rel="nofollow,noindex" target="_blank">参考</a> 。 </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_6"> </p>
<p> 源文本： <code>敏捷的棕色狐狸跳过了懒惰的狗</code> </p>
<p>编码后：</p>
<pre>#!shell
=E6=95=8F=E6=8D=B7=E7=9A=84=E6=A3=95=E8=89=B2=E7=8B=90=E7=8B=B8=E8=B7=B3=E8
=BF=87=E4=BA=86=E6=87=92=E6=83=B0=E7=9A=84=E7=8B=97</pre>
<p> 编码解码 <a href="http://www.mxcz.net/tools/QuotedPrintable.aspx" rel="nofollow,noindex" target="_blank">链接</a> </p>
<h3>5.XXencode编码</h3>
<p>XXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。它所选择的可打印字符是：+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz，一共64个字符。跟base64打印字符相比，就是UUencode多一个“-” 字符，少一个”/” 字符。</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_7"> </p>
<p> 源文本： <code>The quick brown fox jumps over the lazy dog</code> </p>
<p> 编码后： <code>hJ4VZ653pOKBf647mPrRi64NjS0-eRKpkQm-jRaJm65FcNG-gMLdt64FjNkc+</code> </p>
<p> 编码解码 <a href="http://web.chacuo.net/charsetxxencode" rel="nofollow,noindex" target="_blank">链接</a> </p>
<h3>6.UUencode编码</h3>
<p>UUencode是一种二进制到文字的编码，最早在unix 邮件系统中使用，全称：Unix-to-Unix encoding，UUencode将输入文本以每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。</p>
<p> 源文本： <code>The quick brown fox jumps over the lazy dog</code> </p>
<p> 编码后： <code>M5&amp;AE('%U:6-K(&amp;)R;W=N(&amp;9O&gt;"!J=6UP&lt;R!O=F5R('1H92!L87IY(&amp;1O9PH*</code> </p>
<p> 编码解码 <a href="http://web.chacuo.net/charsetuuencode" rel="nofollow,noindex" target="_blank">链接</a> </p>
<h3>7.URL编码</h3>
<p>url编码又叫百分号编码，是统一资源定位(URL)编码方式。URL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。 现在已经成为一种规范了，基本所有程序语言都有这种编码，如js：有encodeURI、encodeURIComponent，PHP有 urlencode、urldecode等。编码方法很简单，在该字节ascii码的的16进制字符前面加%. 如 空格字符，ascii码是32，对应16进制是'20'，那么urlencode编码结果是:%20。</p>
<p> 源文本： <code>The quick brown fox jumps over the lazy dog</code> </p>
<p>编码后：</p>
<pre>#!shell
%54%68%65%20%71%75%69%63%6b%20%62%72%6f%77%6e%20%66%6f%78%20%6a%75%6d%70%73%20%6f%76%65%72%20%74%68%65%20%6c%61%7a%79%20%64%6f%67</pre>
<p> 编码解码 <a href="http://web.chacuo.net/charseturlencode" rel="nofollow,noindex" target="_blank">链接</a> </p>
<h4>8.Unicode编码</h4>
<p>Unicode编码有以下四种编码方式：</p>
<p> 源文本： <code>The</code> </p>
<p> &amp;#x [Hex]： <code>&amp;#x0054;&amp;#x0068;&amp;#x0065;</code> </p>
<p> &amp;# [Decimal]： <code>&amp;#00084;&amp;#00104;&amp;#00101;</code> </p>
<p> \U [Hex]： <code>\U0054\U0068\U0065</code> </p>
<p> \U+ [Hex]： <code>\U+0054\U+0068\U+0065</code> </p>
<p> 编码解码 <a href="http://www.mxcz.net/tools/Unicode.aspx" rel="nofollow,noindex" target="_blank">链接</a> </p>
<h3>9.Escape/Unescape编码</h3>
<p>Escape/Unescape加密解码/编码解码,又叫%u编码，采用UTF-16BE模式， Escape编码/加密,就是字符对应UTF-16 16进制表示方式前面加%u。Unescape解码/解密，就是去掉"%u"后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”。</p>
<p> 源文本： <code>The</code> </p>
<p> 编码后： <code>%u0054%u0068%u0065</code> </p>
<h3>10.HTML实体编码</h3>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_8"> </p>
<p> 完整编码手册 <a href="http://www.w3school.com.cn/tags/html_ref_entities.html" rel="nofollow,noindex" target="_blank">参考</a> </p>
<h3>11.敲击码</h3>
<p>敲击码(Tap code)是一种以非常简单的方式对文本信息进行编码的方法。因该编码对信息通过使用一系列的点击声音来编码而命名，敲击码是基于5×5方格波利比奥斯方阵来实现的，不同点是是用K字母被整合到C中。</p>
<p>敲击码表:</p>
<pre>#!shell
  1  2  3  4  5
1 A  B C/K D  E
2 F  G  H  I  J 
3 L  M  N  O  P
4 Q  R  S  T  U
5 V  W  X  Y  Z</pre>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_9"> </p>
<h3>12.莫尔斯电码</h3>
<p>摩尔斯电码(Morse Code)是由美国人萨缪尔·摩尔斯在1836年发明的一种时通时断的且通过不同的排列顺序来表达不同英文字母、数字和标点符号的信号代码，摩尔斯电码主要由以下5种它的代码组成：</p>
<ol>
<li>点（.）</li>
<li>划（-）</li>
<li>每个字符间短的停顿（通常用空格表示停顿）</li>
<li> 每个词之间中等的停顿（通常用 <code>/</code> 划分） </li>
<li>以及句子之间长的停顿</li>
</ol>
<p>摩尔斯电码字母和数字对应表：</p>
<pre>#!shell
A  .-    N  -.    .  .-.-.-  +  .-.-.    1  .----
B  -...  O  ---   ,  --..--  _  ..--.-   2  ..---
C  -.-.  P  .--.  :  ---...  $  ...-..-  3  ...--
D  -..   Q  --.-  "  .-..-.  &amp;  .-...    4  ....-
E  .     R  .-.   '  .----.  /  -..-.    5  .....
F  ..-.  S  ...   !  -.-.--              6  -....
G  --.   T  -     ?  ..--..              7  --...
H  ....  U  ..-   @  .--.-.              8  ---..
I  ..    V  ...-  -  -....-              9  ----.
J  .---  W  .--   ;  -.-.-.              0  -----
K  -.-   X  -..-  (  -.--.           
L  .-..  Y  -.--  )  -.--.-          
M  --    Z  --..  =  -...-</pre>
<p> 源文本: <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p>编码后:</p>
<pre>#!shell
- .... . / --.- ..- .. -.-. -.- / -... .-. --- .-- -. / ..-. --- -..- / .--- ..- -- .--. ... / --- ...- . .-. / - .... . / .-.. .- --.. -.-- / -.. --- --.</pre>
<p> 在线编码解码 <a href="http://rumkin.com/tools/cipher/morse.php" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<p> 摩尔斯电码除了能对字母数字编码以外还对一些标点符号，非英语字符进行了编码，而且还有一些特定意义的组合称为特殊符号，比如 <code>·-·-·-·-·-</code> 表达的意思是调用信号，表示“我有消息发送”。如果你感兴趣可以参考 <a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81" rel="nofollow,noindex" target="_blank">WiKi</a> 。 </p>
<h3>13.编码的故事</h3>
<p> 推荐大家去看 <a href="http://wenku.baidu.com/link?url=kTrscV5j5AsZq5zvBpr2jdkEJW8LqgrkkKsddwWA3YlXmgeqh_be95nMxqbFPOYoVBVy3A6lutlcXVDYLdZ-3iRawJpc0VZ71as07FnxtGS" rel="nofollow,noindex" target="_blank">编码的故事</a> 一文。 </p>
<h2>各种文本加密</h2>
<p>文本加密可以将正常文本内容打乱为不可连读的文字或符号(汉字 数字 字母 音乐符号 国际音标 盲文 韩文 日文 傣文 彝文 箭头符号 花朵符号 俄文)，换行等格式信息也会被清除，达到加密的作用。在进行文本加密时可以设定一个密码，这样只有知道密码的人才能解密文本。密码可以是数字、字母和下划线，最多九位。</p>
<p>加密示例：</p>
<p> 源文本： <code>敏捷的棕色狐狸跳过了懒惰的狗</code> </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_10"> </p>
<p> 编码解码 <a href="http://www.qqxiuzi.cn/bianma/wenbenjiami.php" rel="nofollow,noindex" target="_blank">链接</a> </p>
<h2>换位加密</h2>
<h3>1.栅栏密码</h3>
<h4>（1）介绍</h4>
<p>栅栏密码(Rail-fence Cipher)就是把要加密的明文分成N个一组，然后把每组的第1个字符组合，每组第2个字符组合...每组的第N(最后一个分组可能不足N个)个字符组合，最后把他们全部连接起来就是密文，这里以2栏栅栏加密为例。</p>
<p> 明文： <code>The quick brown fox jumps over the lazy dog</code> </p>
<p> 去空格： <code>Thequickbrownfoxjumpsoverthelazydog</code> </p>
<p> 分组： <code>Th eq ui ck br ow nf ox ju mp so ve rt he la zy do g</code> </p>
<p> 第一组： <code>Teucbonojmsvrhlzdg</code> </p>
<p> 第二组： <code>hqikrwfxupoeteayo</code> </p>
<p> 密文： <code>Teucbonojmsvrhlzdghqikrwfxupoeteayo</code> </p>
<p> 加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/rail-fence/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>2.曲路密码</h3>
<p>曲路密码(Curve Cipher)是一种换位密码，需要事先双方约定密钥(也就是曲路路径)。</p>
<p> 明文： <code>The quick brown fox jumps over the lazy dog</code> </p>
<p>填入5行7列表(事先约定填充的行列数)</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_11"> </p>
<p>加密的回路线(事先约定填充的行列数)</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_12"> </p>
<p> 密文： <code>gesfc inpho dtmwu qoury zejre hbxva lookT</code> </p>
<h3>3.列移位密码</h3>
<h4>（1）介绍</h4>
<p>列移位密码(Columnar Transposition Cipher)是一种比较简单，易于实现的换位密码，通过一个简单的规则将明文打乱混合成密文。下面我们以明文 The quick brown fox jumps over the lazy dog，密钥 how are u为例：</p>
<p>填入5行7列表(事先约定填充的行列数，如果明文不能填充完表格可以约定使用某个字母进行填充)</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_11"> </p>
<p> 密钥： <code>how are u</code> </p>
<p>按how are u在字母表中的出现的先后顺序进行编号，我们就有a为1,e为2，h为3，o为4，r为5，u为6，w为7，所以先写出a列，其次e列，以此类推写出的结果便是密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_13"> </p>
<p> 密文： <code>qoury inpho Tkool hbxva uwmtd cfseg erjez</code> </p>
<p> 这里提供一个行列数相等的填充规则列移位密码加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/" rel="nofollow,noindex" target="_blank">链接</a> </p>
<p> 另外由列移位密码变化来的密码也有其他的，比如 <a href="http://www.thonky.com/kryptos/amsco-cipher" rel="nofollow,noindex" target="_blank">Amsco密码</a> (Amsco Cipher)和 <a href="http://www.thonky.com/kryptos/cadenus-cipher" rel="nofollow,noindex" target="_blank">Cadenus密码</a> (Cadenus Cipher)。 </p>
<h2>替换加密</h2>
<h3>1.埃特巴什码</h3>
<h4>（1）介绍</h4>
<p>埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密，也就是下面的对应关系：</p>
<pre>ABCDEFGHIJKLMNOPQRSTUVWXYZ
ZYXWVUTSRQPONMLKJIHGFEDCBA</pre>
<p> 明文： <code>the quick brown fox jumps over the lazy dog</code> </p>
<p> 密文： <code>gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt</code> </p>
<p> 加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>2.凯撒密码</h3>
<h4>（1）介绍</h4>
<p> 凯撒密码(Caesar Cipher或称恺撒加密、恺撒变换、变换加密、位移加密)是一种替换加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推，更多 <a href="https://en.wikipedia.org/wiki/Caesar_cipher" rel="nofollow,noindex" target="_blank">参考</a> 。 </p>
<p>加密实例：</p>
<p> 明文： <code>The quick brown fox jumps over the lazy dog</code> </p>
<p>偏移量：1</p>
<p> 密文： <code>Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph</code> </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_14"> </p>
<p> 你也可以使用Python的pycipher模块来加解密，如果提示没有这个模块可以通过 <code>pip install pycipher</code> 或者其他方式来安装pycipher模块。 </p>
<pre>#!python
&gt;&gt;&gt; from pycipher import Caesar
&gt;&gt;&gt; Caesar(key=1).encipher('The quick brown fox jumps over the lazy dog')
'UIFRVJDLCSPXOGPYKVNQTPWFSUIFMBAZEPH'
&gt;&gt;&gt; Caesar(key=1).decipher('UIFRVJDLCSPXOGPYKVNQTPWFSUIFMBAZEPH')
'THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG'</pre>
<p>参考表(这里是向后移位加密，向前移位解密)：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_15"> </p>
<p> 加密解密 <a href="http://planetcalc.com/1434/" rel="nofollow,noindex" target="_blank">链接</a> (这个网站可以将26种情况一次性列举出来，比较方便) </p>
<h3>3.ROT5/13/18/47</h3>
<h4>（1）介绍</h4>
<p>ROT5/13/18/47是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取。</p>
<div>
<p>ROT5 是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。下面分别说说它们的编码方式：</p>
<p>ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。</p>
<p>ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。</p>
<p>ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。</p>
<p>ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码，下面以rot13以例。</p>
</div>
<p> 明文： <code>the quick brown fox jumps over the lazy dog</code> </p>
<p> 密文： <code>gur dhvpx oebja sbk whzcf bire gur ynml qbt</code> </p>
<p> <a href="http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>4.简单替换密码</h3>
<h4>（1）介绍</h4>
<p>简单换位密码(Simple Substitution Cipher)加密方式是以每个明文字母被与之唯一对应且不同的字母替换的方式实现的，它不同于恺撒密码，因为密码字母表的字母不是简单的移位，而是完全是混乱的。 比如：</p>
<pre>#!shell
明文字母 : abcdefghijklmnopqrstuvwxyz
明文字母 : phqgiumeaylnofdxjkrcvstzwb</pre>
<p> 明文： <code>the quick brown fox jumps over the lazy dog</code> </p>
<p> 密文： <code>cei jvaql hkdtf udz yvoxr dsik cei npbw gdm</code> </p>
<h4>（2）破解</h4>
<p> 当密文数据足够多时这种密码我们可以通过字频分析方法破解或其他方法破解，比较好的在线词频分析网站 <a href="http://quipqiup.com/index.php" rel="nofollow,noindex" target="_blank">http://quipqiup.com/index.php</a> (翻= =墙)，这里推荐一篇通过"爬山算法"来破解简单替换密码 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-simple-substitution-cipher/" rel="nofollow,noindex" target="_blank">文章</a> ，基于文中的算法实现的工具来破解示例。 </p>
<p>密文：</p>
<pre>#!shell
pmpafxaikkitprdsikcplifhwceigixkirradfeirdgkipgigudkcekiigpwrpucikceiginasikwduearrxiiqepcceindgmieinpwdfprduppcedoikiqiasafmfddfipfgmdafmfdteiki</pre>
<p>解密：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_16"> </p>
<p>(ps:score值越小越准确)</p>
<p> 密钥： <code>PHQGIUMEAVLNOFDXBKRCZSTJWY</code> </p>
<p>明文：</p>
<pre>#!shell
AGAINPIERREWASOVERTAKENBYTHEDEPRESSIONHESODREADEDFORTHREEDAYSAFTERTHEDELIVERYOFHISSPEECHATTHELODGEHELAYONASOFAATHOMERECEIVINGNOONEANDGOINGNOWHERE</pre>
<p>将明文转换成可读句子：</p>
<p>again pierre was over taken by the depression he so dreaded for three day safter the delivery of his speech at the lodge he lay on a sofa at home receiving no one and going no where</p>
<h3>5.希尔密码</h3>
<h4>（1）介绍</h4>
<p> 希尔密码(Hill Cipher)是基于线性代数多重代换密码，由Lester S. Hill在1929年发明。每个字母转换成26进制数字：A=0, B=1, C=2...Z=25一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD26。更多 <a href="https://en.wikipedia.org/wiki/Hill_cipher" rel="nofollow,noindex" target="_blank">参考</a> </p>
<h4>（2）加密</h4>
<p> 明文： <code>ACT</code> </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_17"> </p>
<p>明文对应矩阵：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_18"> </p>
<p> 加密密钥： <code>GYBNQKURP</code> </p>
<p>加密矩阵：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_19"> </p>
<p>计算过程：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_20"> </p>
<p> 密文： <code>FIN</code> </p>
<h4>（3）解密</h4>
<p> 密文： <code>FIN</code> </p>
<p>计算加密矩阵的逆矩阵：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_21"> </p>
<p>解密计算：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_22"> </p>
<p> 明文： <code>ACT</code> </p>
<p>至于证明和求逆可以参考线性代数知识。</p>
<h4>（4）破解</h4>
<p>密码分析一门破解编码和密码的艺术。当我们尝试去攻破希尔密码你会发现频率分析实际上没有什么用处，特别在密钥长度增多的情况下。对于较长的二元矩阵（2×2的希尔密码）频率分析可能可能会有帮助，但是对于较短的密文分析是没有实际作用的。</p>
<p> 这里推荐一篇关于用 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-hill-cipher/" rel="nofollow,noindex" target="_blank">已知明文样本攻击的方式破解希尔密码</a> 的文章，基础的希尔密码用 <a href="https://en.wikipedia.org/wiki/Known-plaintext_attack" rel="nofollow,noindex" target="_blank">已知明文攻击</a> 的方式是可攻破的，由于加密完全是线性的，所以攻击者在截取到部分明文/密文字符对可以轻松建立一个线性系统，轻松搞定希尔密码，如果不能完全确定线性系统，那么只需要添加部分明文/密文对即可。已知明文攻击时最好的方式去破解写入密码，如果明文一无所知，那就进行推测猜出部分明文。基于已知明文样本攻击的方式破解希尔密码的算法的实现工具破解示例： </p>
<p>密文：</p>
<pre>#!shell
XUKEXWSLZJUAXUNKIGWFSOZRAWURORKXAOSLHROBXBTKCMUWDVPTFBLMKEFVWMUXTVTWUIDDJVZKBRMCWOIWYDXMLUFPVSHAGSVWUFWORCWUIDUJCNVTTBERTUNOJUZHVTWKORSVRZSVVFSQXOCMUWPYTRLGBMCYPOJCLRIYTVFCCMUWUFPOXCNMCIWMSKPXEDLYIQKDJWIWCJUMVRCJUMVRKXWURKPSEEIWZVXULEIOETOOFWKBIUXPXUGOWLFPWUSCH</pre>
<p>解密：</p>
<p> 解密 <a href="http://bobao.360.cn/ctf/learning/136.html" rel="nofollow,noindex" target="_blank">脚本实例</a> </p>
<p> 在线加解密 <a href="http://www.practicalcryptography.com/ciphers/hill-cipher/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>6.猪圈密码</h4>
<h4>（1）介绍</h4>
<p> 猪圈密码(Pigpen Cipher或称九宫格密码、朱高密码、共济会密码或共济会员密码)，是一种以格子为基础的简单替代式密码。更多 <a href="https://en.wikipedia.org/wiki/Pigpen_cipher" rel="nofollow,noindex" target="_blank">参考</a> </p>
<p>明文字母和对应密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_23"> </p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p>密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_24"> </p>
<p> 在线加密 <a href="http://www.simonsingh.net/The_Black_Chamber/pigpen.html" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>（2）变种</h4>
<p>圣堂武士密码(Templar Cipher)是共济会的“猪圈密码”的一个变种，一直被共济会圣殿骑士用。</p>
<p>明文字母和对应密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_25"> </p>
<h4>（3）其他变种</h4>
<p>明文字母和对应密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_26"> </p>
<p>明文字母和对应密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_27"> </p>
<p>明文字母和对应密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_28"> </p>
<h3>7.波利比奥斯方阵密码</h3>
<h4>（1）介绍</h4>
<p> 波利比奥斯方阵密码（Polybius Square Cipher或称波利比奥斯棋盘）是棋盘密码的一种，是利用波利比奥斯方阵进行加密的密码方式，简单的来说就是把字母排列好，用坐标(行列)的形式表现出来。字母是密文，明文便是字母的坐标。更多 <a href="https://en.wikipedia.org/wiki/Polybius_square" rel="nofollow,noindex" target="_blank">参考</a> </p>
<p>常见的排布方式：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_29"> </p>
<p>加密实例：</p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 密文： <code>442315 4145241325 1242345233 213453 2445323543 442315 31115554 143422</code> </p>
<h3>8.夏多密码(曲折加密)</h3>
<h4>（1）介绍</h4>
<p>夏多密码是作者麦克斯韦·格兰特在中篇小说《死亡之链》塑造夏多这一英雄人物中所自创的密码，如下图所示：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_30"> </p>
<div>
<p>注意，在以上所示的字母表密钥的底部，列有四个附加符号1，2，3，4.他们可以放在密文中的任何地方。每个附加符号指示，如何转动写有密文的纸张，再进行后续的加密或解密操作，直到出现另一个附加符号。可以把每个附加符号中的那根线看作是指示针，它指示了纸张的上端朝上，朝右，朝下，朝左。比如说：如果出现符号3，那么纸张就应该转动180度，使其上端朝下； 符号2表示纸张上端朝右，依次类推。</p>
</div>
<p> 源文本： <code>I AM IN DANGER SEND HELP(我有危险，速来增援)</code> </p>
<p>密文：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_31"> </p>
<h3>9.普莱菲尔密码</h3>
<div>
<p>普莱菲尔密码(Playfair Cipher)是第一种用于实际的双字替换密码，用双字加密取代了简单代换密码的单字加密，很明显这样使得密文更难破译，因为使用简单替换密码的频率分析基本没有什么作用，虽然频率分析，通常仍然可以进行，但是有25×25=625种可能而不是25种可能，可以分为三个步骤，即编制密码表、整理明文、编写译文，下面我们以明文：</p>
<p> <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> 和密钥 <code>CULTURE</code> 为例来讲解。普莱菲尔密码又称为单方密码(Single Cipher)之后又出现它的升级版Double Playfair，也就是 <a href="https://en.wikipedia.org/wiki/Two-square_cipher" rel="nofollow,noindex" target="_blank">二方密码</a> (Two-square Cipher),在之后又有四方密码(Four-square Cipher) </p>
</div>
<h4>(1)编制密码表</h4>
<p> 1.整理密钥字母 <code>C U L T U R E</code> ，去掉后面重复的字母得到： <code>C U L T R E</code> </p>
<p>2.用上一步得到的字母自上而下来填补5乘5方表的纵列（也可横排），之后的空白按照相同的顺序用字母表中剩余的字母依次填补完整，得到如下的方格:</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_32"> </p>
<div>
<p>这一步需要注意的要点：整理密钥字母时，如果出现"Z"，则需要去除，因为在英文里"Z"的使用频率最低，相应的如果是德文，则需将"I"与"J"当作一个字母来看待，而法语则去掉"W"或"K"。</p>
</div>
<h4>(2)整理明文</h4>
<p> 我们要遵循的原则是“两个一组”，得到是若干个两两成对的字母段，用到的是明文 <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> 与字母" <code>X</code> "： </p>
<p> 1.将明文两两一组按顺序排开，得到： <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO G</code> </p>
<p> 2.对于末尾的单个字母要加上一个" <code>X</code> "使之成对： <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX</code> </p>
<div>
<p> 这一步需要注意的要点：对于相连字母相同者，每个后面都需要加" <code>X</code> "，例如 <code>TOMORROW</code> ，需要写成： <code>TO MO RX RX OW</code> 。 </p>
</div>
<h4>(3)编写密文</h4>
<p>我们要得到的密文，当然，对于每个字母对，要严格遵循如下的原则：</p>
<div>
<p> 1.如果两个字母在同一行则要用它右邻的字母替换，如果已在最右边，则用该行最左边的替换，如明文为" <code>CE</code> "，依据上表，应替换为" <code>EG</code> "； </p>
<p> 2.如果两个字母在同一列则要用它下边的字母替换，如果已在最下边，则用该行最上边的替换，如明文为" <code>OQ</code> "，依据上表，应替换为" <code>PS</code> "； </p>
<p> 3.如果两个字母在不同的行或列，则应在密码表中找两个字母使四个字母组成一个矩形，明文占据两个顶点，需用另外两个顶点的字母替换，如明文为" <code>HX</code> "，可以替换为" <code>WI/J</code> "或" <code>I/JW</code> "（下面的例子将按照横向替换原则即同行优先）。 </p>
</div>
<p> 按照上述原则，将明文 <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX</code> 加以转换得到 <code>KU ND LH GT LF WU ES PW LH SI/J NP CG CR AG BU VZ QA I/JV</code> （/表示或者，不过一般用I不用J，所以分析密文时你看25个字母都有而只差一个字母没有用到可以考虑一下这种加密方式）将得到的字母改为大写并五个一组列好，得到密文 <code>KUNDL HGTLF WUESP WLHSI NPCGC RAGBU VZQAI V</code> 。 </p>
<p> 加密解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/playfair/" rel="nofollow,noindex" target="_blank">传送门</a> (ps：这里加解密是横向编制密码表) </p>
<p>加密解密实例(ps：这里加解密也是横向编制密码表)：</p>
<pre>#!python
&gt;&gt;&gt;from pycipher import Playfair
&gt;&gt;&gt;Playfair('CULTREABDFGHIKMNOPQSVWXYZ').encipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG')
'UKDNLHTGFLWUSEPWHLISNPCGCRGAUBVZAQIV'
&gt;&gt;&gt;Playfair('CULTREABDFGHIKMNOPQSVWXYZ').decipher('UKDNLHTGFLWUSEPWHLISNPCGCRGAUBVZAQIV')
'THEQUICKBROWNFOXIUMPSOVERTHELAZYDOGX'</pre>
<h3>10.维吉尼亚密码</h3>
<h4>（1）介绍</h4>
<p> 维吉尼亚密码(Vigenère Cipher)是在单一恺撒密码的基础上扩展出多表代换密码，根据密钥(当密钥长度小于明文长度时可以循环使用)来决定用哪一行的密表来进行替换，以此来对抗字频统计，更多 <a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher" rel="nofollow,noindex" target="_blank">参考</a> 。 </p>
<p>密表：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_33"> </p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 密钥(循环使用，密钥越长相对破解难度越大)： <code>CULTURE</code> </p>
<p>加密过程：如果第一行为明文字母，第一列为密钥字母，那么明文字母'T'列和密钥字母'C'行的交点就是密文字母'V'，以此类推。</p>
<p> 密文： <code>VBP JOZGM VCHQE JQR UNGGW QPPK NYI NUKR XFK</code> </p>
<h4>（2）已知密钥加解密</h4>
<pre>#!python
&gt;&gt;&gt;from pycipher import Vigenere
&gt;&gt;&gt;Vigenere('CULTURE').encipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG')
'VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK'
&gt;&gt;&gt;Vigenere('CULTURE').decipher('VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK')
'THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG'</pre>
<p> 在线加密解密 <a href="http://planetcalc.com/2468/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>（3）未知密钥破解</h4>
<p> 可以参考 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/" rel="nofollow,noindex" target="_blank">维吉尼亚密码分析</a> 这篇文章，破解维吉尼亚密码第一步是确定密钥长度，维吉尼亚密码分析这篇文章里介绍了使用 <a href="https://en.wikipedia.org/wiki/Index_of_coincidence" rel="nofollow,noindex" target="_blank">重合指数</a> 算法来确定密钥长度，在确定密钥长度后就可以尝试确定密钥，通常我们可以使用 <a href="https://en.wikipedia.org/wiki/Chi-squared_test" rel="nofollow,noindex" target="_blank">卡方检验</a> 来找到每个字母的偏移量，基于维吉尼亚密码分析一文中的算法实现的工具破解示例。 </p>
<p> 密文： <code>kiqpbkxspshwehospzqhoinlgapp</code> </p>
<p>解密：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_34"> </p>
<p>(ps:结合左边的值，密钥以及解出明文可以确定kien 5或者klen 10为准确的结果)</p>
<p> 明文： <code>DEFEND THE EAST WALL OF THE CASTLE</code> </p>
<h4>（4）变种</h4>
<p> 有几种密码和维吉尼亚密码相似，格罗斯费尔德密码(Gronsfeld cipher)实际上和维吉尼亚密码相同，除了使用了数字来代替字母以外没有什么区别。数字可以选择一种数列，如斐波那契数列，或者一些其他的伪随机序列。格罗斯费尔德密码密码分析过程和维吉尼亚密码大同小异，不过，自动密钥密码不能使用 <a href="http://www.zybang.com/question/a0a1108423f63d10dbbf0c3e1bfdf3b3.html" rel="nofollow,noindex" target="_blank">卡西斯基算法</a> (kasiski)来破译，因为自动密钥密码的密钥不重复循环使用，破译自动密钥密码最好的方法的就是从密文不断尝试和猜测其中明文或密钥的一部分。 </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_35"> </p>
<pre>#!python
&gt;&gt;&gt;from pycipher import Gronsfeld
&gt;&gt;&gt;Gronsfeld([2,20,11,45,20,43,4]).encipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG')
'VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK'
&gt;&gt;&gt;Gronsfeld([2,20,11,45,20,43,4]).decipher('VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK')
'THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG'</pre>
<p> 在线加解密 <a href="http://rumkin.com/tools/cipher/gronsfeld.php" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>11.自动密钥密码</h3>
<h4>（1）介绍</h4>
<p>自动密钥密码(Autokey Cipher)是多表替换密码，与维吉尼亚密码密切相关，但使用不同的方法生成密钥，通常来说要比维吉尼亚密码更安全。自动密钥密码主要有两种，关键词自动密钥密码和原文自动密钥密码.下面我们以关键词自动密钥为例：</p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 关键词： <code>CULTURE</code> </p>
<p> 自动生成密钥： <code>CULTURE THE QUICK BROWN FOX JUMPS OVER THE</code> </p>
<p>接下来的加密过程和维吉尼亚密码类似，从密表可得：</p>
<p> 密文： <code>VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK</code> </p>
<h4>（2）已知关键词加解密</h4>
<pre>#!python
&gt;&gt;&gt;from pycipher import Autokey
&gt;&gt;&gt;Autokey('CULTURE').encipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG')
'VBPJOZGDIVEQVHYYAIICXCSNLFWWZVDPWVK'
&gt;&gt;&gt;Autokey('CULTURE').decipher('VBPJOZGDIVEQVHYYAIICXCSNLFWWZVDPWVK')
'THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG'</pre>
<p> 在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/autokey/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>（3）未知关键词破解</h4>
<p> 推荐去看这篇 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/" rel="nofollow,noindex" target="_blank">自动密钥密码分析文章</a> ，基于文中的算法实现的工具来破解示例。 </p>
<p>密文:</p>
<pre>#!shell
isjiqymdebvuzrvwhmvysibugzhyinmiyeiklcvioimbninyksmmnjmgalvimlhspjxmgfiraqlhjcpvolqmnyynhpdetoxemgnoxl</pre>
<p>解密</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_36"> </p>
<p>(ps:从klen 13可以看出使用的关键词为'FORTIFICATION')</p>
<p>明文：</p>
<pre>#!shell
DESPITEBEINGMORESECURETHANTHEVIGENERECIPHERTHEAUTOKEYCIPHERISSTILLVERYEASYTOBREAKUSINGAUTOMATEDMETHODS</pre>
<p>将明文转换成可读句子：</p>
<p>despite being more secure than the vigenere cipher the autokey cipher is still very easy to break using automated methods</p>
<h3>12.博福特密码</h3>
<h4>（1）介绍</h4>
<p>博福特密码(Beaufort Cipher)，是一种类似于维吉尼亚密码的代换密码，由弗朗西斯·蒲福(Francis Beaufort)发明。它最知名的应用是Hagelin M-209密码机。博福特密码属于对等加密，即加密演算法与解密演算法相同。</p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 密钥(循环使用，密钥越长相对破解难度越大)： <code>CULTURE</code> </p>
<p>加密过程：如果第一行为明文字母，第一列为密文字母，那么沿明文字母'T'列出现密钥字母'C'的行号就是密文字母'J'，以此类推。</p>
<p> 密文： <code>JNH DAJCS TUFYE ZOX CZICM OZHC BKA RUMV RDY</code> </p>
<h4>（2）已知密钥加解密</h4>
<pre>#!python
&gt;&gt;&gt;from pycipher import Beaufort
&gt;&gt;&gt;Beaufort('CULTURE').encipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG')
'JNHDAJCSTUFYEZOXCZICMOZHCBKARUMVRDY'
&gt;&gt;&gt;Beaufort('CULTURE').decipher('JNHDAJCSTUFYEZOXCZICMOZHCBKARUMVRDY')
'THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG'</pre>
<p> 在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/beaufort/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>13.滚动密钥密码</h3>
<h4>（1）介绍</h4>
<p>滚动密钥密码(Running Key Cipher)和维吉尼亚密码有着相同的加密机制，区别是密钥的选取，维吉尼亚使用的密钥简短，而且重复循环使用，与之相反，滚动密钥密码使用很长的密钥，比如引用一本书作为密钥。这样做的目的是不重复循环使用密钥，使密文更难破译，尽管如此，滚动密钥密码还是可以被攻破，因为有关于密钥和明文的统计分析模式可供利用，如果滚动密钥密码使用统计上的随机密钥来源，那么理论上是不可破译的，因为任何可能都可以成为密钥，并且所有的可能性都是相等的。</p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p>密钥：选取C语言编程(1978版)第63页第1行"errors can occur in several places. A label has..."，去掉非字母部分作为密钥(实际选取的密钥很长，长度至少不小于明文长度)。</p>
<p>加密过程：加密过程和维吉尼亚密码加密过程相同</p>
<p> 密文: <code>XYV ELAEK OFQYH WWK BYHTJ OGTC TJI DAK YESR</code> </p>
<p> 已知密钥在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/running-key/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>14.Porta密码</h3>
<h4>（1）介绍</h4>
<p>Porta密码(Porta Cipher)是一个由意大利那不勒斯的医生Giovanni Battista della Porta发明的多表代换密码，Porta密码具有加密解密过程的是相同的特点。</p>
<p>密表：</p>
<pre>#!shell
KEYS| A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
----|----------------------------------------------------
A,B | N O P Q R S T U V W X Y Z A B C D E F G H I J K L M
C,D | O P Q R S T U V W X Y Z N M A B C D E F G H I J K L
E,F | P Q R S T U V W X Y Z N O L M A B C D E F G H I J K
G,H | Q R S T U V W X Y Z N O P K L M A B C D E F G H I J
I,J | R S T U V W X Y Z N O P Q J K L M A B C D E F G H I
K,L | S T U V W X Y Z N O P Q R I J K L M A B C D E F G H
M,N | T U V W X Y Z N O P Q R S H I J K L M A B C D E F G
O,P | U V W X Y Z N O P Q R S T G H I J K L M A B C D E F
Q,R | V W X Y Z N O P Q R S T U F G H I J K L M A B C D E
S,T | W X Y Z N O P Q R S T U V E F G H I J K L M A B C D
U,V | X Y Z N O P Q R S T U V W D E F G H I J K L M A B C
W,X | Y Z N O P Q R S T U V W X C D E F G H I J K L M A B
Y,Z | Z N O P Q R S T U V W X Y B C D E F G H I J K L M A</pre>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 密钥(循环使用，密钥越长相对破解难度越大)： <code>CULTURE</code> </p>
<p>加密过程：明文字母'T'列与密钥字母'C'行交点就是密文字母'F',以此类推。</p>
<p> 密文： <code>FRW HKQRY YMFMF UAA OLWHD ALWI JPT ZXHC NGV</code> </p>
<p> 已知密钥在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/porta/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>（2）破解</h4>
<p> Porta密码可以被以 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher-part-2/" rel="nofollow,noindex" target="_blank">维吉尼亚密码</a> 破解相类似方式进行自动攻破，破解Porta密码第一步是先确定密钥长度，这里推荐一篇关于使用 <a href="https://en.wikipedia.org/wiki/Index_of_coincidence" rel="nofollow,noindex" target="_blank">重合指数算法</a> 确定为维吉尼亚密钥长度 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/" rel="nofollow,noindex" target="_blank">文章</a> 。 </p>
<h3>15.同音替换密码</h3>
<h4>（1）介绍</h4>
<p>同音替换密码(Homophonic Substitution Cipher)是单字母可以被其他几种密文字母同时替换的密码，通常要比标准替换密码破解更加困难，破解标准替换密码最简单的方法就是分析字母出现频率，通常在英语中字母'E'(或'T')出现的频率是最高的，如果我们允许字母'E'可以同时被3种不同字符代替，那么就不能还是以普通字母的频率来分析破解，如果允许可代替字符越多，那么密文就会更难破译。</p>
<p>常见代换规则表：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_37"> </p>
<p> 明文: <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 密文(其中一种)： <code>6CZ KOVST XJ0MA EQY IOGL4 0W1J UC7 P9NB F0H</code> </p>
<h4>（2）破解</h4>
<p> 如果同音替换密码的同音词个数很多，那么破解它难度很大，通常的方法采取类似破解替换密码的"爬山算法"，除了找到一个明文字母映射几个字符之外，我们还需要确定映射了那些字符，可以尝试 <a href="http://www.cs.sjsu.edu/faculty/stamp/RUA/homophonic.pdf" rel="nofollow,noindex" target="_blank">2层嵌套"爬山算法"</a> 来破解，外层确定映射的数量，内层确定映射字符。 </p>
<h3>16.仿射密码</h3>
<h4>（1）介绍</h4>
<p> 仿射密码(Affine Cipher)是一种单表代换密码，字母表中的每个字母相应的值使用一个简单的数学函数映射到对应的数值，再把对应数值转换成字母。这个公式意味着每个字母加密都会返回一个相同的字母，意义着这种加密方式本质上是一种标准替代密码。因此，它具有所有替代密码的弱点。每一个字母都是通过函数（ax + b）mod m加密，其中B是位移量，为了保证仿射密码的可逆性，a和m需要满足gcd(a , m)=1，一般m为设置为26。更多 <a href="https://en.wikipedia.org/wiki/Affine_cipher" rel="nofollow,noindex" target="_blank">参考</a> </p>
<p>常见的字母对应关系：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_38"> </p>
<p>下面我们以E(x) = (5x + 8) mod 26函数为例子</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_39"> </p>
<p>至于解密我们知道</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_40"> </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_41"> </p>
<p>即可得出解密结果</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_42"> </p>
<p>以E(x) = (5x + 8) mod 26加密，通过计算可得D(x)=21(x - 8) mod 26，这样便可以得到明文。</p>
<p>可参考的Python脚本</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_43"> </p>
<p> 加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/affine/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>17.培根密码</h3>
<h4>（1）介绍</h4>
<p>培根密码(Baconian Cipher)是一种替换密码，每个明文字母被一个由5字符组成的序列替换，最初的加密方式就是由'A'和'B'组成序列替换明文(所以你当然也可以用别的字母)，比如字母'D'替换成"aaabb"，以下是全部的对应关系(另一种对于关系是每个字母都有唯一对应序列，I和J与U/V各自都有不同对应序列)：</p>
<pre>#!shell
A = aaaaa  I/J = abaaa  R = baaaa

<p>B = aaaab  K = abaab    S = baaab</p>
<p>C = aaaba  L = ababa    T = baaba</p>
<p>D = aaabb  M = ababb    U/V = baabb</p>
<p>E = aabaa  N = abbaa    W = babaa</p>
<p>F = aabab  O = abbab    X = babab</p>
<p>G = aabba  P = abbba    Y = babba</p>
<p>H = aabbb  Q = abbbb    Z = babbb</pre></p>
<p> 明文： <code>T H E F O X</code> </p>
<p> 密文： <code>baaba aabbb aabaa aabab abbab babab</code> </p>
<p> 加解密 <a href="http://rumkin.com/tools/cipher/baconian.php" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>18.ADFGX和ADFGVX密码</h3>
<h4>（1）ADFGX密码</h4>
<p>ADFGX密码(ADFGX Cipher)是结合了改良过的Polybius方格替代密码与单行换位密码的矩阵加密密码，使用了5个合理的密文字母：A，D，F，G，X，这些字母之所以这样选择是因为当转译成摩尔斯电码(ADFGX密码是德国军队在一战发明使用的密码)不易混淆，目的是尽可能减少转译过程的操作错误。</p>
<p>加密矩阵示例：</p>
<pre>#!shell
    A  D  F  G   X
  ----------------
A | p  h  q  g   m 
D | e  a  y  n   o 
F | f  d  x  k   r
G | c  v  s  z   w 
X | b  u  t  i/j l</pre>
<p> 明文： <code>THE QUICK BROWN FOX</code> </p>
<p>结果矩阵加密：</p>
<pre>#!shell
XF AD DA   AF XD XG GA FG   XA FX DX GX DG   FA DX FF</pre>
<p> 列移位密钥： <code>how are u</code> </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_44"> </p>
<p> 密文： <code>DXADF AGXF XFFXD FXGGX DGFG AADA ADXXF</code> </p>
<p>已知密钥加解密：</p>
<pre>#!python
&gt;&gt;&gt;from pycipher import ADFGX
&gt;&gt;&gt;a = ADFGX('phqgmeaynofdxkrcvszwbutil','HOWAREU')
&gt;&gt;&gt;a.encipher('THE QUICK BROWN FOX')
'DXADFAGXFXFFXDFXGGXDGFGAADAADXXF'
&gt;&gt;&gt;a.decipher('DXADFAGXFXFFXDFXGGXDGFGAADAADXXF')
'THEQUICKBROWNFOX'</pre>
<p> 在线加解密 <a href="http://www.practicalcryptography.com/ciphers/adfgx-cipher/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>（2）ADFGVX密码</h4>
<p>ADFGVX密码实际上就是ADFGX密码的扩充升级版，一样具有ADFGX密码相同的特点，加密过程也类似，不同的是密文字母增加了V，使得可以再使用10数字来替换明文。</p>
<pre>#!shell
    A D F G V X
  -------------
A | p h 0 q g 6
D | 4 m e a 1 y
F | l 2 n o f d
G | x k r 3 c v
V | s 5 z w 7 b
X | j 9 u t i 8</pre>
<p>由于两种加密过程完全类似这里就不再重复给出加密过程。</p>
<pre>#!python
&gt;&gt;&gt;from pycipher import ADFGVX
&gt;&gt;&gt;a = ADFGVX('ph0qg64mea1yl2nofdxkr3cvs5zw7bj9uti8','HOWAREU')
&gt;&gt;&gt;a.encipher('THE QUICK BROWN FOX')
'DXXFAFGFFXGGGFGXDVGDVGFAVFVAFVGG'
&gt;&gt;&gt;a.decipher('DXXFAFGFFXGGGFGXDVGDVGFAVFVAFVGG')
'THEQUICKBROWNFOX'</pre>
<h3>19.双密码</h3>
<h4>（1）双密码</h4>
<p> 双密码(Bifid Cipher)结合了波利比奥斯方阵换位密码，并采用分级实现扩散，这里的“双”是指用2个密钥进行加密。双密码是由法国Felix Delastelle发明，除此之外Felix Delastelle还发明了三分密码(Trifid Cipher)，四方密码(Four-Square Cipher)。还有一个 <a href="https://en.wikipedia.org/wiki/Two-square_cipher" rel="nofollow,noindex" target="_blank">两方密码</a> (Two-Square)与四方密码类似， <a href="http://www.thonky.com/kryptos/cm-bifid-cipher" rel="nofollow,noindex" target="_blank">共轭矩阵双密码</a> (Conjugated Matrix Bifid Cipher)也是双密码的变种。 </p>
<p>示例密阵:</p>
<pre>#!shell
   1 2 3 4 5
1| p h q g m
2| e a y l n
3| o f d x k
4| r c v s z
5| w b u t i/j</pre>
<p> 明文: <code>THE QUICK BROWN FOX</code> </p>
<p>经过密阵转换：</p>
<p> 行: <code>512 15543 54352 333</code> </p>
<p> 列: <code>421 33525 21115 214</code> </p>
<p>分组:</p>
<p>51215 54354 35233 3</p>
<p>42133 52521 11521 4</p>
<p>合并：</p>
<pre>#!shell
5121542133 5435452521 3523311521 34</pre>
<p> 在经过密阵转换后密文: <code>WETED TKZNE KYOME X</code> </p>
<h4>（2）已知密阵加解密</h4>
<pre>#!python
&gt;&gt;&gt;from pycipher import
&gt;&gt;&gt;Bifid('phqgmeaylnofdxkrcvszwbuti',5).encipher('THE QUICK BROWN FOX')
'WETEDTKZNEKYOMEX'
&gt;&gt;&gt;Bifid('phqgmeaylnofdxkrcvszwbuti',5).decipher('WETEDTKZNEKYOMEX')
'THEQUICKBROWNFOX'</pre>
<p> 在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/bifid/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>（3）未知密阵破解</h4>
<p> 手工分析破解双密码是有一定难度的，每个字母都是同过3个数字进行非线性代替转换，而且之后还会对字母顺序进行打乱，这样使双密码比一些替换密码和换位密码更难破解。然而，现在是计算机时代，这张加密方式没有安全性可言，通过 <a href="http://baike.baidu.com/link?url=mkceUr0W4L7B7UVQxc-dUkXKPJbj9v4YyBh_hrskt5iXk99UdnjW6mZ_YxoJO1PkT1zdjEZD2hd7TCMiSxpOma" rel="nofollow,noindex" target="_blank">模拟退火</a> 算法就能快速找到双密码的密阵。 这里推荐一篇详细的 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-bifid-cipher/" rel="nofollow,noindex" target="_blank">双密码破解分析</a> 的文章，基于模拟退火算法实现的工具破解示例： </p>
<p>密文:</p>
<pre>#!shell
KWTAZQLAWWZCPONIVBTTBVQUZUGRNHAYIYGIAAYURCUQLDFTYVHTNQEENUPAIFCUNQTNGITEFUSHFDWHRIFSVTBISYDHHASQSROMUEVPQHHCCRBYTQBHWYRRHTEPEKHOBFSZUQBTSYRSQUDCSAOVUUGXOAUYWHPGAYHDNKEZPFKKWRIEHDWPEIOTBKESYETPBPOGTHQSPUMDOVUEQAUPCPFCQHRPHSOPQRSSLPEVWNIQDIOTSQESDHURIEREN</pre>
<p>解密：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_45"> </p>
<p>得到加密矩阵:</p>
<pre>#!shell
G B C M K
D H U E T
L V Y W I
X O Z S P
N F A R Q</pre>
<p>明文:</p>
<pre>#!shell
CRYPTANALYS IS OF BIFID BY HAND IS ACTUALLY FAIRLY DIFFICULT THE FRACTIONATING NATURE OF THE CIPHER IE EACH LETTER IS SUBSTITUTED BY CHARACTERS THEN THESE CHARACTERS ARE IUM BLED WHICH WILL PULL THEM APART MAKES THE CIPHER MUCH STRONGER THAN SUBSTITUTION CIPHERS OR TRANSPOSITION CIPHER SON THEIR OWN</pre>
<h3>20.三分密码</h3>
<p>三分密码(Trifid Cipher)结合换位和替换，三分密码与双密码非常相似，差别之处就是用除了3×3×3的密阵代替5×5密阵。</p>
<p>示例密阵:</p>
<pre>#!shell
密阵顺序 = EPSDUCVWYM.ZLKXNBTFGORIJHAQ      

<p>方阵 1      方阵 2      方阵 3<br>  1 2 3      1 2 3      1 2 3<br>1 E P S    1 M . Z    1 F G O<br>2 D U C    2 L K X    2 R I J<br>3 V W Y    3 N B T    3 H A Q</pre></p>
<p> 明文: <code>THE QUICK BROWN FOX.</code> </p>
<p>经过密阵转换：</p>
<pre>#!shell
T H E Q U I C K B R O W N F O X .
2 3 1 3 1 3 1 2 2 3 3 1 2 3 3 2 2
3 3 1 3 2 2 2 2 3 2 1 3 3 1 1 2 1
3 1 1 3 2 2 3 2 2 1 3 2 1 1 3 3 2</pre>
<p>T(233)表示T在第一个方阵第三行第三列的位置</p>
<p>分组(分组密钥以5为例):</p>
<pre>#!shell
THEQU ICKBR OWNFO X.
23131 31223 31233 22
33132 22232 13311 21
31132 23221 32113 32</pre>
<p>合并：</p>
<pre>#!shell
23131 33132 31132 31223 22232 23221 31233 13311 32113 22 21 32</pre>
<p>在经过密阵转换后密文:</p>
<pre>#!shell
231313313231132312232223223221312331331132113222132
N  O  O  N  W  G  B  X  X  L  G  H  H  W  S  K  W</pre>
<p> 想要深入了解三分密码并破解三分密码的小伙伴推荐去看LANIKI教授的一篇密码课程章节的 <a href="http://www.und.nodak.edu/org/crypto/crypto/lanaki.crypt.class/lessons/lesson17.zip" rel="nofollow,noindex" target="_blank">讲义</a> 。 </p>
<h3>21.四方密码</h3>
<h4>（1）介绍</h4>
<p>四方密码(Four-Square Cipher)是类似普莱菲尔密码双字母加密密码，这样使加密效果强于其他替换密码，因为频率分析变得更加困难了。</p>
<p>四方密码使用4个预先设置的5×5字母矩阵，每个矩阵包括25个字母，通常字母'j'被融入到'i'中(维基百科上说'q'被忽略，不过这不重要，因为'q'和'j'都是很少出现的字母)，通常左上和右下矩阵式是标准字母排序明文矩阵，右上和左下矩阵是打乱顺序的密钥矩阵。</p>
<p>示例矩阵：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_46"> </p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 整理明文(分组不够时用'X'填充)： <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX</code> </p>
<p>加密过程：分别在明文矩阵中找到'TH'，分别找到他们在右上矩阵有左下矩阵的交点字母'ES'就是密文，以此类推。</p>
<p> 密文： <code>ESZWQAFHGTDKWHRKUENYQOLMQTUNWMBPTGHQ</code> </p>
<h4>（2）已知密钥矩阵加解密</h4>
<pre>#!python
&gt;&gt;&gt;from pycipher import Foursquare
&gt;&gt;&gt;fs = Foursquare('zgptfoihmuwdrcnykeqaxvsbl','mfnbdcrhsaxyogvituewlqzkp')
&gt;&gt;&gt;fs.encipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG')
'ESZWQAFHGTDKWHRKUENYQOLMQTUNWMBPTGHQ'
&gt;&gt;&gt;fs.decipher('ESZWQAFHGTDKWHRKUENYQOLMQTUNWMBPTGHQ')
'THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG'</pre>
<p> 在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/four-square/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h4>（3）未知密钥矩阵破解</h4>
<p> 推荐一篇关于采用 <a href="http://blog.csdn.net/xianlingmao/article/details/7798647" rel="nofollow,noindex" target="_blank">模拟退火算法</a> 的 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-foursquare-cipher/" rel="nofollow,noindex" target="_blank">四方密码分析</a> 文章，如果有足够多的密文那么四方密码可以轻易被破解，如果知道了明文和密文推出密钥是很容易的，猜测部分明文是一个有效的方法去破解四方密码，如果一部分明文已知或者可以被猜测出 那么我们首先要确定尽可能多可利用的密钥，然后才可以进行更多的推测或者用其他的方法破译。基于四方密码分析一文实现的 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-foursquare-cipher/" rel="nofollow,noindex" target="_blank">C代码</a> 破解示例： </p>
<p>密文(密文最好在200个字符以上)：</p>
<p>HMMKEQESDTMDHLAWFWMNKSOSFOMRFNLWLKHNSQGGEKXEOLLVDXNRSQQGARTFKSAVNUDLFNDHESPZGQ TWESAGPGSQSQSTPKUSBBQLQHESAGPGSQSQGXLNAVHTPMHMKKNYGSUGDMTPDGFNKYAVHXLWGEKRILESLZ ZOFNAVIHRHRKAGHSMYUGEGNSRGAVMVOQPRLNKRXLMYLQPXILESQYBNRHRKAGKYQXDIHMPGPYOERZOLBEZ LURFWLWUOLDDPNSQYAGMUQPQWESBEZVEQESDTMDBQLWDIUSHB</p>
<p>用法：</p>
<pre>#!shell
gcc -O3 -lm foursquarecrack2.c scoreText_2.c -o fsc
./fsc</pre>
<p>输出结果：</p>
<pre>#!shell
Running foursquarecrack, this could take a few minutes... 
best score so far: -1239.505249, on iteration 1
Key: 'KFMLUGWSQEPOZTNRBHDAVXCIY','UGSVKFIZMOYXPQRWTHLNCABED'     
plaintext: 'THECIPHERTEXTSQUARESCANBEGENERATEDUSINGAKEYWORDDROPPINGDUPLICAT
            ELETTERSTHENFILLTHEREMAININGSPACESWITHTHEREMAININGLETTERSOFTHEA
            LPHABETINORDERALTERNATIVELYTHECIPHERTEXTSQUARESCANBEGENERATEDCO
            MPLETELYRANDOMLYTHEFOURSQUAREALGORITHMALLOWSFORTWOSEPARATEKEYSO
            NEFOREACHOFTHETWOCIPHERTEXTMATRICESX'</pre>
<h3>2.棋盘密码</h3>
<p>棋盘密码（Checkerboard Cipher)是使用一个波利比奥斯方阵和两个密钥作为密阵的替换密码，通常在波利比奥斯方阵中J字母往往被包含在I字母中。</p>
<p>示例密阵：</p>
<pre>#!shell
   Q  U  I  C  K
  --------------
B |K  N I/J G  H
R |P  Q  R  S  T
O |O  Y  Z  U  A
W |M  X  W  V  B
N |L  F  E  D  C</pre>
<p>经过密阵替换:</p>
<pre>#!shell
明文:T  H  E  Q  U  I  C  K  B  R  O  W  N  F  O  X
密文:RK BK RU OC OC BI NK BQ WK RI OQ WI BU NU OQ WU</pre>
<h3>23.跨棋盘密码</h3>
<p>跨棋盘密码(Straddle Checkerboard Cipher)是一种替换密码，当这种密码在结合其他加密方式，加密效果会更好。</p>
<p>棋盘示例(选择3和7作为变换):</p>
<pre>#!shell
   0 1 2 3 4 5 6 7 8 9
   f k m   c p d   y e
3: h b i g q r o s a z
7: l u t j n w v x</pre>
<p> 明文: <code>T H E Q U I C K B R O W N F O X</code> </p>
<p> 经过加密棋盘替换得到密文: <code>72 30 9 34 71 32 4 1 31 35 36 75 74 0 36 77</code> </p>
<p>当然我们还可以继续用其他的加密方式在对跨棋盘密码加密出的结果再进行加密:</p>
<p>示例变换密钥:83729</p>
<pre>#!shell
     8372983729837298372983729837
    +7230934713241313536757403677
    -----------------------------
     5502817432078501808630122404</pre>
<p>在经过棋盘转换后:</p>
<pre>#!shell
5502817432078501808630122404
ppfmyk n if  pfkyfyd hkmmcfc</pre>
<p>最终得到密文: ppfmyk n if pfkyfyd hkmmcfc</p>
<p> 在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/straddle-checkerboard/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>24.分组摩尔斯替换密码</h3>
<p> 分组摩尔斯替换密码(Fractionated Morse Cipher)首先把明文转换为莫尔斯电码，不过每个字母之间用 <code>x</code> 分开，每个单词用 <code>xx</code> 分开。然后使用密钥生成一个替换密表，这个密表包含所有 <code>. - x</code> 组合的情况(因为不会出现 <code>xxx</code> 的情况，所以一共26种组合)。 </p>
<p> 密钥: <code>MORSECODE</code> </p>
<p>密表:</p>
<pre>#!shell
MORSECDABFGHIJKLNPQTUVWXYZ
.........---------XXXXXXXX
...---XXX...---XXX...---XX
.-X.-X.-X.-X.-X.-X.-X.-X.-</pre>
<p>说明:密表下半部分是固定的，密表的安全性以及加密效果主要取决于使用的密钥。</p>
<p> 明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p>(类似)摩尔斯电码:</p>
<pre>#!shell
-x....x.xx--.-x..-x..x-.-.x-.-xx-...x.-.x---x.--x-.xx..-.x---x-..-xx.---x..- --x.--.x...xx---x...-x.x.-.xx-x....x.xx.-..x.-x--..x-.--xx-..x---x--.</pre>
<p>说明:明文在转换为(类似)摩尔斯电码后进行每3个字符分组，再进行密表的查表。</p>
<p> 密文(经过密表替换): <code>LMUWC OQVHG ZMTAK EVYSW NOYJQ NLIQB JQCDH XMDYF TWRGP FWNH</code> </p>
<p> 已知密钥在线加解密 <a href="http://ruffnekk.stormloader.com/fractmorse_tool.html" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>25.Bazeries密码</h3>
<p>Bazeries密码(Bazeries Cipher)是换位密码和替换密码的组合，使用两个波利比奥斯方阵，一个明文字母方阵，使用一个随机的数字(一般小于1000000)的生成一个密钥矩阵同时作为第一轮明文划分分组，比如2333这个数字翻译为英文便是TWO THOUSAND THREE HUNDRED THIRTY THREE,从第一个字母T开始选取不重复的字母，之后再从字母表中按序选取没有出现的字母组成密钥矩阵。</p>
<p> 明文: <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> </p>
<p> 随机数字: <code>2333</code> </p>
<p>明文矩阵:</p>
<pre>#!shell
A  F  L  Q  V
B  G  M  R  W
C  H  N  S  X
D I/J O  T  Y
E  K  P  U  Z</pre>
<p>示例密钥矩阵:</p>
<pre>#!shell
T  W  O  H  U
S  A  N  D  R
E I/J Y  B  C
F  G  K  L  M
P  Q  V  X  Z</pre>
<p>明文分组:</p>
<pre>#!shell
2   3   3   3   2   3   3   3  2   3   3  3
TH EQU ICK BRO WN FOX JUM PSO VE RTH ELA ZYD OG</pre>
<p>分组明文反序:</p>
<pre>#!shell
HT UQE KCI ORB WN XOF MUJ OSP EV EHT ALE DYZ GO</pre>
<p>使用密钥矩阵替换:</p>
<pre>#!shell
IL XHP QEG KDS YR CKW NXG KBV PU ILD TOP FMZ AK</pre>
<p>(比如'H'在明文矩阵对应到密钥矩阵的位置就是'I'）</p>
<p> 已知密钥在线加解密 <a href="http://ruffnekk.stormloader.com/bazeries_tool.html" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>26.Digrafid密码</h3>
<p>Digrafid密码(Digrafid Cipher)使用两个密钥生成分别生成类似波利比奥斯方阵的3x9方格的密表。，主要有3分组和4分组两类。</p>
<p> 第一个方阵密钥: <code>digrafid</code> </p>
<p> 第二个方阵密钥: <code>cipher</code> </p>
<p>密表：</p>
<pre>#!shell
1 2 3 4 5 6 7 8 9
D I G R A F D B C 1 2 3
E H J L M N O P Q 4 5 6
S T U V W X Y Z # 7 8 9
                  c f s 1
                  i g t 2
                  p j u 3
                  h k v 4
                  e l w 5
                  r m x 6
                  a n y 7
                  b o z 8
                  d q # 9</pre>
<p> 明文: <code>THE QUICK BROWN FOX</code> </p>
<p>密表转换(以4分组为例):</p>
<pre>#!shell
Th Eq Ui Ck   Br Ow Nf Ox
2  1  3  9    8  7  6  7
7  5  7  2    1  6  5  6
4  9  2  4    6  5  1  6</pre>
<p>说明:T在第一矩阵第2列，h在第二矩阵第4行，T所在的行与h所在的列相交的位置数字为7，所以Th表示为274。</p>
<p>转换密文:</p>
<pre>#!shell
213 975 724 924   876 716 566 516
Ip  #e  Dk  Ck    Zr  Dr  Mx  Ar</pre>
<h3>27.格朗普雷密码</h3>
<p>格朗普雷密码(Grandpré Cipher)是替换密码的一种，一般使用8个8字母的单词横向填充8x8方阵，且第一列为一个单词，并且在方阵中26个字母都必须出现一次以上。</p>
<p>示例密阵:</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_47"> </p>
<pre>#!shell
明文:T  H  E  Q  U  I  C  K  B  R  O  W  N  F  O 
密文:84 27 82 41 51 66 31 36 15 71 67 73 52 34 67</pre>
<p>说明：明文中的字母在密阵位置可能不止一个，所以加密结果可能有多种，但是不影响解密。密阵还有6x6，7x7，9x9,10x10几种。显然密阵越大每个字母被替换的情况就可能越多，那么加密效果就更好。</p>
<h3>28.比尔密码</h3>
<p>比尔密码(Beale ciphers)有三份密码，当然这里说的是已被破解第二份，是一种类似书密码的替换密码。</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_48"> </p>
<p>以第二密码为例，每一个数字代表美国《独立宣言》的文本中的第几个词的首字母，如1代表第1个词的首字母“w”，2代表第2个词首字母“i”。解密后的文字如下：</p>
<p>I have deposited in the county of Bedford...</p>
<p> 比尔密码还有一段有趣的故事，感兴趣可以看一下比尔密码的 <a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E5%B0%94%E5%AF%86%E7%A0%81" rel="nofollow,noindex" target="_blank">详细介绍</a> 。 </p>
<h3>29.键盘密码</h3>
<p> 一般用到的键盘密码就是手机键盘和电脑键盘两种，2014 0ctf比赛里Crypto类型中Classic一题就是电脑键盘密码，详细可以 <a href="http://www.programlife.net/0ops-ctf-writeup.html" rel="nofollow,noindex" target="_blank">参考</a> ，另外给出另外一些 <a href="http://www.secbox.cn/hacker/ctf/8078.html" rel="nofollow,noindex" target="_blank">参考</a> 情况。 </p>
<h2>其他有趣的机械密码</h2>
<h3>1.恩尼格玛密码</h3>
<p> 恩尼格玛密码机（德语：Enigma，又译哑谜机，或“谜”式密码机）是一种用于加密与解密文件的密码机。确切地说，恩尼格玛是对二战时期纳粹德国使用的一系列相似的转子机械加解密机器的统称，它包括了许多不同的型号，为密码学对称加密算法的流加密。详细工作原理参考 <a href="https://zh.wikipedia.org/wiki/%E6%81%A9%E5%B0%BC%E6%A0%BC%E7%8E%9B%E5%AF%86%E7%A0%81%E6%9C%BA" rel="nofollow,noindex" target="_blank">维基百科</a> 。 </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_49"> </p>
<p> 在线模拟 <a href="http://enigmaco.de/enigma/enigma.html" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<p> 感兴趣可以观看 <a href="http://list.youku.com/albumlist/show?id=23400097&amp;ascending=1&amp;page=1" rel="nofollow,noindex" target="_blank">播单:计算机历史文化课</a> </p>
<h2>代码混淆加密</h2>
<p> 1. <a href="http://www.zhaoyuanma.com/aspfix.html" rel="nofollow,noindex" target="_blank">asp混淆加密</a> </p>
<p> 2.[php language="混淆加密"][/php] <a href="http://www.zhaoyuanma.com/phpjmvip.html" rel="nofollow,noindex" target="_blank">118</a> </p>
<p> 3.[css language="/js混淆加密"][/css] <a href="http://tool.css-js.com/" rel="nofollow,noindex" target="_blank">119</a> </p>
<p> 4. <a href="http://www.zhaoyuanma.com/aspfix.html" rel="nofollow,noindex" target="_blank">VBScript.Encode混淆加密</a> </p>
<h3>5.ppencode</h3>
<p>ppencode-Perl把Perl代码转换成只有英文字母的字符串。</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_50"> </p>
<p> ppencode <a href="http://namazu.org/~takesako/ppencode/demo.html" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>6.rrencode</h3>
<p>rrencode可以把ruby代码全部转换成符号。</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_51"> </p>
<p> rrencode <a href="http://www.lab2.kuis.kyoto-u.ac.jp/~yyoshida/rrencode.html" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>7.jjencode/aaencode</h3>
<p> jjencode将JS代码转换成只有符号的字符串，类似于rrencode，介绍的 <a href="http://utf-8.jp/public/20090710/jjencode.pps" rel="nofollow,noindex" target="_blank">PPT</a> ，aaencode可以将JS代码转换成常用的网络表情，也就是我们说的颜文字js加密。 </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_52"> </p>
<p> aaencode <a href="http://utf-8.jp/public/aaencode.html" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<p> jjencode/aaencode的解密直接在浏览器的控制台里输入密文即可执行解密，想要详细了解jjencode是如何进行请 <a href="http://pferrie2.tripod.com/papers/jjencode.pdf" rel="nofollow,noindex" target="_blank">参考</a> ，你也可以在github上 <a href="https://github.com/jacobsoo/Decoder-JJEncode" rel="nofollow,noindex" target="_blank">下载</a> 实现jjdecoder的源码进行分析。 </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_53"> </p>
<h3>8.JSfuck</h3>
<p> JSFuck 可以让你只用 6 个字符 <code>[ ]( ) ! +</code> 来编写 JavaScript 程序。 </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_54"> </p>
<p> JSfuck <a href="http://www.jsfuck.com/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<h3>9.jother</h3>
<p> jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括： <code>! + ( ) [ ] &#123; &#125;</code> 。只用这些字符就能完成对任意字符串的编码。 </p>
<p> <a href="http://drops.wooyun.org/author/do9gy" rel="nofollow,noindex" target="_blank">do9gy</a> 的 <a href="http://drops.wooyun.org/web/4410" rel="nofollow,noindex" target="_blank">jother编码之谜</a> </p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_55"> </p>
<p> jother编码 <a href="http://tmxk.org/jother/" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<p>jother直接在浏览器(IE可以)的控制台里输入密文即可执行解密：</p>
<p> <img src="http://image99.360doc.com/DownloadImg/2016/09/0621/79515527_56"> </p>
<h3>10.brainfuck</h3>
<p> Brainfuck是一种极小化的计算机语言，按照"Turing complete（完整图灵机）"思想设计的语言，它的主要设计思路是：用最小的概念实现一种“简单”的语言，BrainF**k 语言只有八种符号，所有的操作都由这八种符号( <code>&gt; &lt; + - . , [ ]</code> )的组合来完成。 </p>
<p>明文：hello!</p>
<pre>#!shell
+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++++ .---. +++++ ++..+ ++.&lt;+ +++++ +++++
[-&gt;++ +++++ ++++&lt; ]&gt;+++ ++++. &lt;++++ +++[- &gt;---- ---&lt;] &gt;--.&lt; +++++ ++[-&gt;
----- --&lt;]&gt; ----- ----- .&lt;</pre>
<p> brainfuck <a href="http://www.splitbrain.org/services/ook" rel="nofollow,noindex" target="_blank">传送门</a> </p>
<p> 其他稀奇古怪的编程语言请 <a href="http://news.mydrivers.com/1/190/190926.htm" rel="nofollow,noindex" target="_blank">参考</a> </p>





<p>============================</p>
<h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>ZXZhbCgkX1BPU1RbcDRuOV96MV96aDNuOV9qMXVfU2gxX0oxM10p</p>
<p>NTU2NJC3ODHHYWJIZ3P4ZWY=</p>
<p>Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用’=’，因此编码后输出的文本末尾可能会出现1或2个’=’</p>
<h4 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h4><p>Base32和Base64相比只有一个区别就是，用32个字符表示256个ASC字符，也就是说5个ASC字符一组可以生成8个Base字符，反之亦然。</p>
<p><a href="http://base64.xpcha.com/">在线编解码</a></p>
<h4 id="希尔密码"><a href="#希尔密码" class="headerlink" title="希尔密码"></a>希尔密码</h4><p>密文： 22,09,00,12,03,01,10,03,04,08,01,17<br>明文：wjamdbkdeibr</p>
<p>解题思路：使用的矩阵是 1 2 3 4 5 6 7 8 10</p>
<p>a b c d e f g h i j  k  l  m  n   o   p   q   r   s   t   u   v   w   x   y   z</p>
<p>0 1 2 3 4 5 6 7 8 9 10 11  12 13  14  15  16  17  18  19  20  21  22  23  24  25</p>
<p>把字母用数字表示，解密时把数字转换成字母，然后放入脚本，密钥要分成矩阵。一般是对称的</p>
<p><a href="http://bobao.360.cn/ctf/learning/136.html">原文链接</a></p>
<p><a href="http://baike.baidu.com/link?url=R6oWhCdKvzlG8hB4hdIdUT1cZPbFOCrpU6lJAkTtdiKodD7eRTbASpd_YVfi4LMl7N8yFyhVNOz5ki6TC7_5eq">百度百科</a></p>
<p>脚本已存</p>
<h4 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h4><p>把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。</p>
<p>密文样例：tn c0afsiwal kes,hwit1r  g,npt  ttessfu}ua u  hmqik e {m,  n huiouosarwCniibecesnren.</p>
<p>解密程序：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">char s[]= “tn c0afsiwal kes,hwit1r  g,npt  ttessfu&#125;ua u  hmqik e &#123;m,  n huiouosarwCniibecesnren.”;</span><br><span class="line">char t[86]= “”;</span><br><span class="line">int i,j,k;</span><br><span class="line"><span class="attribute">k</span>=0;</span><br><span class="line"><span class="keyword">for</span> (<span class="attribute">i</span>=0;i&lt;17;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">j</span>=0;j&lt;5;j++)</span><br><span class="line">&#123;</span><br><span class="line">t[k++]= ch[j<span class="number">*17</span>+i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=0;i&lt;85;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(“%c”,t[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.csdn.net/shinukami/article/details/45980629">原文链接</a></p>
<p><a href="http://www.practicalcryptography.com/ciphers/classical-era/rail-fence/">在线解密</a></p>
<h4 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h4><p>通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。</p>
<p>常规解密：</p>
<p>from pycipher import Caesar<br>for i in range(1,27):<br>str=Caesar(key=i).encipher(‘UIF RVJDLCSPXOGPYKVNQTPWFSUIFMBAZEPH’)<br>print “mingwen:”+str.lower()+“rn“</p>
<p>密文样例：U8Y]:8KdJHTXRI&gt;XU#?!K_ecJH]kJG<em>bRH7YJH7YSH]</em>=93dVZ3^S8*$:8″&amp;:9U]RH;g=8Y!U92’=j*$KH]ZSj&amp;[S#!gU#*dK9.</p>
<p>解题思路：</p>
<p>得知是凯撒加密之后，尝试进行127次轮转爆破：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lstr</span>=”””U<span class="number">8</span>Y]:<span class="number">8</span>KdJHTXRI&gt;XU#?!K_ecJH]kJG*bRH<span class="number">7</span>YJH<span class="number">7</span>YSH]*=<span class="number">93</span>dVZ<span class="number">3</span>^S<span class="number">8</span>*$:<span class="number">8</span>″&amp;:<span class="number">9</span>U]RH;g=<span class="number">8</span>Y!U<span class="number">92</span>’=j*$KH]ZSj&amp;[S#!gU#*dK<span class="number">9</span>.”””</span><br><span class="line"><span class="attribute">forp</span> in range(<span class="number">127</span>):</span><br><span class="line"><span class="attribute">str1</span> = ”</span><br><span class="line"><span class="attribute">for</span> i in lstr:</span><br><span class="line"><span class="attribute">temp</span> = chr((ord(i)+p)%<span class="number">127</span>)</span><br><span class="line"><span class="attribute">if</span> <span class="number">32</span>&lt;ord(temp)&lt;<span class="number">127</span> :</span><br><span class="line"><span class="attribute">str1</span> = str<span class="number">1</span> + temp</span><br><span class="line"><span class="attribute">feel</span> = <span class="number">1</span></span><br><span class="line"><span class="attribute">else</span>:</span><br><span class="line"><span class="attribute">feel</span> = <span class="number">0</span></span><br><span class="line"><span class="attribute">break</span></span><br><span class="line"><span class="attribute">if</span> feel == <span class="number">1</span>:</span><br><span class="line"><span class="attribute">print</span>(str<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.csdn.net/shinukami/article/details/46369765">原文链接</a></p>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>密文样例：u5927u5bb6u597duff0cu6211u662fu0040u65e0u6240u4e0du80fdu7684u9b42u5927u4ebauff01u8bddu8bf4u5faeu535au7c89u4e1du8fc7</p>
<p><a href="tool.chinaz.com/Tools/Unicode.aspx">在线解密</a></p>
<h4 id="brainfuck"><a href="#brainfuck" class="headerlink" title="brainfuck"></a>brainfuck</h4><p>类型：++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</p>
<blockquote>
<p>++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</p>
</blockquote>
<blockquote>
<p>.+++.——.——–.&gt;+.&gt;.</p>
</blockquote>
<p>利用BFVM.exe直接解密</p>
<p>用法 loadtxt 1.txt</p>
<p><a href="http://www.splitbrain.org/services/ook">在线解密</a></p>
<h4 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a>摩斯密码</h4><p>密文样例：–  —  .-.  …  .</p>
<p><a href="http://www.jb51.net/tools/morse.htm">在线解密</a></p>
<h4 id="jsfuck"><a href="#jsfuck" class="headerlink" title="jsfuck"></a>jsfuck</h4><p>密文中 ()[]{}!+</p>
<p><a href="www.jsfuck.com">在线解密</a></p>
<p><a href="http://patriciopalladino.com/files/hieroglyphy/">在线解密</a></p>
<p>如果jsfuck定义的是一个函数并且最后以()结尾，则在火狐console中运行时函数也会运行，就会错掉什么提示。这时候需要把最后的()换成.toString() </p>
<h4 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h4><p>培根所用的密码是一种本质上用二进制数设计的。不过，他没有用通常的0和1来表示，而是采用a和b。</p>
<p><a href="http://baike.baidu.com/link?url=acaeI3babB7MogPQFh98rDAVSwHfPwh-HnEFTb9cx7DZ5Nz4MkMA14H4SDjBNnOdBsJpliNYa1vnfikQGqvA7K">百科链接</a></p>
<p>已知将一个flag以一种加密形式为使用密钥进行加密，使用密钥WELCOMETOCFF加密后密文为</p>
<p>培根密码表看其他文件</p>
<h4 id="费娜姆密码"><a href="#费娜姆密码" class="headerlink" title="费娜姆密码"></a>费娜姆密码</h4><h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>已知将一个flag以一种加密形式为使用密钥进行加密，使用密钥WELCOMETOCFF加密后密文为 00000000000000000000000000000000000</p>
<p>0000000000000000101110000110001000000101000000001 请分析出flag。</p>
<p>密钥为12位，密文为84位，可能是异或：</p>
<p>7位二进制可能表示字母顺序：</p>
<p>W     E     L     C     O     M    E    T    O     C     F    F</p>
<p>密文</p>
<p>0000000 0000000 0000000 0000000 0000000 0000000 0000000 0010111 0000110 0010000 0010100 0000001</p>
<p>密钥</p>
<p>0010111 0000101 0001100 0000011 0001111 0001101 0000101 0010100 0001111 0000011 0000110 0000110</p>
<p>Xor</p>
<p>0010111 0000101 0001100 0000011 0001111 0001101 0000101 0000011 0001001 0010011 0010010 0000111</p>
<p>W     E     L     C     O     M    E    C     I     S    R     G</p>
<p>即：WELCOMECISRG</p>
<p>flag：WELCOMECISRG</p>
<h4 id="猪圈密码，又称共济会密码"><a href="#猪圈密码，又称共济会密码" class="headerlink" title="猪圈密码，又称共济会密码"></a>猪圈密码，又称共济会密码</h4><p><a href="http://baike.baidu.com/link?url=yN39kWG2pGd9XHo3RjeUAbd7xs0QlnJ2uHzCJfxC03V-fJcQUdfcJ-WuGoAkKGFVE0AxFK4-98wa4FtzvxRA0_">百度百科</a></p>
<h4 id="CRC32"><a href="#CRC32" class="headerlink" title="CRC32"></a>CRC32</h4><p>密文样例：4D1FAE0B</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">import zlib</span><br><span class="line"></span><br><span class="line">def crc32(<span class="keyword">st</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">crc</span> = zlib.crc32(<span class="keyword">st</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">crc</span> &gt; 0:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> “%x” % (<span class="keyword">crc</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> “%x” % (~<span class="keyword">crc</span> ^ 0xffffffff)</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.csdn.net/ab748998806/article/details/46382017">原文链接</a></p>
<h4 id="颜文字加密-aaencode"><a href="#颜文字加密-aaencode" class="headerlink" title="颜文字加密(aaencode)"></a>颜文字加密(aaencode)</h4><p>这个好萌啊&gt;.&lt;</p>
<p>颜文字js加密：明文alert(“flag”);</p>
<p>密文：ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //<em>´∇｀</em>/ [‘<em>’]; o=(ﾟｰﾟ) =</em>=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: ‘_’ ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +’_’) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ ‘_’)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +’_’)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +’_’) [c language=”^_^o”][/c];(ﾟДﾟ) [‘c’] = ((ﾟДﾟ)+’_’) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [‘o’] = ((ﾟДﾟ)+’_’) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [‘c’]+(ﾟДﾟ) [‘o’]+(ﾟωﾟﾉ +’_’)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +’_’) [ﾟｰﾟ] + ((ﾟДﾟ) +’_’) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ]+((ﾟｰﾟ==3) +’_’) [(ﾟｰﾟ) – (ﾟΘﾟ)]+(ﾟДﾟ) [‘c’]+((ﾟДﾟ)+’_’) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [‘o’]+((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ];(ﾟДﾟ) [‘_’] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+’_’) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +’_’) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ]+ (ﾟωﾟﾉ +’_’) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=’\’; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +’_’)[c language=”^_^o”][/c];(ﾟДﾟ) [ﾟoﾟ]=’”‘;(ﾟДﾟ) [‘_’] ( (ﾟДﾟ) [‘_’] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) – (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) – (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) – (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (‘_’);</p>
<p><a href="http://utf-8.jp/public/aaencode.html">在线解密</a></p>
<h4 id="Jjencode"><a href="#Jjencode" class="headerlink" title="Jjencode"></a>Jjencode</h4><p>密文：$=~[];$={<em><strong>:++$,$$$$:(![]+””)[$],</strong>$:++$,$</em>$<em>:(![]+””)[$],</em>$<em>:++$,$</em>$$:({}+””)[$],$$<em>$:($[$]+””)[$],</em>$$:++$,$$$<em>:(!””+””)[$],$__:++$,$</em>$:++$,$$<strong>:({}+””)[$],$$<em>:++$,$$$:++$,$</em></strong>:++$,$<strong>$:++$};$.$<em>=($.$</em>=$+””)[$.$<em>$]+($.</em>$=$.$_[$.</strong>$])+($.$$=($.$+””)[$.<strong>$])+((!$)+””)[$._$$]+($.</strong>=$.$<em>[$.$$</em>])+($.$=(!””+””)[$.<strong>$])+($.<em>=(!””+””)[$.</em>$<em>])+$.$</em>[$.$_$]+$.</strong>+$.<em>$+$.$;$.$$=$.$+(!””+””)[$.</em>$$]+$.<strong>+$.<em>+$.$+$.$$;$.$=($.</em></strong>)[$.$<em>][$.$</em>];$.$($.$($.$$+”””+$.$<em>$</em>+(![]+””)[$.<em>$</em>]+$.$$$<em>+”\”+$.__$+$.$$</em>+$.<em>$</em>+$.<strong>+”(\”\”+$.</strong>$+$.<strong>$+$.</strong><em>+$.$$$</em>+(![]+””)[$.<em>$</em>]+(![]+””)[$.<em>$</em>]+$.<em>$+”,\”+$.$<strong>+$.</strong></em>+”\”+$.<strong>$+$.</strong>$+$.<em>$</em>+$.$<em>$</em>+”\”+$.<strong>$+$.$$<em>+$.$$</em>+$.$<em>$</em>+”\”+$.</strong>$+$.<em>$</em>+$.<em>$$+$.$$<strong>+”\”+$.</strong>$+$.$$</em>+$.<em>$</em>+”\”+$.<strong>$+$.$_$+$.</strong>$+”\”+$.<strong>$+$.$$<em>+$.</em></strong>+$.<strong>+”\”\”+$.$</strong>+$.___+”)”+”””)())();</p>
<p><a href="http://utf-8.jp/public/jjencode.html?src=&var=$">解密地址</a></p>
<h4 id="无字母加密"><a href="#无字母加密" class="headerlink" title="无字母加密"></a>无字母加密</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">@<span class="variable">$_</span>++; <span class="comment">// $_ = 1</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$__</span>=(“<span class="comment">#”^”|”); // $__ = _</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$__</span>.=(“.”^”~”); <span class="comment">// _P</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$__</span>.=(“/”^”`”); <span class="comment">// _PO</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$__</span>.=(“|”^”/”); <span class="comment">// _POS</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$__</span>.=(“&#123;“^”/”); <span class="comment">// _POST</span></span><br><span class="line"></span><br><span class="line">$&#123;<span class="variable">$__</span>&#125;[!<span class="variable">$_</span>]($&#123;<span class="variable">$__</span>&#125;[<span class="variable">$_</span>]); <span class="comment">// $_POST[0]($_POST[1]);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://www.waitalone.cn/php-backdoor.html">在线解密</a></p>
<h4 id="Utf-7编解码"><a href="#Utf-7编解码" class="headerlink" title="Utf-7编解码"></a>Utf-7编解码</h4><p>原文：gdfgdfg</p>
<p>密文：+AGcAZABmAGcAZABmAGc-</p>
<p>无论何种，都是+开头-结尾</p>
<p><a href="http://tomeko.net/online_tools/base32.php?lang=en">在线解密</a></p>
<h4 id="云影密码"><a href="#云影密码" class="headerlink" title="云影密码"></a>云影密码</h4><p>如果密码只有01248组成。。。</p>
<p>原理很简单，有了1，2，4，8这四个简单的数字，你可以以加法表示出0-9任何一个数字，例如0=28，7=124，9=18。</p>
<p>这样，再用1-26来表示A-Z，就可以用作密码了。</p>
<p>为了不至于混乱，我个人引入了第五个数字0，来用作间隔，以避免翻译错误，所以还可以称“01248密码”。</p>
<p>题目：12401011801180212011401804</p>
<p>第一步，分割，即124  1  118  118  212  114  18  4</p>
<p>第二步，基本翻译，例如124可以表示7，也可以表示16（但不可能是34，因为不会超过26），所以可以放在一边，翻译其他没有异议的，可得：124  a  s  s  w  o  18  d</p>
<p>第三步，推测得出明文。可以推测后面的18表示r，前面的为p最合适。</p>
<p>明文：password（密码）.</p>
<h4 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h4><p>key welcometoicqedu</p>
<p>密文UUyFTj8PCzF6geFn6xgBOYSvVTrbpNU4OF9db9wMcPD1yDbaJw==</p>
<p>用脚本解密 脚本已存 </p>
<h4 id="曼彻斯特"><a href="#曼彻斯特" class="headerlink" title="曼彻斯特"></a>曼彻斯特</h4><p>转二进制 不是10就是01 即是曼彻斯特 解密看脚本</p>
<p>对于其他一些未知密文，可尝试到下列几个网站转换试试，看看运气</p>
<p><a href="http://web.chacuo.net/charsetuuencode">在线解密</a></p>
<p><a href="http://blog.csdn.net/ab748998806/article/details/46368337">在线解密</a></p>
<p><a href="http://www.qqxiuzi.cn/bianma/wenbenjiami.php">在线解密</a></p>
<h3 id="其他小技巧："><a href="#其他小技巧：" class="headerlink" title="其他小技巧："></a>其他小技巧：</h3><ul>
<li><p>如果密文是十进制，字符范围为“0-9”，可以猜测是ASCII编码；</p>
</li>
<li><p>如果密文由“a-z”“A-Z”和“=”构成，特别是末尾有“=”，那么可以判断为Base64编码；</p>
</li>
<li><p>如果密文含有“%” ，形式为 “%xx” 和 “%uxxxx”，字符范围又是十六进制“0-F”，判断是escape() 函数编码，用unescape()解码；</p>
</li>
<li><p>若密文由“[]，()，{}，+,！”字符组成的编码通常就通过Jother解密。</p>
</li>
</ul>
<p>判断出可能的编码方式，就可以使用程序或工具进行解密。</p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>这位大叔，生日快乐</title>
    <url>/articles/Essay-Happy-Birthday.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>24岁生日快乐。</p>
<p><del> 少年 </del>？</p>
<p>不存在的，已经大叔了。天天煮心灵鸡汤那种大叔。</p>
<span id="more"></span>

<p>有两个事情，今天高兴一下。</p>
<ul>
<li><p>个人主页正式调试完毕，所有功能齐全。</p>
</li>
<li><p>摊上一个好领导，说过段时间让我去安全部试试。</p>
</li>
</ul>
<p>说实话有时候虽然在公司挺努力的，但是还是觉得自己做的太少了。</p>
<p>辣鸡。</p>
<p>不过至少前途，是能看到光明的。</p>
<p>现在才懂了付出了是真的会有结果的。</p>
<p>只是一天天变得坚硬而冷淡了。</p>
<p>莫名其妙。</p>
<p>打开各种游戏试了试，嗯，已经<strong>手残</strong>了。</p>
<p>也不知道自己都写啥了，差不多要去睡觉了。</p>
<p>晚安。</p>
]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>爱与尊重</title>
    <url>/articles/Essay-Love-and-Respect.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>最成熟的爱，是尊重对方，让他成长为最好的自己。</strong></p>
<span id="more"></span>

<h4 id="成熟"><a href="#成熟" class="headerlink" title="成熟"></a>成熟</h4><p>怎么定义“成熟”？</p>
<p>人们对于“成功”、“幸福”诸如此类的定义和内涵，早已没了太大的分歧，达成了一定的共识。</p>
<p>譬如：</p>
<p>成功就是和自己比，每天进步一点点。</p>
<p>幸福其实是一种心理体验，是靠比较得来的，是存在于日常琐事中的。</p>
<p>其实这样“正态”的形容词，共同点是和财富不成正相关。</p>
<p>然而对于“成熟”的定义，却似乎比他们要复杂得多。</p>
<p>“成熟就是看破不说破。”</p>
<p>“成熟就是话到口边留三分。”</p>
<p>“成熟就是心中虽有千万头草泥马呼啸而过却挂着笑脸说你好。”</p>
<p>“成熟就是心中其实早已满目苍夷血泪模糊脸上仍旧笑容灿烂可掬。”</p>
<p>“成熟就是以适合的方式对待不同的人。”</p>
<p>“成熟就是……”</p>
<p>鬼知道到底是啥。</p>
<p>关于这些定义，大概人们只认同让自己满意的那些吧。</p>
<p>我说成熟是什么呢……</p>
<p>拥有独立生活的能力以及享受孤独的能力；</p>
<p>为回忆伤感却不再悔恨；</p>
<p>理解复杂，选择简单；</p>
<p>越来越不装聪明；</p>
<p>憋得住尿，更重要的是憋得住话；</p>
<p>不是年龄有多大，而是肩膀能担起多少责任；</p>
<p>不是绷起脸显得多么老道，而是遇事沉着冷静了然于胸；</p>
<p>不是知道多少大是大非，而是能理解有些事情的发生也许有不得已；</p>
<p>不是经历了多少成功失败，而是学会了宽容懂得了理解；</p>
<p>淡然面对一切，不强求，凡是尽人事，随缘而安；</p>
<p>……</p>
<blockquote>
<p>成熟是一种明亮而不刺眼的光辉。    ——余秋雨</p>
</blockquote>
<h4 id="尊重"><a href="#尊重" class="headerlink" title="尊重"></a>尊重</h4><p>尊重，指尊敬和重视。</p>
<p>尊重自己，尊重他人。</p>
<p>自尊没什么好说的，全废话。</p>
<p>怎么尊重他人呢？</p>
<p>“平等”是尊重的前提。</p>
<p>学会理解与倾听。</p>
<p>学会换位思考。</p>
<h4 id="爱"><a href="#爱" class="headerlink" title="爱"></a>爱</h4><p>爱是什么样子呢？</p>
<p>很多人总习惯以自己的标准和喜好去影响、改变对方。</p>
<p>我觉得适合我的，是什么样子呢？两个人互相尊重，活成各自最好的样子。不过这算不算是，又以我自己的的标准和喜好去怎样了呢？我似乎变得很自私。我也不知道。</p>
<p>曾经在知乎点赞了一篇，“恋人间最好的状态是什么？”</p>
<blockquote>
<p>你相信自己能变得更好，而不是紧张地怀疑自己是否做错了什么。</p>
</blockquote>
]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的男人自带烧钱属性</title>
    <url>/articles/Essay-Interesting-Boy.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>都说好看的女孩子自带烧钱属性。其实有趣的男生何尝不是如此呢？</p>
<span id="more"></span>

<p>很多人觉得一个男生每天有什么好忙的，一套格子衫就能穿上一个季度，又不需要保养品，干嘛那么努力挣钱。我当时就笑了。如果你认识一个有趣的男生，你就会了解，有趣是有代价的。他自己组装的PC、雷蛇机械键盘、森海塞尔耳机的价格可能让你瞠目结舌，各式各样的Steam游戏抵得上限量款香奈儿圣诞口红价格。他时常去旅行，对各种相机和镜头如数家珍，周末去健身房撸铁打拳（但是不会撩妹）。正是这些元素撑起了他的有趣。这都需要钱。</p>
<p>其实自己也时常会有这样的想法：我是不是太浪费钱了；我要不要谈恋爱了；我还得买车买房啊；我还需要很多钱和喜欢的人约会旅行吃大餐啊……其实蛮纠结的。</p>
<p>但有时候会想象到，一个宅男算得上是个完美男友，整日只想着存钱给女朋友买房子，省吃俭用，不打游戏不旅行，一件格子衬衣加洗得发白的牛仔裤可以穿两三年，节假日舍不得出去旅游，只在窝在家里陪女友刷剧。有一天妹子参加同学聚会，立刻被初恋吸引住了。这个有趣的男人，可以滔滔不绝地讲在北欧旅行路过的小镇，在阿尔卑斯山滑雪，三文鱼、牛排配红酒的各种吃法。聚会后，妹子跟着初恋回了家，看到一墙的旅拍，一柜子的相机镜头，还有手办和航模，男人讲自己经常逛的展览，侃侃而谈。妹子被这样的初恋又吸引了，旧情复燃果断出轨。</p>
<p>宅男伤心极了，反正房子也不买了，钱留着也没用，就大方地去潇洒吧。于是他买了自己一直想买的咖啡机，组装了四路泰坦的顶配电脑，衣柜里摆满了潮牌鞋服，配了一块儿手表，余下的钱给爸妈买了保险，陪爸妈出去旅游。</p>
<p>几个月后，他变了。谈吐间透露出男人的有趣和健谈。</p>
<p>我想，也许，就算你买下全部的电脑外设和 Steam 游戏，全部的 AJ 和百达翡丽手表，全部的相机镜头，不喜欢的人可能还是不会喜欢你，但喜欢你的人，会越来越多。最重要的是，你会爱上一个有趣的自己。</p>
<p>男生为什么要有钱？</p>
<p>我想大概是为了过上更好的生活，买得起更多的电子产品、游戏和设备，最后遇见并爱上一个女孩子，跟她一起奋斗并且度过这一生吧。</p>
<p>要买 NVIDIA 2080Ti，Conan 5D5，Sony A7R3，DJI Inspire 2……各种电子设备在男人眼里都是最好的玩具。</p>
<p>要去家旁边最好的健身房办十年卡，请最好的私教上常规课、拳课、拉伸课，苦练胸肌马甲线，去除中年的油腻。</p>
<p>要去买豪华大气的车，买带阁楼和落地窗的大房子以及高级感的装修，给自己的老婆孩子一个家。</p>
<p>总而言之，有钱，会让我们变得更有趣。</p>
<p>想来，这个社会为什么富人更富，穷人更穷，其实是因为，富人不需要担心生活中的琐碎，不需要被各种压力烦恼，可以把精力用在更多提升自己的地方；而穷人终其一生都在为了锅碗瓢盆的琐事困扰、被买房买车的压力压垮，哪里还有精力去提升自己呢？</p>
<p>你什么都嫌贵，吃的嫌贵，穿的嫌贵，运动嫌贵，设备嫌贵，游戏嫌贵……无论做什么都嫌贵，自己就变得廉价，别人也会嫌你廉价。</p>
<p>所以男人最好的状态应该是，我能赚钱养家，也能让自己变得好玩有趣。</p>
<p>从今天起，做一个有趣的男孩儿，面向大海，摁下快门，只关心装备和游戏。</p>
<p>……</p>
<p>以上，均为扯淡。</p>
<p>说出来的话多少有点情绪化，甚至显得有点直男癌，可其实很多话是说得夸张了。</p>
<p>只是看到太多周围的朋友，因为车房婚恋的压力，逐渐变成了赚钱工具，没有了自己的生活和灵魂。</p>
<p>当然了，年轻人也要攒钱啊，我自己也因为买相机和健身，在一段时间变得有些狼狈，负债还钱的滋味并不好受。但是我也不会后悔，因为作为程序员，必须要随时想好自己的后路，30 多岁做不动的时候，那时候也是生活压力最大的时候，我还能通过什么来继续维持生活呢？对于我来讲，是摄影，是美食，是写作。所以我年轻时候烧的钱，以后还会通过这些赚回来，顺便假装自己是个文艺青年。</p>
<p>本杰明·富兰克林说过：“有些人二十五岁就死了，只是到七十五岁才被埋葬。”</p>
<p>我想和最爱的人，在一起活到疯狂到一百岁。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>个人成长总结</title>
    <url>/articles/Essay-Personal-Development.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>准备面试以来，除了学习以外的个人成长总结。</p>
<span id="more"></span>

<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>中间件</p>
<p>架构设计</p>
<p>设计模式</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>寻找共性</p>
<p>提升抽象层次</p>
<p>构建金字塔</p>
<p><strong>金字塔模型</strong></p>
<p>结构化思考和表达</p>
<p>自下而上思考，总结概括；自上而下表达，结论先行。</p>
<p><strong>如何提升抽象思维能力</strong></p>
<p>多阅读，少看视频和图像</p>
<p>多总结，写作、表达，锻炼抽象思维和结构化能力</p>
<p>领域建模训练</p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分而治之</p>
<p>分：递归地将原问题分解成小问题</p>
<p>治：逐个击破之后合并小问题的解，从而得到整个问题的解</p>
<ol>
<li>分解：将要解决的问题划分成若干规模较小的同类问题</li>
<li>求解：当子问题划分得足够小时，用较简单的方法解决</li>
<li>合并：按原问题的要求，将子问题的解逐层合并，构成原问题的解</li>
</ol>
<h4 id="编程中的分治"><a href="#编程中的分治" class="headerlink" title="编程中的分治"></a>编程中的分治</h4><ul>
<li>相关算法</li>
</ul>
<ul>
<li>函数分解</li>
</ul>
<p>坏味道：又臭又长的代码，将大函数分解为多个短小、易读、易维护的小函数</p>
<p>原则：</p>
<ol>
<li>单一职责原则</li>
<li>在使用组合函数模式时，要注意抽象层次一致性原则，不同抽象层次的内容放在一起会给人凌乱、逻辑不协调的感觉。</li>
</ol>
<ul>
<li>写代码的两次创作</li>
</ul>
<ol>
<li>第一遍实现功能，创造</li>
<li>第二遍重构优化，创作</li>
</ol>
<ul>
<li>分治相关设计模式</li>
</ul>
<p>管道模式，装饰者模式，责任链模式……</p>
<ul>
<li>分层设计</li>
</ul>
<p>分层设计是架构体系设计中最常见和重要的一种结构。</p>
<p>分层设计最大的好处就是分离关注。就可以通过分层隔离简化一个复杂的问题，让每一层只对上一层负责，从而使每一层的职责变得相对简单。</p>
<ul>
<li>横切和竖切</li>
</ul>
<p>数据库设计，分库分表分区</p>
<h2 id="技术人的素养"><a href="#技术人的素养" class="headerlink" title="技术人的素养"></a>技术人的素养</h2><h3 id="不教条"><a href="#不教条" class="headerlink" title="不教条"></a>不教条</h3><p>控制系统复杂度，但凡能提高代码可读性、可扩展性和可维护性的方法，都是值得考虑的，并不一定要拘泥于某种特定的开发过程或者编程范式。</p>
<p>IDP：强行拆模块，导致开发复杂度提升，关键是本来也没有先做规范，导致后续开发进一步陷入混乱。</p>
<p>当然，首先要学会基本的原则，然后才能知道什么时候去打破规则。在遵守规范和原则的基础上适时打破规则来满足目标。</p>
<h3 id="不炫技"><a href="#不炫技" class="headerlink" title="不炫技"></a>不炫技</h3><p>不能为了炫技而过度设计或强行使用。存在瓶颈的时候为了解决问题才要适当引入合适的解决方案。</p>
<h3 id="批判性思维"><a href="#批判性思维" class="headerlink" title="批判性思维"></a>批判性思维</h3><p>批判性思维是一种谨慎运用推理去断定一个断言是否为真的能力。它要求个人保持思考的自主性和逻辑的严密性，不被动地全盘接受，也不刻意地带着偏见去驳斥一个观点。</p>
<h3 id="成长型思维"><a href="#成长型思维" class="headerlink" title="成长型思维"></a>成长型思维</h3><p>成长的过程中不可能是一帆风顺的，肯定会有痛苦、有阻力、有挫折。</p>
<p>面对逆境，应该怎么做？</p>
<p>有些人也许不堪重负，就此沉沦；有些人可以越挫越勇，把每次失败都当成学习的机会。</p>
<p>成长型思维和固定型思维会极大影响人们面对逆境的处理方式。</p>
<p>我们获得的成功并不是完全由能力和天赋决定的，更多受到我们再追求目标的过程中展现的思维模式的影响。</p>
<table>
<thead>
<tr>
<th>成长型思维</th>
<th>固定型思维</th>
</tr>
</thead>
<tbody><tr>
<td>我的态度和汗水决定了一切</td>
<td>我的聪明才智决定了一切</td>
</tr>
<tr>
<td>我可以学会任何我想学的东西</td>
<td>我擅长某些事，不擅长另外一些事</td>
</tr>
<tr>
<td>我想要挑战我自己</td>
<td>我不想要尝试我可能不擅长的东西</td>
</tr>
<tr>
<td>当我失败的时候，我学会很多东西</td>
<td>如果我失败了，我就无地自容</td>
</tr>
<tr>
<td>我希望你表扬我很努力</td>
<td>我希望你表扬我很聪明</td>
</tr>
<tr>
<td>如果别人成功了，我会受到别人的启发</td>
<td>如果别人成功了，他会威胁到我</td>
</tr>
</tbody></table>
<p>成长型思维和固定型思维体现了应对成功与失败、成绩与挑战时的两种基本心态。认为才智和努力哪个更重要、能力能否通过努力改变，决定了你是否会满足于既有成果，还是会积极探索新知。通过了解自己的思维模式并做出改变，人们能以最简单的方式培养对学习的热情，以及在任何领域内取得成功都需要的抗压力。</p>
<p>具有成长型思维的人相信自己可以通过学习来提升自我，相信学习和成长的力量，相信努力可以改变智力和能力。会用更加理性的态度看待一时的成败得失，内心坚定地相信成长和学习的力量。工作或生活中面临挑战时，不会轻言放弃，而是会积极主动地去学习，去寻找解决方案。即使最终还是失败了，也不要一蹶不振，而是把失败当成学习的动力和机会。</p>
<h3 id="结构化思维"><a href="#结构化思维" class="headerlink" title="结构化思维"></a>结构化思维</h3><p>逻辑+套路</p>
<p><strong>逻辑</strong></p>
<ul>
<li>演绎顺序</li>
</ul>
<p>大前提、小前提、结论</p>
<ul>
<li>时间/步骤顺序</li>
</ul>
<p>第一、第二、第三，首先、再者、然后，大多数时间顺序也是因果顺序</p>
<ul>
<li>空间/结构顺序</li>
</ul>
<p>前端、后端、数据库，东方、南方、西方、北方，化整为零，相互独立，完全穷尽</p>
<ul>
<li>程度/重要性顺序</li>
</ul>
<p>最重要、次重要、不重要</p>
<p><strong>套路</strong></p>
<p>解决问题的方法论、路径和经验</p>
<p>5W2H：why、who、when、where、what、how、how much</p>
<p>逻辑是一种能力，而套路是方法论、经验；</p>
<p>逻辑属于道，而方法论属于术。</p>
<h3 id="如何融入新团队"><a href="#如何融入新团队" class="headerlink" title="如何融入新团队"></a>如何融入新团队</h3><p>结构化拆解问题：团队/项目/企业——业务、技术、人</p>
<p>业务：产品形态，业务流程，走访客户</p>
<p>技术：系统架构，领域模型，代码结构</p>
<p>人：组织结构，人员角色，勤沟通</p>
<h3 id="工具化思维"><a href="#工具化思维" class="headerlink" title="工具化思维"></a>工具化思维</h3><p>适当的懒比低效的勤奋更具智慧，懒惰的对立面除了勤奋也可能是硬干、苦干、傻干，可能是一种徒劳、低效、大可不必的努力，只会说明做事情过于急切，欠缺思考。人们很容易混淆行动与进展、忙碌与多产的概念。</p>
<p>在有效的工作中，最重要的是学习和思考，而人在思考的时候通常看上去不会很忙。</p>
<p>智慧懒是一种工具化思维，是磨刀不误砍柴工的智慧。</p>
<p>程序员与其他行业的最大区别是不仅使用工具，还能创造工具。</p>
<p>对于整天非常忙，忙到没有时间思考的人，真心建议停下来，思考一下：我是否存在知识盲区（先探索完整个地图，再选择交通工具，然后规划路线，最后一路顺风）？我的方法有没有问题？是不是有更“偷懒”的方式可以帮助我提升效率？</p>
<h3 id="好奇心"><a href="#好奇心" class="headerlink" title="好奇心"></a>好奇心</h3><h3 id="记笔记，写总结"><a href="#记笔记，写总结" class="headerlink" title="记笔记，写总结"></a>记笔记，写总结</h3><h3 id="有目标，有野心"><a href="#有目标，有野心" class="headerlink" title="有目标，有野心"></a>有目标，有野心</h3><h3 id="选择的自由"><a href="#选择的自由" class="headerlink" title="选择的自由"></a>选择的自由</h3><h3 id="平和的心态"><a href="#平和的心态" class="headerlink" title="平和的心态"></a>平和的心态</h3><p>动机至善，了无私心；用无为的心，做有为的事。</p>
<p>无为：平和的心态，活在当下的智慧，宠辱不惊</p>
<h3 id="精进"><a href="#精进" class="headerlink" title="精进"></a>精进</h3><p>每天进步一点点，慢就是快</p>
<h2 id="Leader-amp-Manager"><a href="#Leader-amp-Manager" class="headerlink" title="Leader &amp; Manager"></a>Leader &amp; Manager</h2><p>manager 是管理事务，是控制和权威；</p>
<p>leader 是领导人心，是引领和激发。</p>
<p>我们不需要这么多“高高在上”“指点江山”的技术 manager，而是需要更多能真正深入系统里面，深入代码细节，给团队带来提升和改变的技术 leader。</p>
<h3 id="技术氛围"><a href="#技术氛围" class="headerlink" title="技术氛围"></a>技术氛围</h3><ul>
<li><p>代码好坏味道</p>
</li>
<li><p>技术分享</p>
</li>
<li><p>代码评审</p>
</li>
<li><p>读书会</p>
</li>
</ul>
<h3 id="目标管理"><a href="#目标管理" class="headerlink" title="目标管理"></a>目标管理</h3><ul>
<li><p>KPI or OKR</p>
</li>
<li><p>SMART 原则</p>
</li>
</ul>
<p>S：specific，明确性</p>
<p>M：measurable，衡量性</p>
<p>A：attainable，实现性</p>
<p>R：relevant，相关性</p>
<p>T：time bound，时限性</p>
<h3 id="技术规划"><a href="#技术规划" class="headerlink" title="技术规划"></a>技术规划</h3><ul>
<li>当前问题/痛点</li>
<li>业务领域</li>
<li>技术领域</li>
<li>团队特色</li>
</ul>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h1 id="工程师精进原则"><a href="#工程师精进原则" class="headerlink" title="工程师精进原则"></a>工程师精进原则</h1><p><a href="https://tech.meituan.com/2018/08/16/10-principles-for-engineers.html">https://tech.meituan.com/2018/08/16/10-principles-for-engineers.html</a></p>
<h2 id="Owner-意识"><a href="#Owner-意识" class="headerlink" title="Owner 意识"></a>Owner 意识</h2><ul>
<li>认真负责是工作的底线。</li>
<li>积极主动是“Owner意识”更高一级的要求。</li>
</ul>
<h2 id="时间观念"><a href="#时间观念" class="headerlink" title="时间观念"></a>时间观念</h2><p>做事有计划，工作分主次。</p>
<h2 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h2><p>先想清楚目标，然后努力实现。</p>
<p>要根据问题设定目标，再进行优化。</p>
<p>带着目标去学习。</p>
<h2 id="闭环思维"><a href="#闭环思维" class="headerlink" title="闭环思维"></a>闭环思维</h2><p>一个人是否靠谱，就看他能否做到凡事有交代，件件有着落，事事有回音。<strong>它强调的是一种即时反馈闭环，</strong>如果别人给我们分配了一个任务，不管完成的结果如何，一定要在规定的时间内给出明确的反馈。</p>
<p><strong>真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。</strong></p>
<p><strong>“闭环思维”还要求能够定期主动进行阶段性的反馈。</strong></p>
<h2 id="保持敬畏"><a href="#保持敬畏" class="headerlink" title="保持敬畏"></a>保持敬畏</h2><p><strong>当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。</strong></p>
<p><strong>让规范与约定与时俱进，也是另一种形式的敬畏。</strong></p>
<h2 id="事不过二"><a href="#事不过二" class="headerlink" title="事不过二"></a>事不过二</h2><p><strong>所有的评审、问题讨论、错误，不要超过两次。</strong></p>
<h2 id="设计优先"><a href="#设计优先" class="headerlink" title="设计优先"></a>设计优先</h2><p>软件架构的目标，是为了让构建与维护系统的所需人力资源最小化。</p>
<p><strong>架构设计，并不仅仅关系到系统的质量，还关乎团队的效能问题。</strong></p>
<p><strong>无数事实证明，忽略了前期设计，往往会导致后续开发周期被大幅拉长，给项目带来了很大的Delay风险。而且最可怕的是，不当的设计会给项目带来巨大的后期维护成本，我们不得不腾出时间，专门进行项目的优化与重构。</strong></p>
<p><strong>“设计优先”这一原则，要求写别人看得懂的设计</strong>。在设计过程中，要以需求为出发点，通过合理的抽象把问题简化，讲清楚各个模块之间的关系，再详细分述模块的实现细节。做完设计之后，可以发给比较资深的RD或者PM审阅一下，根据他们的反馈再进行完善。好的设计，一定是逻辑清晰易懂、细节落地可执行的。</p>
<h2 id="P-PC-平衡"><a href="#P-PC-平衡" class="headerlink" title="P/PC 平衡"></a>P/PC 平衡</h2><p><strong>产出与产能必须平衡，才能达到真正的高效能</strong>。</p>
<p>从系统的角度看，每一个系统都是通过持续不断地叠加功能来实现其产出，而系统的产能是通过系统架构的可扩展性、稳定性等一系列特性来表征。为了达到产出与产能的平衡，需要在不断支持业务需求的过程中，持续进行技术架构层面的优化。如果一味地做业务需求，经过一定的时间，系统会越来越慢，最终影响业务的稳定性；反之，一个没有任何业务产出的系统，最终会消亡。</p>
<p>再从RD的角度来看这个问题，RD通过做需求来给公司创造价值，实现自己的产出。而RD的产能是指技术能力、软素质、身体健康状况，有这些资本后，我们才能进行持续的产出。在日常工作中，我发现很多RD往往只重视产出。他们也在很努力地做项目，但是每一个项目所使用的方法，还是沿用自己先前一贯的思路。最终，不仅项目做得一般，还会抱怨自己得不到任何成长。这就是P/PC不平衡的体现。<strong>如果能在做项目的过程中，通过学习总结持续提升自己的技术能力和软素质，并将其应用于项目实施交付中，相信一定会取得双赢的结果。</strong></p>
<h2 id="善于提问"><a href="#善于提问" class="headerlink" title="善于提问"></a>善于提问</h2><p><strong>“善于提问”，首先要勤于提问</strong>。<strong>只有在争辩中，才可能诞生最好的主意和最好的决定</strong>。</p>
<p><strong>“善于提问”，还要懂得如何提问</strong>。为什么同样是参加设计评审，有的同学就能提出很好的问题，而有的同学却提不出任何问题？除了知识储备、专业技能、经验等方面的差异外，还有一点很重要：批判性思维。</p>
<p>批判性思维主张通过批判性思考达到理性思维，即对事物本质的认知和掌握。关于如何进行批判性思维，大家可以参考一些经典的图书如《批判性思维》、《学会提问》等。在工作中面临一项决策时，会有各种各样的意见摆在你面前，所以我们必须要学会使用批判性思维来进行分析，每个人的论据是否可靠，论证是否合理，是否有隐含的立场。同样，在阅读一篇技术博客的时候，也要使用批判性的思维，多问几个为什么，作者得出的结论是否合理？论据是否充分？只有这样，才能不断地获取真正的知识。</p>
<h2 id="空杯心态"><a href="#空杯心态" class="headerlink" title="空杯心态"></a>空杯心态</h2><p><strong>保持“空杯心态”这一原则要求我们时刻进行自我检视与反省</strong>。</p>
<h2 id="工作中如何做好技术积累"><a href="#工作中如何做好技术积累" class="headerlink" title="工作中如何做好技术积累"></a>工作中如何做好技术积累</h2><p><a href="https://tech.meituan.com/2018/04/16/study-vs-work.html">https://tech.meituan.com/2018/04/16/study-vs-work.html</a></p>
<h1 id="如何晋升蚂蚁-P8"><a href="#如何晋升蚂蚁-P8" class="headerlink" title="如何晋升蚂蚁 P8"></a>如何晋升蚂蚁 P8</h1><h2 id="程序员四大原则"><a href="#程序员四大原则" class="headerlink" title="程序员四大原则"></a>程序员四大原则</h2><h3 id="加速原则"><a href="#加速原则" class="headerlink" title="加速原则"></a>加速原则</h3><p>能加快工作的一切事物。</p>
<p>快捷键，工具，能提升效率的工作和沟通模式。</p>
<p>研究原理和其他的插件之后，手撕热部署源码，并且在组内分享，节省了大量的测试部署时间的成本消耗。</p>
<h3 id="专注原则"><a href="#专注原则" class="headerlink" title="专注原则"></a>专注原则</h3><p>专注可以很大程度上提高工作效率。</p>
<p>隔离干扰，提前上班（专注于编码一小时，完成 60%的编码工作，正常工作时间用来做沟通和自我提升，复盘、总结、整理），避免能分散自己注意力的东西（手机、浏览器）</p>
<h3 id="自动化原则"><a href="#自动化原则" class="headerlink" title="自动化原则"></a>自动化原则</h3><p>把能自动化的一切都去人力去手工。</p>
<p>依然热部署</p>
<p>订阅</p>
<h3 id="规范性原则"><a href="#规范性原则" class="headerlink" title="规范性原则"></a>规范性原则</h3><p>规范很重要，减少不一致。降低理解和沟通的成本。</p>
<p>主动做一些输出，例如开发规范、技术分享、设计模式、领域驱动等。</p>
<h2 id="几项能力"><a href="#几项能力" class="headerlink" title="几项能力"></a>几项能力</h2><ul>
<li><p>承担责任，但不为团队背不该背的锅</p>
</li>
<li><p>任何事情首先从自己身上找原因，该认怂就认怂，问题尽量控制在一定范围内，避免扩大和升级</p>
</li>
<li><p>综合能力，技术、业务、项目管理都要懂</p>
</li>
<li><p>一叶知秋的洞察力</p>
</li>
<li><p>自省，善待质疑自己和与自己争论的人</p>
</li>
<li><p>带领团队一起提升，大家一起强了，其实才会轻松</p>
</li>
<li><p>同理心</p>
</li>
<li><p>情绪管理</p>
</li>
<li><p>文档能力</p>
</li>
</ul>
<p>文档是第一生产力，通俗易懂，结构化，简化/强化沟通。</p>
<ul>
<li>算法能力</li>
</ul>
<p>除了技术的提升，思维提升也是受益良多。</p>
<ul>
<li><p>解决问题的效率</p>
</li>
<li><p>表达能力</p>
</li>
</ul>
<p>表达能力决定了所做的技术的影响范围，决定了影响力，决定了威信，决定了价值。</p>
<p>基于格局、思维、技巧。</p>
<ul>
<li><p>优雅和美观的抽象能力</p>
</li>
<li><p>读书，总结</p>
</li>
<li><p>裸编程能力</p>
</li>
<li><p>掌握底层系统原理</p>
</li>
<li><p>追求代码世界的简约</p>
</li>
<li><p>保持谦逊，对一切充满敬畏</p>
</li>
</ul>
]]></content>
      <categories>
        <category>闲言碎语</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 项目の架构&amp;设计</title>
    <url>/articles/Fabric-Architecture-and-Design.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文着重介绍一些跟超级账本 Fabric 项目的架构和设计相关的知识。</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 的部署和使用</title>
    <url>/articles/Fabric-Deploying-and-Using.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Fabric 是超级账本项目 Hyperledger 下的第一个顶级项目。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 快速部署</title>
    <url>/articles/Fabric-Rapid-Deployment.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>以下环境搭建及配置均在 Mac 上完成。</p>
<p>Windows 系统本身不太适合做区块链开发，没有 Mac 的小朋友请安装 Linux 虚拟机做相关开发。</p>
<p>需要提到一点的是尽量给虚拟机分配多一点配置，毕竟需要多线程是吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger</tag>
        <tag>Fabric</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础（二）异常体系</title>
    <url>/articles/Java-Basics-Exception.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 异常体系和常见异常，一篇搞定！</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全部技术岗技能整理</title>
    <url>/articles/Hack-Security-Engineer-Skills.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近期可能会从应用系统开发部转岗至信息安全岗，所以大概了解了一下安全岗的职位描述以及职位要求，顺便整理了一下学习路线。</p>
<span id="more"></span>

<h1 id="安全人员基本技能"><a href="#安全人员基本技能" class="headerlink" title="安全人员基本技能"></a>安全人员基本技能</h1><p>关键字：时间，翻墙，同步，行业</p>
<h2 id="职位描述"><a href="#职位描述" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li><p>合理安排工作时间，完成上级交待的任务；</p>
</li>
<li><p>打造属于自己的开发与测试环境；</p>
</li>
<li><p>专属的网络上网环境；</p>
</li>
<li><p>开发工具与代码同步；</p>
</li>
<li><p>专业文档编写技巧；</p>
</li>
<li><p>能无障碍读懂专业英文资料；</p>
</li>
<li><p>关注行业态势和热点。</p>
</li>
</ul>
<h2 id="职位要求"><a href="#职位要求" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li><p>了解行业发展，目前大公司的产品和业务；</p>
</li>
<li><p>熟悉 GTD 时间管理方式；</p>
</li>
<li><p>能独立安装 Windows/Ubuntu 系统和虚拟机；</p>
</li>
<li><p>客户端与服务器通信过程；</p>
</li>
<li><p>浏览器插件与使用技巧（Firebug）；</p>
</li>
<li><p>突破网络限制，建立自己的私有网络（VPN，Wireshark）；</p>
</li>
<li><p>针对每种语言的开发工具（Sublime，Ulipad等），git 的使用技巧；</p>
</li>
<li><p>Office 编辑与格式注意（标题、封面、页眉、页码、字体等）；</p>
</li>
<li><p>英语水平良好，能阅读各种英文技术文档。</p>
</li>
</ul>
<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><h3 id="科学的工作环境"><a href="#科学的工作环境" class="headerlink" title="科学的工作环境"></a>科学的工作环境</h3><p>打造适合自己的工作环境，主要包含：电脑，操作系统，科学网络，常用工具，虚拟机。</p>
<ul>
<li>学习安装操作系统（Windows、Vmware/VirtualBox、Ubuntu/Kali），学习方法 Google/SecWiki 搜索；</li>
<li>学习自身安全意识：个人电脑安装杀毒软件、网站安全密码安全，可以参照这里，<a href="http://evilcos.me/yinsi.html">你得学几招保护自己</a>；</li>
<li>科学上网环境（goagent 现已整合为 XX-NET、shadowsocks、vpn），学习方法 Google/SecWiki 搜索；</li>
<li>提问的智慧，<a href="https://www.zhihu.com/question/20161362">Google 搜索技巧</a>；</li>
</ul>
<h3 id="文档编辑技巧"><a href="#文档编辑技巧" class="headerlink" title="文档编辑技巧"></a>文档编辑技巧</h3><p>Word 文档编写，PPT/Prize 基本操纵，Markdown 书写。</p>
<ul>
<li>培养感觉，多逛<a href="http://www.v2ex.com/">v2ex</a>，<a href="http://www.zhihu.com/">知乎</a>，<a href="http://stackoverflow.com/">stackoverflow</a>，<a href="https://twitter.com/">twitter</a>；</li>
<li>Office 和 Prize 视频教程，在<a href="http://study.163.com/">网易云课堂</a>和<a href="http://www.duobei.com/">多贝网</a>搜索；</li>
<li><a href="http://wowubuntu.com/markdown/">Markdown 语法说明</a>；</li>
<li><a href="http://www.sec-wiki.com/news/search?wd=Sublime">Sublime 相关技巧</a>；</li>
</ul>
<h3 id="浏览器插件与技巧"><a href="#浏览器插件与技巧" class="headerlink" title="浏览器插件与技巧"></a>浏览器插件与技巧</h3><p>高效与舒适的上网环境需要优秀的浏览器和众多插件支持。</p>
<ul>
<li>Chrome/Firefox 两者选其一，并研究其开发者工具的功能，参见<a href="http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html">Chrome 浏览器开发者工具</a>；</li>
<li>Chrome/Firefox 快捷键和代理设置；</li>
<li>插件的使用：Firebug、Hackbar、Tamper Data、Adblock、SwitchySharp；</li>
<li><a href="http://fex.baidu.com/blog/2014/05/what-happen/">从输入 URL 到页面加载完成的过程中都发生了什么事情</a>；</li>
<li><a href="http://www.qianxingzhem.com/post-1499.html">网页编码就是那点事</a>；</li>
</ul>
<h3 id="网络配置与分析"><a href="#网络配置与分析" class="headerlink" title="网络配置与分析"></a>网络配置与分析</h3><p>熟悉掌握各类网络环境配置，并知道遇到网络问题如何解决。</p>
<ul>
<li>Windows/Linux 环境下动态 IP 获取与静态 IP 配置，DNS 配置；</li>
<li>利用 wireshark 分析系统网络问题，参见<a href="https://community.emc.com/message/827199#827199">wireshark 实用技巧</a>；</li>
<li>路由器上网拨号，路由器无线安全配置；</li>
<li>浏览器网络问题分析，利用 Wireshark/Fiddler/Burp 工具进行分析；</li>
</ul>
<h3 id="个人时间管理"><a href="#个人时间管理" class="headerlink" title="个人时间管理"></a>个人时间管理</h3><p>如何更合理地安排时间和完成任务。</p>
<ul>
<li>了解时间管理的解决方法（GTD、番茄工作法、四象限等）；</li>
<li>阅读《小强升职记》书籍；</li>
<li>选择适合自己的时间管理软件（Doit.im、ticktick、番茄等）；</li>
</ul>
<h3 id="团队协作与个人博客"><a href="#团队协作与个人博客" class="headerlink" title="团队协作与个人博客"></a>团队协作与个人博客</h3><p>学会git实现团协作，并通过 Github 建立自己的博客。</p>
<ul>
<li>学习团队协作的重要性和 Git 的安装；</li>
<li>Git 相关教程：<a href="http://www.sec-wiki.com/news/4551">猴子都能懂的 GIT 入门</a>、<a href="http://www.sec-wiki.com/news/4574">Pro Git book V2</a>、<a href="http://www.sec-wiki.com/news/search?wd=Github">SecWiki-Git</a>；</li>
<li>了解 Github Pages 或者 Gitcafe Pages；</li>
<li>了解 Octopress 或者 hexo 的机制，并选择其中一个研究，具体方法可以 Google；</li>
<li>通过以上软件建立自己的博客，可以参考简明<a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/">Github Pages 与 Hexo 教程</a> ，<a href="http://leodots.com/2014/06/26/hexo_0/">hexo 搭建博客</a>。</li>
</ul>
<h1 id="Web-安全工程师"><a href="#Web-安全工程师" class="headerlink" title="Web 安全工程师"></a>Web 安全工程师</h1><p>关键字：渗透，攻防，编程，挖掘</p>
<h2 id="职位描述-1"><a href="#职位描述-1" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>对公司网站、业务系统进行安全评估测试（黑盒、白盒测试）；</li>
<li>对公司各类系统进行安全加固；</li>
<li>对公司安全事件进行响应，清理后门，根据日志分析攻击途径；</li>
<li>安全技术研究，包括安全防范技术，黑客技术等；</li>
<li>跟踪最新漏洞信息，进行业务产品的安全检查。</li>
</ul>
<h2 id="职位要求-1"><a href="#职位要求-1" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>熟悉主流的Web安全技术，包括 SQL 注入、XSS、CSRF、一句话木马等安全风险； </li>
<li>熟悉国内外主流安全产品和工具，如：Nessus、Nmap、AWVS、Burp、Appscan 等；</li>
<li>熟悉 Windows、Linux 平台渗透测试、后门分析、加固；</li>
<li>至少掌握一门编程语言 C/C++/Perl/Python/PHP/Go/Java 等；</li>
<li>熟悉渗透测试的步骤、方法、流程，具有 Web 安全实战经验；</li>
<li>熟悉常见安全攻防技术，对网络安全、系统安全、应用安全有深入的理解和自己的认识；</li>
<li>对 Web 安全整体有深刻理解，具备代码审计和独立漏洞挖掘能力；</li>
<li>具有较强的团队意识，高度的责任感，文档、方案能力优秀者优先。</li>
</ul>
<h2 id="学习路线-1"><a href="#学习路线-1" class="headerlink" title="学习路线"></a>学习路线</h2><h3 id="Web-安全相关概念"><a href="#Web-安全相关概念" class="headerlink" title="Web 安全相关概念"></a>Web 安全相关概念</h3><p>熟悉基本概念（SQL 注入、上传、XSS、CSRF、一句话木马等）。</p>
<ul>
<li>通过关键字（SQL 注入、上传、XSS、CSRF、一句话木马等）进行 Google/SecWiki；</li>
<li>阅读《精通脚本黑客》，虽然很旧也有错误，但是入门还是可以的；</li>
<li>看一些渗透笔记/视频，了解渗透实战的整个过程，可以 Google（渗透笔记、渗透过程、入侵过程等）；</li>
</ul>
<h3 id="熟悉渗透相关工具"><a href="#熟悉渗透相关工具" class="headerlink" title="熟悉渗透相关工具"></a>熟悉渗透相关工具</h3><p>熟悉 AWVS、sqlmap、Burp、nessus、chopper、nmap、Appscan 等相关工具的使用。</p>
<ul>
<li>了解该类工具的用途和使用场景，先用软件名字 Google/SecWiki；</li>
<li>下载无后门版的这些软件进行安装；</li>
<li>学习并进行使用，具体教材可以在<a href="http://www.sec-wiki.com/news/">SecWiki</a>上搜索，例如：<a href="http://www.sec-wiki.com/news/search?wd=burp">Brup的教程</a>、<a href="http://www.sec-wiki.com/news/search?wd=sqlmap">sqlmap</a>；</li>
<li>待常用的这几个软件都学会了可以安装<a href="http://www.3lsoft.com/">音速启动</a>做一个渗透工具箱；</li>
</ul>
<h3 id="渗透实战操作"><a href="#渗透实战操作" class="headerlink" title="渗透实战操作"></a>渗透实战操作</h3><p>掌握渗透的整个阶段并能够独立渗透小型站点。</p>
<ul>
<li>网上找渗透视频看并思考其中的思路和原理，关键字（渗透、SQL 注入视频、文件上传入侵、数据库备份、dedecms 漏洞利用等等）；</li>
<li>自己找站点/搭建测试环境进行测试，记住请隐藏好你自己；</li>
<li>思考渗透主要分为几个阶段，每个阶段需要做那些工作，例如这个：<a href="http://netsec.ccert.edu.cn/hacking/files/2011/07/PTES_MindMap_CN1.pdf">PTES渗透测试执行标准</a>；</li>
<li>研究 SQL 注入的种类、注入原理、手动注入技巧；</li>
<li>研究文件上传的原理，如何进行截断、双重后缀欺骗(IIS、PHP)、解析漏洞利用（IIS、Nignix、Apache）等，参照：<a href="http://www.owasp.org.cn/OWASP_Training/Upload_Attack_Framework.pdf">上传攻击框架</a>；</li>
<li>研究 XSS 形成的原理和种类，具体学习方法可以 Google/SecWiki，可以参考：<a href="http://www.sec-wiki.com/news/search?wd=XSS">XSS</a>；</li>
<li>研究 Windows/Linux 提权的方法和具体使用，可以参考：<a href="http://www.sec-wiki.com/news/search?wd=%E6%8F%90%E6%9D%83">提权</a>；</li>
<li>可以参考: <a href="http://www.sec-wiki.com/topic/17">开源渗透测试脆弱系统</a>；</li>
</ul>
<h3 id="关注安全圈动态"><a href="#关注安全圈动态" class="headerlink" title="关注安全圈动态"></a>关注安全圈动态</h3><p>关注安全圈的最新漏洞、安全事件与技术文章。</p>
<ul>
<li>通过 <a href="http://www.sec-wiki.com/">SecWiki</a> 浏览每日的安全技术文章/事件；</li>
<li>通过 Weibo/twitter 关注安全圈的从业人员（遇到大牛的关注或者好友果断关注），天天抽时间刷一下；</li>
<li>通过 feedly/鲜果订阅国内外安全技术博客（不要仅限于国内，平时多注意积累），没有订阅源的可以看一下<a href="http://www.sec-wiki.com/opml/index">SecWiki的聚合栏目</a>；</li>
<li>养成习惯，每天主动提交安全技术文章链接到 SecWiki 进行积淀；</li>
<li>多关注下最新漏洞列表，推荐几个：<a href="http://www.exploit-db.com/">exploit-db</a>、<a href="http://cve.scap.org.cn/">CVE中文库</a>、<a href="http://www.wooyun.org/">Wooyun</a>等，遇到公开的漏洞都去实践下。</li>
<li>关注国内国际上的安全会议的议题或者录像，推荐<a href="http://www.sec-wiki.com/news/index?tag=conference">SecWiki-Conference</a>。</li>
</ul>
<h3 id="熟悉Windows-Kali-Linux"><a href="#熟悉Windows-Kali-Linux" class="headerlink" title="熟悉Windows/Kali Linux"></a>熟悉Windows/Kali Linux</h3><p>学习 Windows/Kali Linux 基本命令、常用工具；</p>
<ul>
<li>熟悉 Windows 下的常用的 cmd 命令，例如：ipconfig,nslookup,tracert,net,tasklist,taskkill 等；</li>
<li>熟悉 Linux 下的常用命令，例如：ifconfig,ls,cp,mv,vi,wget,service,sudo等；</li>
<li>熟悉 Kali Linux 系统下的常用工具，可以参考<a href="http://www.sec-wiki.com/news/search?wd=Kali">SecWiki</a>,《Web Penetration Testing with Kali Linux》、《Hacking with Kali》等；</li>
<li>熟悉 metasploit 工具，可以参考<a href="http://www.sec-wiki.com/news/search?wd=Metasploit">SecWiki</a>、《Metasploit渗透测试指南》。</li>
</ul>
<h3 id="服务器安全配置"><a href="#服务器安全配置" class="headerlink" title="服务器安全配置"></a>服务器安全配置</h3><p>学习服务器环境配置，并能通过思考发现配置存在的安全问题。</p>
<ul>
<li>Windows2003/2008 环境下的 IIS 配置，特别注意配置安全和运行权限，可以参考：<a href="http://www.sec-wiki.com/news/search?wd=%E9%85%8D%E7%BD%AE">SecWiki-配置</a>；</li>
<li>Linux 环境下的 LAMP 的安全配置，主要考虑运行权限、跨目录、文件夹权限等，可以参考：<a href="http://www.sec-wiki.com/news/search?wd=%E9%85%8D%E7%BD%AE">SecWiki-配置</a>；</li>
<li>远程系统加固，限制用户名和口令登陆，通过 iptables 限制端口；</li>
<li>配置软件 Waf 加强系统安全，在服务器配置 mod_security 等系统，参见<a href="http://www.sec-wiki.com/news/search?wd=modsecurity">SecWiki-ModSecurity</a>；</li>
<li>通过 Nessus 软件对配置环境进行安全检测，发现未知安全威胁。</li>
</ul>
<h3 id="脚本编程学习"><a href="#脚本编程学习" class="headerlink" title="脚本编程学习"></a>脚本编程学习</h3><p>选择脚本语言 Perl/Python/PHP/Go/Java 中的一种，对常用库进行编程学习。</p>
<ul>
<li>搭建开发环境和选择 IDE，PHP 环境推荐<a href="http://www.wampserver.com/en/">Wamp</a>和<a href="https://www.apachefriends.org/index.html">XAMPP</a>，IDE 强烈推荐<a href="http://www.sublimetext.com/">Sublime</a>，一些 Sublime 的技巧：<a href="http://www.sec-wiki.com/news/search?wd=sublime">SecWiki-Sublime</a>；</li>
<li>Python 编程学习，学习内容包含：语法、正则、文件、网络、多线程等常用库，推荐《Python核心编程》，不要看完；</li>
<li>用 Python 编写漏洞的 exp，然后写一个简单的网络爬虫，可参见<a href="http://www.sec-wiki.com/news/search?wd=%E7%88%AC%E8%99%AB">SecWiki-爬虫</a>、<a href="http://www.icoolxue.com/album/show/113">视频</a>；</li>
<li>PHP 基本语法学习并书写一个简单的博客系统，参见《PHP 与 MySQL 程序设计（第4版）》、<a href="http://www.verycd.com/topics/2843130/">视频</a>；</li>
<li>熟悉 MVC 架构，并试着学习一个 PHP 框架或者 Python 框架（可选）；</li>
<li>了解 Bootstrap 的布局或者 CSS，可以参考：<a href="http://www.sec-wiki.com/news/search?wd=Bootstrap">SecWiki-Bootstrap</a>；</li>
</ul>
<h3 id="源码审计与漏洞分析"><a href="#源码审计与漏洞分析" class="headerlink" title="源码审计与漏洞分析"></a>源码审计与漏洞分析</h3><p>能独立分析脚本源码程序并发现安全问题。</p>
<ul>
<li>熟悉源码审计的动态和静态方法，并知道如何去分析程序，参见<a href="http://www.sec-wiki.com/news/search?wd=%E5%AE%A1%E8%AE%A1">SecWiki-审计</a>；</li>
<li>从 Wooyun 上寻找开源程序的漏洞进行分析并试着自己分析；</li>
<li>了解 Web 漏洞的形成原因，然后通过关键字进行查找分析，参见<a href="http://www.sec-wiki.com/news/search?wd=%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1">SecWiki-代码审计</a>、<a href="https://code.google.com/p/pasc2at/wiki/SimplifiedChinese">高级PHP应用程序漏洞审核技术</a>；</li>
<li>研究 Web 漏洞形成原理和如何从源码层面避免该类漏洞，并整理成checklist。</li>
</ul>
<h3 id="安全体系设计与开发"><a href="#安全体系设计与开发" class="headerlink" title="安全体系设计与开发"></a>安全体系设计与开发</h3><p>能建立自己的安全体系，并能提出一些安全建议或者系统架构。</p>
<ul>
<li>开发一些实用的安全小工具并开源，体现个人实力；</li>
<li>建立自己的安全体系，对公司安全有自己的一些认识和见解；</li>
<li>提出或者加入大型安全系统的架构或者开发；</li>
<li>看自己发展咯~</li>
</ul>
<h1 id="Web-安全研发工程师"><a href="#Web-安全研发工程师" class="headerlink" title="Web 安全研发工程师"></a>Web 安全研发工程师</h1><p>关键字：系统，开发，业务，调试</p>
<h2 id="职位描述-2"><a href="#职位描述-2" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>负责互联网运营平台、业务安全平台等系统的建设和开发工作；</li>
<li>对安全产品的易用性改进和Web研发技术优化；</li>
<li>根据公司安全的需要开发安全辅助工具或平台；</li>
<li>参与安全系统的需求分析、设计、编码等开发工作；</li>
<li>维护公司现有的安全程序与系统。</li>
</ul>
<h2 id="职位要求-2"><a href="#职位要求-2" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>能熟练应用一门或几门以下的技术：PHP/Python/Shell/JavaScript/Ajax，熟练把握 LNMP 开发；</li>
<li>熟悉MYSQL数据库开发、配置、维护、性能优化；</li>
<li>优秀的数据库设计和优化能力，至少精通一种数据库应用，MySQL、Redis、mongoDB 加分；</li>
<li>熟悉 Linux 下的开发，熟悉网络开发，具备一定的系统调优能力；</li>
<li>了解常见安全攻击和漏洞及系统化的防护方案；</li>
<li>必须拥有良好的职业道德，责任心，团队合作精神，代码风格；</li>
<li>大访问量网站建设或数据库建设经验优先。</li>
</ul>
<h1 id="安全运维工程师"><a href="#安全运维工程师" class="headerlink" title="安全运维工程师"></a>安全运维工程师</h1><p>关键字：应急，加固，培训，产品</p>
<h2 id="职位描述-3"><a href="#职位描述-3" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>服务器与网络基础设备的安全加固；</li>
<li>安全事件排查与分析，配合定期编写安全分析报告，专注业内安全事件； </li>
<li>跟踪最新漏洞信息，进行业务产品的安全检查； </li>
<li>负责信息安全策略/流程的制定,安全培训/宣传及推广；</li>
<li>负责Web漏洞和系统漏洞修复工作推进，跟踪解决情况，问题收集。</li>
</ul>
<h2 id="职位要求-3"><a href="#职位要求-3" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>熟悉主流的Web安全技术，包括 SQL 注入、XSS、CSRF 等 OWASP TOP 10 安全风险； </li>
<li>熟悉 Linux/Windows 下系统和软件的安全配置与加固；</li>
<li>熟悉常见的安全产品及原理，例如 IDS、IPS、防火墙等；</li>
<li>掌握常见系统、应用的日志分析方法；</li>
<li>熟练掌握 C/PHP/Perl/Python/Shell 等一或多种语言； </li>
<li>具有安全事件挖掘、调查取证经验； </li>
<li>网络基础扎实，熟悉 TCP/IP 协议，二层转发和三层路由的原理，动态路由协议，常用的应用层协议；</li>
<li>较好的文档撰写能力、语言表达和与沟通能力。</li>
</ul>
<h1 id="安全测试工程师"><a href="#安全测试工程师" class="headerlink" title="安全测试工程师"></a>安全测试工程师</h1><p>关键字：测试，培训，审计，文档</p>
<h2 id="职位描述-4"><a href="#职位描述-4" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>负责公司产品的安全测试、漏洞扫描等工作，保障产品安全质量；</li>
<li>负责安全测试技术积累，提升安全测试能力和效率；</li>
<li>跟踪和分析业界最新安全漏洞、发展趋势和解决方案，引入业界安全测试最佳实践； </li>
<li>负责设计系统的安全测试框架和测试流程，负责制定安全开发规范；</li>
<li>对研发人员、测试相关人员进行安全规范培训，提升规范的可实施性。</li>
</ul>
<h2 id="职位要求-4"><a href="#职位要求-4" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>熟悉常见安全攻防技术和安全漏洞，熟练使用常用渗透测试工具；</li>
<li>熟悉PC客户端软件、手机客户端（Android、iOS）软件的测试流程和方法；</li>
<li>熟悉常见的代码审计或白盒测试工具；</li>
<li>熟练使用 C/C++/PHP/Java/JavaScript/Python 一到两种；</li>
<li>具有良好的技术文档撰写能力，具有良好的沟通能力及协调能力；</li>
<li>良好的职业道德，责任心，团队合作精神。</li>
</ul>
<h1 id="Windows-逆向工程师"><a href="#Windows-逆向工程师" class="headerlink" title="Windows 逆向工程师"></a>Windows 逆向工程师</h1><p>关键字：漏洞，病毒，调试，挖掘</p>
<h2 id="职位描述-5"><a href="#职位描述-5" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>参与漏洞挖掘、分析和利用技术研究；</li>
<li>分析当月高危漏洞原理和利用技巧，撰写相关技术总结文档；</li>
<li>挖掘浏览器、Office、Adobe Reader、flash 等客户端软件以及网络协议常见漏洞；</li>
<li>研发相应的漏洞挖掘和分析的一体化框架平台；</li>
<li>恶意程序分析以及其他程序内部实现逻辑分析；</li>
<li>对公司其他部门提供技术支持。</li>
</ul>
<h2 id="职位要求-5"><a href="#职位要求-5" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>熟悉 x86/x64 系列汇编语言、C/C++ 语言，能熟练读懂汇编代码；</li>
<li>有较好的逆向功底，熟练使用 IDA、Windbg、Ollydbg、Immunity Debugger、Bindiff 等分析工具以及 Metasploit 等渗透测试工具；</li>
<li>至少掌握一门编程语言，包括 C/C++/python/ruby/perl/javascript；</li>
<li>熟悉浏览器、office、adobe 以及 flash 等软件内部工作原理以及相应软件漏洞分析与利用技术优先；</li>
<li>熟悉操作系统的相关安全机制，掌握绕过漏洞缓解措施的基本方法；</li>
<li>熟悉 Windows 系统安全，掌握 Windows 核心编程优先；</li>
<li>熟悉漏洞挖掘和分析相关技术、工具以及平台，如 Fuzzing 测试，补丁比较、符号执行技术等。</li>
<li>能够流畅的阅读漏洞方面的英文资料，具备较强的漏洞学习和理解能力；</li>
<li>熟悉技术文档的写作、PPT 制作、具备基本的工作汇报能力；</li>
<li>学习能力强、富有团队精神、有责任心和进取能力；</li>
</ul>
<h2 id="学习路线-2"><a href="#学习路线-2" class="headerlink" title="学习路线"></a>学习路线</h2><h3 id="漏洞相关概念"><a href="#漏洞相关概念" class="headerlink" title="漏洞相关概念"></a>漏洞相关概念</h3><p>熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode 编写）。</p>
<ul>
<li>通过关键字（栈溢出、堆溢出、整数溢出、<a href="https://www.sec-wiki.com/news/search?wd=UAF">UAF</a>、double-free、<a href="https://www.sec-wiki.com/news/search?wd=shellcode">shellcode</a>）进行Google/<a href="https://www.sec-wiki.com/">SecWiki</a>等了解基本概念；</li>
<li>阅读《Q版本缓冲区溢出》《0day漏洞挖掘》等<a href="https://www.sec-wiki.com/book/index/type/binvul">书籍</a>，学习二进制漏洞形成的基本原理和基本的利用方法，并进行实践操作；</li>
<li>学习<a href="https://www.sec-wiki.com/book/13">《加密与解密》</a>中部分章节，熟悉Windows系统的重要数据结构、函数传参方法以及PE文件结构等基础知识。</li>
</ul>
<h3 id="熟悉相关的工具和平台使用"><a href="#熟悉相关的工具和平台使用" class="headerlink" title="熟悉相关的工具和平台使用"></a>熟悉相关的工具和平台使用</h3><p>熟悉 IDA、WinDbg、Ollydbg、Immunity Debugger、Bindiff，Metasploit 等常见的漏洞分析调试和集成平台使用；</p>
<ul>
<li>了解这些工具的使用背景和用途，可以通过 Google/<a href="https://www.sec-wiki.com/">SecWiki</a> 等搜索了解。</li>
<li>下载安装相应的工具和搭建相应的平台。</li>
<li>学习这些工具的功能和基本使用方法，收集有用的工具插件（如<a href="https://www.sec-wiki.com/news/search?wd=mona">mona</a>、idapython）。教程可以通过 Google 或者 <a href="https://www.sec-wiki.com/">SecWiki</a> 上搜索。</li>
<li>学习常见工具的插件和脚步编写方法，如 <a href="https://www.sec-wiki.com/news/search?wd=Windbg">WinDbg</a> 插件编写、IDC 和 IDApython 脚步编写、od 脚本编写，具体可以 Google 相关教程。</li>
<li>熟悉<a href="https://www.sec-wiki.com/news/search?wd=Metasploit">Metasploit</a>渗透工具的使用，重点熟悉漏洞模块选择、查看、配置利用以及 shellcode 导出配置等功能，并利用 Metasploit 进行实践。具体教程可以Google：如 Metasploit 教程</li>
<li>待基本工具都熟悉后将相关工具做成一个工具箱。</li>
</ul>
<h3 id="漏洞样本分析"><a href="#漏洞样本分析" class="headerlink" title="漏洞样本分析"></a>漏洞样本分析</h3><p>掌握基本的漏洞原理和利用思路后开始分析分析各种类型的漏洞并撰写分析报告。</p>
<ul>
<li>通过搜索引擎各大漏洞披露平台(<a href="http://exploit-db/">exploit-db</a>、<a href="http://ww.cve.com/">CVE</a>、<a href="http://www.binvul.com/">binvul</a>等)搜集历年爆出来的比较经典的各种类型的二进制漏洞进行整理归类，并同时搜集相应的漏洞分析教程。</li>
<li>根据漏洞描述搭建相应的漏洞<a href="https://www.sec-wiki.com/news/search?wd=%E8%B0%83%E8%AF%95">调试</a>分析环境，利用 Metasploit 生成样本来进行漏洞重现，并根据漏洞分析报告自己<a href="https://www.sec-wiki.com/news/search?wd=%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90">调试分析</a>。</li>
<li>待调试分析完成并掌握了漏洞触发的原因和相应的利用方法后，认真总结，并撰写自己的调试分析报告。</li>
<li>根据 Metasploit 中生成样本的 ruby 源码和调试过程的分析，自己尝试编写漏洞 <a href="https://www.sec-wiki.com/news/search?wd=exp">poc</a> 并进行验证。</li>
<li>各个类型的漏洞分析 3 - 5 个，总结各种类型的漏洞的形成机理并及时进行归纳总结。</li>
</ul>
<h3 id="高级漏洞利用技术"><a href="#高级漏洞利用技术" class="headerlink" title="高级漏洞利用技术"></a>高级漏洞利用技术</h3><p>学习掌握现在的主流高级漏洞利用技术，了解操作系统以及编译器的各种漏洞利用缓解和保护措施以及相应的绕过方法。</p>
<ul>
<li>了解现在操作系统以及编译器的漏洞利用缓解和保护措施，如GS、DEP、ALSR、CFI等。</li>
<li>学习掌握针对这些缓解保护措施的基本方法，如SEH利用、堆喷射、<a href="https://www.sec-wiki.com/news/search?wd=ROP">ROP</a>导向编程等。</li>
<li>学习掌握一些针对特定应用程序的高级利用技术：如<a href="https://blog.fortinet.com/2014/06/16/advanced-exploit-techniques-attacking-the-ie-script-engine">IE脚步引擎高级利用技术</a>、<a href="https://www.greyhathacker.net/?p=770">office漏洞利用绕过ALSR</a>、<a href="https://www.greyhathacker.net/?p=911">office漏洞利用堆喷射</a>、<a href="https://sites.google.com/site/zerodayresearch/smashing_the_heap_with_vector_Li.pdf.">Flash高级漏洞利用技术</a>。</li>
<li>通过一些在线扫描网站平台如<a href="https://malwr.com/">malwr</a>、<a href="https://www.virustotal.com/">VirusTotal</a>、<a href="http://malware.dontneedcoffee.com/">widespread kits</a>等搜集一些在真实环境中使用的<a href="https://www.sec-wiki.com/topic/4">样本</a>（推荐通过阅读一些安全公司的分析报告并获取相关样本的MD5值然后搜索下载），分析这些在野外使用的样本中的各种高级漏洞利用技术并进行总结。</li>
<li>关注一些安全峰会的分享议题（如<a href="https://www.sec-wiki.com/news/search?wd=BlackHat">BlackHat</a>等），对其中涉及到漏洞利用的高级技术进行学习和研究。</li>
</ul>
<h3 id="漏洞挖掘平台使用"><a href="#漏洞挖掘平台使用" class="headerlink" title="漏洞挖掘平台使用"></a>漏洞挖掘平台使用</h3><p>掌握主流的漏洞挖掘方法Fuzz测试以及各个Fuzz测试平台的使用。</p>
<ul>
<li>熟悉<a href="https://www.sec-wiki.com/news/search?wd=Fuzz">Fuzz</a>测试的基本原理，了解主流的Fuzz测试平台，如Peach-fuzz，AFL等。</li>
<li>搭建<a href="https://www.sec-wiki.com/news/search?wd=Peach">Peach</a>-fuzz测试框架，熟悉Peach-fuzz的使用范围，熟悉Peach-Fuzz的各个模块的基本工作原理，掌握Peach-pit<a href="http://www.binvul.com/viewthread.php?tid=334">语法规则</a>。</li>
<li>阅读peach-pit的模板，以简单的文档格式为基础，参照编写相应的Peach-pit文件并对目标软件进行Fuzz测试。</li>
<li>了解AFL的基本工作原理，掌握<a href="https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/">AFL的基本使用方法</a>，下载安装Windows平台的<a href="https://github.com/ivanfratric/winafl">winafl</a>，熟悉其使用，并利用其对Windows平台下的非开源软件进行Fuzz测试。</li>
<li>在熟练使用以上Fuzz测试平台的基础上，阅读工具源码，对其工作原理进行更深层次的了解，并在此基础上根据自己需要开发定制化的工具。</li>
<li>熟悉掌握其他Fuzz测试框架或者平台。</li>
</ul>
<h3 id="关注安全动态、安全社区与安全会议"><a href="#关注安全动态、安全社区与安全会议" class="headerlink" title="关注安全动态、安全社区与安全会议"></a>关注安全动态、安全社区与安全会议</h3><p>关注相关的安全社区和安全大牛，掌握行业最新的安全资讯和安全发展动态。</p>
<ul>
<li>收集国内外与安全相关的站点并及时整理制作浏览器书签，每天定期抽时间查看，了解行业的最新动态和新时间。如<a href="https://www.sec-wiki.com/">SecWiki-安全维基</a>、<a href="http://http//www.freebuf.com/">Freebuf</a>、<a href="http://bbs.pediy.com/">看雪论坛</a>、<a href="http://www.binvul.com/">Binvul二进制安全</a>、<a href="http://www.52pojie.cn/">吾爱破解</a>;<br>收集整理常见的漏洞披露平台制作成浏览器书签，如<a href="http://exploit-db/">exploit-db</a>、<a href="http://ww.cve.com/">CVE</a>、<a href="http://protekresearchlab.com/">Protekresearchlab</a>，及时关注最新漏洞，对于感兴趣的或者重要的漏洞都去实际分析调试一下。</li>
<li>通过Weibo、微信等平台关注国内一些<a href="https://www.sec-wiki.com/opml/index/tag/binvul">安全大牛的博客</a>或者一些知名的安全公账号，及时了解安全达人的最新分享以及安全研究进展。</li>
<li>通过Twitter关注一些国外的安全界著名人士，，很多国外研究者都会定期在Twitter上发布其最新的研究成果，随时跟踪便可以了解国外的最新研究方向和研究现状。</li>
<li>关注一些重要的<a href="https://www.sec-wiki.com/news?tag=conference">安全峰会</a>，如<a href="https://www.sec-wiki.com/news/search?wd=BlackHat">BlackHat</a>、RSA等，收集相关感兴趣的议题，对其中相关的议题进行学习研究。</li>
</ul>
<h3 id="脚步编程和符号执行框架学习"><a href="#脚步编程和符号执行框架学习" class="headerlink" title="脚步编程和符号执行框架学习"></a>脚步编程和符号执行框架学习</h3><p>选择脚步语言Python、Perl、JavaScript中的一种，对语法进行熟悉，对常见库进行学习，推荐学习Python，Python库比较完善，可以大大提高工作效率。</p>
<ul>
<li>搭建相应的开发环境，根据自己的喜好选择相应的IDE，推荐<a href="https://www.sec-wiki.com/news/search?wd=Sublime">Sublime</a>等。</li>
<li>选择一本合适的教程学习Python基础语法，如<a href="https://www.sec-wiki.com/book/index/type/program">《Python核心编程》</a>。</li>
<li>Python的基本语法学习完后，可以针对性的学习一些Python应用于逆向工程的库，推荐学习《Python灰帽子》里面介绍了常见的用于逆向工程的Python库以及Python应用于immunity debugger和IDApython等方面的应用，利用这些库可以开发很多自动化的分析工具，节省分析时间。</li>
<li>学习一些动态插桩分析工具，如intel开发的<a href="https://software.intel.com/en-us/articles/pintool/">pin</a>,并利用pin插桩平台可以开发一些污点追踪分析的工具，同时可以在github上搜索与<a href="https://www.sec-wiki.com/news/search?wd=pin+">pin有关的项目</a>，加入并学习。</li>
<li>学习一些符号执行框架或者平台，符号执行在程序分析和漏洞挖掘上被认为是最有潜力的研究方向，符号执行已经有成熟的框架被用于程序程序分析、自动化漏洞挖掘与利用。推荐学习平台：<a href="http://s2e.epfl.ch/">s2e</a>、<a href="https://github.com/chyyuu/symexe/blob/master/klee_document/klee_analysis.md">klee</a>、<a href="https://github.com/angr/angr/">angr</a>。</li>
<li>搜集一些与符号执行相关的<a href="https://www.sec-wiki.com/news?tag=paper">学术论文</a>，进行学习。</li>
</ul>
<h3 id="漏洞自动化分析与挖掘安全工具的开发"><a href="#漏洞自动化分析与挖掘安全工具的开发" class="headerlink" title="漏洞自动化分析与挖掘安全工具的开发"></a>漏洞自动化分析与挖掘安全工具的开发</h3><p>随着人工智能的发展，安全领域的研究也将向着以机器代替人的方向发展，在今年举办的CGC挑战赛中，其主题”THE WORLD’S FIRST ALL-MACHINE HACKING TOURNAMENT”就体现了由机器来代替人进行网络攻防对抗的理念，开发自动化的工具也将是下一步进一步发展方向。</p>
<ul>
<li>在对各种漏洞类型成因有深入的研究和了解后，逐步对各个类型的漏洞建立相应的漏洞模型。</li>
<li>综合利用符号执行以及机器学习等方法，结合建立的漏洞模型，开发相应的自动化漏洞挖掘原型系统，在人工尽量参与少的情况下自动化进行漏洞挖掘。</li>
<li>深入分析漏洞触发的原因以及漏洞条件，结合符号执行的方法，建立一套针对漏洞自动化分析的平台，能够支持挖掘系统产出的异常样本进行可利用性评估以及利用生成等高级功能。</li>
<li>深入分析漏洞利用的过程以及利用技巧，建立相应的攻击检测模型，并开发相应的检测系统，能够针对各种类型的漏洞攻击进行检测并报警。</li>
</ul>
<h1 id="系统研发工程师"><a href="#系统研发工程师" class="headerlink" title="系统研发工程师"></a>系统研发工程师</h1><p>关键词：系统，底层，开发，优化</p>
<h2 id="职位描述-6"><a href="#职位描述-6" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>内部安全系统的相关架构设计与开发；</li>
<li>保障生产环境系统层的安全；</li>
<li>高性能服务系统开发与优化；</li>
<li>前沿安全问题研究。</li>
</ul>
<h2 id="职位要求-6"><a href="#职位要求-6" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>熟练掌握Linux/Unix或Windows平台的各种开发技能；</li>
<li>熟悉常用算法和数据结构，熟悉网络编程、多线程编程技术 ；</li>
<li>熟悉Linux下的开发，网络安全、Linux系统安全；</li>
<li>了解常见的应用层安全工具开发、了解APP安全；</li>
<li>具备一定的系统调优能力，具有良好的分析和解决问题能力 ；</li>
<li>善于学习和运用新知识， 对业界安全动态较为敏感；</li>
<li>具有良好的沟通表达能力和团队协作能力。</li>
</ul>
<h1 id="Android安全工程师"><a href="#Android安全工程师" class="headerlink" title="Android安全工程师"></a>Android安全工程师</h1><p>关键字：移动，测试，应急，研究</p>
<h2 id="职位描述-7"><a href="#职位描述-7" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>负责移动应用安全测试和安全事件应急响应；</li>
<li>负责移动应用安全平台建设；</li>
<li>负责信息安全策略/流程的制定，安全培训/宣传及推广；</li>
<li>跟踪最新漏洞信息，进行业务产品的安全检查。</li>
</ul>
<h2 id="职位要求-7"><a href="#职位要求-7" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>熟悉Android开发环境，能够较为熟练的开发Android程序；</li>
<li>了解ARM、Smali汇编语言；</li>
<li>熟悉IDA、Gdb等调试分析工具；</li>
<li>有Android漏洞挖掘、漏洞利用经验优先；</li>
<li>最好熟悉Android/Linux底层框架，熟悉系统的工作原理和细节；</li>
<li>最好能够深入研究Android系统底层，分析漏洞和潜在风险；</li>
<li>最好能够跟踪国内外的Android安全动态，分享Android安全的最新技术。</li>
</ul>
<h2 id="学习路线-3"><a href="#学习路线-3" class="headerlink" title="学习路线"></a>学习路线</h2><h3 id="Android基础知识"><a href="#Android基础知识" class="headerlink" title="Android基础知识"></a>Android基础知识</h3><p>学习Android开发编程，了解其原理。</p>
<ul>
<li>熟悉Java,C和C++三种在Android系统中使用较多的语言，了解几种语言的特性。</li>
<li>学习<a href="https://www.sec-wiki.com/news/search?wd=Android%E5%BC%80%E5%8F%91">Android开发</a>，推荐使用Android studio进行开发，也可以使用eclipse。完成一些小程序，学习Native开发，利用NDK完成一些native程序。在过程中了解Android系统的层次结构，四大组件等Android系统的基本知识。尽可能的了解Andorid系统的概貌。 </li>
<li>在基础学习的过程中学习有效的使用<a href="https://www.google.com/search?q=%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7&ie=UTF-8">搜索引擎</a>，对不熟悉的属于进行了解学习。</li>
</ul>
<h3 id="逆向基础知识"><a href="#逆向基础知识" class="headerlink" title="逆向基础知识"></a>逆向基础知识</h3><p>学习逆向基础相关知识和工具、并试图动手实践。</p>
<ul>
<li>熟悉<a href="https://www.sec-wiki.com/news/search?wd=Android%E9%80%86%E5%90%91">Android逆向</a>工具的使用，如<a href="https://github.com/pxb1988/dex2jar">dex2jar</a>，<a href="http://www.droidsec.cn/android-%E5%8F%8D%E7%BC%96%E7%BB%8E%E5%B7%A5%E5%85%B7jeb%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%B8%8B%E8%BD%BD/">JEB</a>，<a href="http://www.pd521.com/thread-136-1-1.html">AndroidKiller</a>，<a href="https://github.com/androguard/androguard">Androguard</a>等，SecWiki上收录的<a href="https://www.sec-wiki.com/news?tag=mobile">移动安全工具</a>也很多，并且有很多开源，尝试自己搜索并使用自己喜欢的。</li>
<li>大致学习APK中包含的各文件格式，最好的方式是阅读Android系统解析APK的源码。也可以利用开源项目Androguard来学习。推荐<a href="https://www.sec-wiki.com/book/index/type/mobile">《Android软件安全与逆向分析》</a></li>
<li>学习和熟悉<a href="https://www.sec-wiki.com/news/search?wd=smali">smali</a>语言。</li>
<li>尝试自己写小程序，并利用工具<a href="https://www.sec-wiki.com/news/search?wd=%E9%80%86%E5%90%91&tag=mobile">逆向</a>，对比学习。</li>
<li>尝试逆向一些小程序，分析其功能逻辑。</li>
</ul>
<h3 id="逆向进阶学习"><a href="#逆向进阶学习" class="headerlink" title="逆向进阶学习"></a>逆向进阶学习</h3><ul>
<li>对ARM汇编、Smali语法、相关调试工具等进行学习。</li>
<li>学习和熟悉<a href="https://www.sec-wiki.com/news/search?wd=ARM">ARM</a>汇编指令；</li>
<li>学习学习并熟悉<a href="https://www.sec-wiki.com/news/search?wd=IDA">IDA</a>，<a href="https://www.sec-wiki.com/news/search?wd=gdb">gdb</a>两种逆向工具的使用； </li>
<li>学习Smali调试的方法，参考书籍<a href="https://www.sec-wiki.com/book">《Android软件安全与逆向分析》</a>；</li>
<li>学习使用IDA静态分析<a href="https://www.sec-wiki.com/news/search?wd=Native">Native</a>程序，自己写Native程序并<a href="https://www.sec-wiki.com/news/search?tag=mobile&kw=Android">逆向</a>，对比学习；</li>
<li>使用IDA和gdb对Native程序进行<a href="https://www.sec-wiki.com/news/search?wd=%E8%B0%83%E8%AF%95">调试</a>；</li>
<li>分析和调试一些带有Native代码的APK；</li>
<li>开始学习Android系统知识，推荐<a href="https://www.sec-wiki.com/book/40">《Android系统源代码情景分析》</a>；</li>
</ul>
<h3 id="逆向实战"><a href="#逆向实战" class="headerlink" title="逆向实战"></a>逆向实战</h3><p>病毒分析语脱壳学习</p>
<ul>
<li>找一些<a href="https://www.sec-wiki.com/news/search?wd=%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90">病毒</a>木马<a href="https://www.sec-wiki.com/opml/index/tag/mobile">分析博客</a>跟着博客内容的<a href="https://www.sec-wiki.com/news/6504">教程</a>进行分析实践推荐用<a href="https://www.sec-wiki.com/news/search?wd=Ransomware">Ransomware</a>类和木马类进行学习</li>
<li>找一些分析加壳程序的分析<a href="https://www.google.com/search?q=android+%E8%84%B1%E5%A3%B3&ie=UTF-8">文章</a>进行手动<a href="https://www.sec-wiki.com/news/search?wd=%E8%84%B1%E5%A3%B3">脱壳</a></li>
</ul>
<h3 id="漏洞分析与挖掘"><a href="#漏洞分析与挖掘" class="headerlink" title="漏洞分析与挖掘"></a>漏洞分析与挖掘</h3><p>学习漏洞类型和原理。</p>
<ul>
<li>学习常见的漏洞类型，例如<a href="https://www.sec-wiki.com/news/search?wd=%E5%A0%86%E6%BA%A2%E5%87%BA">堆溢出</a>，<a href="https://www.sec-wiki.com/news/search?wd=%E6%A0%88%E6%BA%A2%E5%87%BA">栈溢出</a>，<a href="https://www.sec-wiki.com/news/search?wd=UAF">UAF</a>等，可以参考<a href="https://www.sec-wiki.com/book/index/type/binvul">SecWiki漏洞分析相关书籍</a>；</li>
<li>关注<a href="http://android.scap.org.cn/index.html">android security bulletin</a>，根据提供的<a href="https://www.sec-wiki.com/news/search?wd=diff">diff</a>分析漏洞成因；</li>
<li>学习并调试以前的<a href="https://www.sec-wiki.com/news/search?wd=Android%E6%BC%8F%E6%B4%9E">经典漏洞</a>和<a href="http://www.droidsec.cn/category/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/">分析文章</a>；</li>
<li>学习漏洞挖掘fuzzing思路，参考书籍<a href="https://www.sec-wiki.com/book/25">《Android安全攻防权威指南》</a>；</li>
</ul>
<h1 id="风控安全工程师"><a href="#风控安全工程师" class="headerlink" title="风控安全工程师"></a>风控安全工程师</h1><p>关键字：风控，检测，防御，开发</p>
<h2 id="职位描述-8"><a href="#职位描述-8" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>负责安全检测分析以及防御系统的研发；</li>
<li>负责大数据分析、分布式计算平台研发；</li>
<li>理解产品作弊生态，规划产品反作弊发展方向，并将方向拆解为可执行的项目；</li>
<li>较强的数据分析能力，将数据规律抽象成机器可实现的策略，为解决问题把握方向。</li>
</ul>
<h2 id="职位要求-8"><a href="#职位要求-8" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>熟悉Python/Java/PHP中的一种开发语言；</li>
<li>熟悉 Linux 系统以及 服务器端开发经验；</li>
<li>熟悉分布式系统部署与开发；</li>
<li>对数据有亲切感，主动性强，细心，思维敏捷；</li>
<li>有安全相关系统研发经验者优先；</li>
<li>有很强的逻辑分析能力，对发现和思考问题充满乐趣；</li>
<li>有反作弊、安全、数据分析专业领域经验优先。</li>
</ul>
<h1 id="安全产品运营员"><a href="#安全产品运营员" class="headerlink" title="安全产品运营员"></a>安全产品运营员</h1><p>关键字：产品，宣传，统计，优化</p>
<h2 id="职位描述-9"><a href="#职位描述-9" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>负责安全类产品运营、帐号安全保障、用户体验优化；</li>
<li>负责建立并通过有效的运营，持续优化各项安全指标以及用户增长；</li>
<li>负责用户安全教育，跟进解决用户的各类问题；</li>
<li>负责产品数据的分析，进行上线后的及时优化；</li>
<li>对产品整个生命周期策略，针对用户需求变化，制定产品运营战略和计划。</li>
</ul>
<h2 id="职位要求-9"><a href="#职位要求-9" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>有安全类产品设计或运营经验者优先；</li>
<li>对网络安全相关知识有一定了解；</li>
<li>能够对各项有效资源进行整合，善于协调跨部门合作，优秀的沟通技巧；</li>
<li>对数据敏感，善于数据统计分析，逻辑清晰；</li>
<li>高度的责任心和合作精神，良好的文字表达能力；</li>
<li>工作积极、善于学习、细致耐心、勇于接受挑战。</li>
</ul>
<h1 id="安全服务工程师（乙方）"><a href="#安全服务工程师（乙方）" class="headerlink" title="安全服务工程师（乙方）"></a>安全服务工程师（乙方）</h1><p>关键字：实施，渗透，审计，规范</p>
<h2 id="职位描述-10"><a href="#职位描述-10" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>负责安全服务项目中的实施部分，包括：漏洞扫描、渗透测试、安全基线检查、代码审计、应急响应等；</li>
<li>爆发高危漏洞后时行漏洞的分析应急；</li>
<li>对公司安全产品的后端支持；</li>
<li>掌握专业文档编写技巧；</li>
<li>关注行业态势和热点。</li>
</ul>
<h2 id="职位要求-10"><a href="#职位要求-10" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>有较强学习能力，能快速学习新的技术；</li>
<li>熟悉风险评估、应急响应、渗透测试、安全加固等安全服务；</li>
<li>熟悉常见黑客攻防方法；</li>
<li>掌握一门编程语言；</li>
<li>具有良好的语言表达能力、文档组织能力。</li>
</ul>
<h2 id="学习路线-4"><a href="#学习路线-4" class="headerlink" title="学习路线"></a>学习路线</h2><h3 id="安全概念和资讯"><a href="#安全概念和资讯" class="headerlink" title="安全概念和资讯"></a>安全概念和资讯</h3><p>前期安全知识的补充学习。</p>
<ul>
<li>熟悉基本的安全术语和概念（SQL注入、上传漏洞、XSS、CSRF、一句话木马、渗透测试、应急响应、风险评估、等级保护等）；</li>
<li>阅读OWASP TOP 10 从漏洞分类和漏洞成因寻找安全漏洞的切入点 <a href="https://www.owasp.org/index.php/Top_10_2013-Top_10">Link</a> ；</li>
<li>阅读经典的网络安全相关书籍 <a href="http://book.douban.com/doulist/894936/">Link</a> ；</li>
<li>安全资讯来源：Secwiki、Reddit、Twitter、Weibo、Wooyun、Freebuf、91ri等。</li>
</ul>
<h3 id="安全工具使用"><a href="#安全工具使用" class="headerlink" title="安全工具使用"></a>安全工具使用</h3><p>熟悉常用的安全测试工具和自家的产品。</p>
<ul>
<li>综合漏洞扫描工具的安装使用：Nessus、X-scan、Nexpose等；</li>
<li>Web漏洞扫描的工具的安装使用和漏洞验证：AppScan、AWVS、WebInspect等；</li>
<li>辅助工具的安装和使用：Nmap、Burp Suite、Sqlmap、wireshark、iptables等；</li>
<li>辅助脚本的收集和修改：各种漏洞利用的Exploit、定制化高的扫描脚本、字典等；</li>
<li>自家安全设备策略部署和使用。</li>
</ul>
<h3 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h3><p>熟悉渗透测试报告的格式和内容。</p>
<ul>
<li>渗透测试流程：《渗透测试授权书》规定渗透时间和范围、《渗透测试免责书》描述渗透测试可能带来的危害、规定时间实施渗透测试，输出《渗透测试报告》，指导甲方进行漏洞修复；</li>
<li>大多数情况下，渗透测试质量中技术能力占40%，报告书写占60%，必须熟练掌握各种word、exel基本功能；</li>
<li>具体的技术细节、工具使用可参考老美的PTES渗透测试指南 <a href="http://www.pentest-standard.org/index.php/PTES_Technical_Guidelines">Link</a>。</li>
</ul>
<h3 id="安全基线检查"><a href="#安全基线检查" class="headerlink" title="安全基线检查"></a>安全基线检查</h3><p>学习安全业务与系统操作。</p>
<ul>
<li>不同的客户，不同的业务系统，有不同的安全基线文档，大致分类无外乎几种：从账户、授权、补丁、日志、冗余端口和服务等层面对主机系统、中间件和数据库进行配置[检查]；</li>
<li>阅读外网流出的各家厂商的安全基线检查内容，如：运营商-移动 <a href="http://wenku.baidu.com/search?word=%EF%BF%BD%EF%BF%BD%C8%AB%EF%BF%BD%EF%BF%BD%EF%BF%BD%C3%BB%EF%BF%BD%EF%BF%BD%EF%BF%BD">Link</a> ；</li>
<li>掌握不同版本的配置方法和配置项，可自行安装系统、中间件、数据库进行实操。</li>
</ul>
<h3 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h3><p>学习渗透实战，并了解应急响应流程。</p>
<ul>
<li>应急响应流程可分为两类：实时性应急响应和入侵后应急响应；</li>
<li>实时性应急响应：大多为DDOS攻击，首要进行流量分析，若流量打满，能做的就是反查攻击IP，逆向渗透；若网络设备会话数被打满或者主机系统的CPU、内存、会话数被打满，可通过交换机做端口镜像，使用wireshark、tcpdump进行抓包，分析流量特征，确认攻击类型，在网络设备或安全设备上做相应阻断策略；</li>
<li>攻击后应急响应：通过分析恶意文件和日志，查找入侵来源IP和入侵者所利用的漏洞，提出漏洞修补方案，并逆向追踪入侵者；</li>
<li>应急响应对工程师的要求较为复杂，需多熟悉不同操作系统、应用、中间件、数据库特性，且能熟练使用编程语言或者vim等编辑器对较大的日志进行数据整理，还需要日常多多积累各种攻击特征和防护策略；</li>
<li>多阅读网上已有的应急响应的文档，学习逆向分析思路。</li>
</ul>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>学习代码审计流程和实战。</p>
<ul>
<li>熟悉代码审计工具的安装使用，可参考SecWiki上的文章 <a href="http://www.sec-wiki.com/topic/41">Link</a> ；</li>
<li>根据工具报告验证问题是否为误报，并跟踪分析；</li>
<li>参看各大资讯平台、论坛、旧杂志的文章，学习白盒分析思路；</li>
<li>Exploit编写。</li>
</ul>
<h3 id="安全边界建设"><a href="#安全边界建设" class="headerlink" title="安全边界建设"></a>安全边界建设</h3><p>学习安全边界检查工作的流程和内容。</p>
<ul>
<li>安全边界检查的工作重点可总结为：根据是各个信息区域否需要外网接入、是否需要访问内部核心网络等行为特点，将信息安全系统划分为边界接入域、网络基础设施域、计算机安全域、运维管理域，并对现有网络是否有按照该标准做相应的安全域划分，或判断其划分是否合理；</li>
<li>可参考规范：IATF <a href="http://www.doc88.com/p-662169539878.html">Link</a>。</li>
</ul>
<h3 id="安全规范"><a href="#安全规范" class="headerlink" title="安全规范"></a>安全规范</h3><p>学习国标和行业规范。</p>
<ul>
<li>除去技术细节了，尚有不少风险评估和等级保护测评的工作，直接读规范有助对项目全局的把控；<ul>
<li>国标规范有： <ul>
<li><a href="http://wenku.baidu.com/link?url=ct9Kp8hScDuL5RgReMmyzbbupQXkB3JJnap-zaKxWRqkpZYcitqPn_mYlxjcXtTiVW-HLpxGi2F_zX3P6kdM57Ho3YA5fcLwsXOOVQBPj5i">《信息系统安全等级保护基本要求》</a>；</li>
<li><a href="http://www.doc88.com/p-518675849182.html">《信息安全风险评估规范》</a>；</li>
</ul>
</li>
<li>行业规范有： <ul>
<li><a href="http://down.51cto.com/data/690206">《网银121号文》</a> ；</li>
<li><a href="http://dl.vmall.com/c05pwufa0x">《中国银联移动支付技术规范》</a>等等；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="技术支持工程师（乙方）"><a href="#技术支持工程师（乙方）" class="headerlink" title="技术支持工程师（乙方）"></a>技术支持工程师（乙方）</h1><p>关键字：售前，招标，培训，应急</p>
<h2 id="职位描述-11"><a href="#职位描述-11" class="headerlink" title="职位描述"></a>职位描述</h2><ul>
<li>负责客户的售前技术支持工作，包括分析挖掘客户需求，针对客户网络架构，设计合理的网络安全解决方案，设计完成产品演示与交流。</li>
<li>配合销售人员，独立完成整个招投标过程。</li>
<li>完成公司各类产品实施，部署上线。</li>
<li>完成用户培训，完成项目售后维护，为客户提供必要的应急响应。</li>
</ul>
<h2 id="职位要求-11"><a href="#职位要求-11" class="headerlink" title="职位要求"></a>职位要求</h2><ul>
<li>精通TCP/IP协议，熟悉网络交换原理和各类路由协议，可熟练调试路由交换设备。</li>
<li>熟悉常见操作系统和数据库。</li>
<li>熟悉公司各类安全产品特性与配置，完成产品部署上线。</li>
<li>熟悉集成类项目管理，稳步推进项目开展。</li>
<li>熟悉招投标流程，可独立完成标书制作与产品演示。</li>
<li>良好的沟通能力。</li>
</ul>
<h2 id="学习路线-5"><a href="#学习路线-5" class="headerlink" title="学习路线"></a>学习路线</h2><h3 id="学习基本安全攻防概念"><a href="#学习基本安全攻防概念" class="headerlink" title="学习基本安全攻防概念"></a>学习基本安全攻防概念</h3><p>熟悉Web安全漏洞和网络攻击漏洞的方法。</p>
<ul>
<li>以OWASP TOP 10入手，了解Web安全漏洞成因与攻击方法（SQL注入、XSS、CSRF、Web2.0安全等），参考书籍：<a href="https://www.owasp.org/index.php/Top_10_2013-Top_10">OWASP2013 Top 10 List</a>，<a href="http://book.douban.com/subject/10546925/">白帽子讲Web安全</a>、<a href="http://book.douban.com/subject/20451827/">Web前端黑客技术揭秘</a>；</li>
<li>熟悉网络攻击漏洞成因与攻击方法（DDoS、缓冲区溢出、社会工程学等），参考书籍：<a href="http://book.douban.com/subject/3035185/">0day安全：软件漏洞分析技术</a>、<a href="http://book.douban.com/subject/25870994/">破坏之王：DDoS攻击与防范深度剖析</a>、<a href="http://book.douban.com/subject/21340013/">黑客社会工程学攻击</a>；</li>
<li>安全资讯来源：Secwiki、Reddit、Twitter、Weibo、Wooyun、Freebuf、91ri等。</li>
</ul>
<h3 id="掌握网络协议与路由交换"><a href="#掌握网络协议与路由交换" class="headerlink" title="掌握网络协议与路由交换"></a>掌握网络协议与路由交换</h3><p>熟悉网络相关技术知识，能动手解决实际问题。</p>
<ul>
<li>学习TCP/IP协议，参考书籍：<a href="http://book.douban.com/subject/1088054/">TCP/IP详解 卷1：协议</a>；</li>
<li>学习路由交换知识，参考CCNA、CCNP教材熟悉常见路由器、交换机配置方法与操作，参考书籍：<a href="http://book.douban.com/subject/2968802/">CCNA学习指南</a>、<a href="http://book.douban.com/subject/2208574/">CCNP BCMSN认证考试指南</a>；</li>
</ul>
<h3 id="安全工具使用-1"><a href="#安全工具使用-1" class="headerlink" title="安全工具使用"></a>安全工具使用</h3><p>熟悉相关安全工具的使用，在不同场景知道用什么工具。</p>
<ul>
<li>网络扫描工具的安装使用：X-Scan、SuperScan、Nmap等，通过SecWiki/Google进行关键字搜索；</li>
<li>Web漏洞扫描的工具的安装使用和漏洞验证：AppScan、AWVS、WebInspect、Netsparker、sqlmap、Burp Suite等，通过SecWiki/Google进行关键字搜索；</li>
<li>其他工具安装使用：Metasploit、Tcpdump、wireshark等，通过SecWiki/Google进行关键字搜索；</li>
</ul>
<h3 id="本公司产品配置与管理"><a href="#本公司产品配置与管理" class="headerlink" title="本公司产品配置与管理"></a>本公司产品配置与管理</h3><p>熟悉公司内部产品和竞争对手的相关产品。</p>
<ul>
<li>学习公司全产品线的各类安全产品配置与管理技巧：防火墙、IDS、IPS、漏洞扫描、SOC、VPN等，可参考公司内部手册；</li>
<li>了解下国内外其它公司的同类产品，参考：<a href="http://www.sec-wiki.com/news/3202">2014年最新国内外信息安全厂家及安全产品分类</a>；</li>
</ul>
<h3 id="安全规范与安全标准"><a href="#安全规范与安全标准" class="headerlink" title="安全规范与安全标准"></a>安全规范与安全标准</h3><p>学习国标和行业规范。</p>
<ul>
<li>国内标准：信息系统安全等级保护基本要求，参考：<a href="http://wenku.baidu.com/view/53e0672f647d27284b735175.html">信息安全-信息系统安全等级保护基本要求</a>，分级保护BMB系列标准（因标准本身涉密，可参考网上各类分析资料）；</li>
<li>国际标准：<a href="http://wenku.baidu.com/view/fbd3bf8aa58da0116d174949.html">ISO 27001信息安全管理体系要求</a>，<a href="http://book.douban.com/subject/3351983/">信息安全管理体系应用手册</a>，<a href="http://wenku.baidu.com/view/9cd85477aaea998fcc220e5c.html">ISO 27002 信息安全控制实用规则</a>。</li>
</ul>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>黑客</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础（一）Java 关键字</title>
    <url>/articles/Java-Basics-Keywords.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 关键字一篇搞定！</p>
<p><img src="Java-Basics-Keywords/v2-8408d6adff55ca7f1772f666afae9425_r.jpg" alt="preview"></p>
<span id="more"></span>

<h1 id="Java-关键字字典"><a href="#Java-关键字字典" class="headerlink" title="Java 关键字字典"></a>Java 关键字字典</h1><table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
<th>使用方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>abstract</strong></td>
<td>表明类或者成员方法具有抽象属性</td>
<td></td>
</tr>
<tr>
<td>assert</td>
<td>断言</td>
<td>用来进行程序调试</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型之一，布尔类型</td>
<td></td>
</tr>
<tr>
<td>break</td>
<td>提前跳出一个块</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>基本数据类型之一，字节类型</td>
<td></td>
</tr>
<tr>
<td>case</td>
<td></td>
<td>用在 switch 语句中，表示其中一个分支</td>
</tr>
<tr>
<td>catch</td>
<td></td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型之一，字符类型</td>
<td></td>
</tr>
<tr>
<td>class</td>
<td>类</td>
<td></td>
</tr>
<tr>
<td>const</td>
<td>保留关键字，没有具体含义</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td></td>
<td>回到一个块的开始处</td>
</tr>
<tr>
<td>default</td>
<td>默认</td>
<td>例如，用在 switch 语句中，表明一个默认的分支</td>
</tr>
<tr>
<td>do</td>
<td></td>
<td>用在 do-while 循环结构中</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型之一，双精度浮点数类型</td>
<td></td>
</tr>
<tr>
<td>else</td>
<td></td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>enum</td>
<td>枚举</td>
<td></td>
</tr>
<tr>
<td>extends</td>
<td>表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</td>
<td></td>
</tr>
<tr>
<td><strong>final</strong></td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td>
<td></td>
</tr>
<tr>
<td>finally</td>
<td></td>
<td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型之一，单精度浮点数类型</td>
<td></td>
</tr>
<tr>
<td>for</td>
<td></td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>goto</td>
<td></td>
<td>保留关键字，没有具体含义</td>
</tr>
<tr>
<td>if</td>
<td></td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>implements</td>
<td>表明一个类实现了给定的接口</td>
<td></td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
<td></td>
</tr>
<tr>
<td>instanceof</td>
<td></td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型之一，整数类型</td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型之一，长整数类型</td>
<td></td>
</tr>
<tr>
<td>native</td>
<td></td>
<td>用来声明一个方法是由与计算机相关的语言（如 C/C++/FORTRAN 语言）实现的</td>
</tr>
<tr>
<td>new</td>
<td></td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>一种访问控制方式：私用模式</td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：共用模式</td>
<td></td>
</tr>
<tr>
<td>return</td>
<td></td>
<td>从成员方法中返回数据</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型之一，短整数类型</td>
<td></td>
</tr>
<tr>
<td><strong>static</strong></td>
<td>表明具有静态属性</td>
<td></td>
</tr>
<tr>
<td>strictfp</td>
<td></td>
<td>用来声明 FP_strict（单精度或双精度浮点数）表达式遵循 IEEE 754 算术规范</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
<td></td>
</tr>
<tr>
<td>switch</td>
<td></td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td><strong>synchronized</strong></td>
<td></td>
<td>表明一段代码需要同步执行</td>
</tr>
<tr>
<td>this</td>
<td></td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>throw</td>
<td></td>
<td>抛出一个异常</td>
</tr>
<tr>
<td>throws</td>
<td></td>
<td>声明在当前定义的成员方法中所有需要抛出的异常</td>
</tr>
<tr>
<td>transient</td>
<td></td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>try</td>
<td></td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>void</td>
<td></td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td><strong>volatile</strong></td>
<td></td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>while</td>
<td></td>
<td>用在循环结构中</td>
</tr>
</tbody></table>
<h1 id="重点-Java-关键字详细介绍"><a href="#重点-Java-关键字详细介绍" class="headerlink" title="重点 Java 关键字详细介绍"></a>重点 Java 关键字详细介绍</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="final-关键字在-Java-中有什么作用？"><a href="#final-关键字在-Java-中有什么作用？" class="headerlink" title="final 关键字在 Java 中有什么作用？"></a>final 关键字在 Java 中有什么作用？</h3><p>final 可用于修饰类、类属性和类方法。</p>
<p>特征：凡是引用 final 关键字的地方皆不可修改！</p>
<ul>
<li>修饰类：表示该类不能被继承。</li>
<li>修饰变量：表示变量只能一次赋值之后值不能被修改（常量）。</li>
<li>修饰方法：表示方法不能被重写。</li>
</ul>
<h3 id="final-有哪些用法？"><a href="#final-有哪些用法？" class="headerlink" title="final 有哪些用法？"></a>final 有哪些用法？</h3><p>这个问题很多面试官都喜欢问，虽然无聊但确实能让人懵逼一下。</p>
<ul>
<li>被 final 修饰的类不能被继承。</li>
<li>被 final修饰的常量，在编译阶段会存入常量池内。</li>
<li>被 final 修饰的变量不能被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变。</li>
<li>被 final 修饰的方法不能被重写。</li>
<li>被 final 修饰的方法，JVM 会尝试将其内联，以提高运行效率。</li>
</ul>
<p>除此之外，编译器对 final 域要遵守的两个重排序规则更好：</p>
<ul>
<li><p>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
</li>
<li><p>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</p>
</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="static-有哪些用法？"><a href="#static-有哪些用法？" class="headerlink" title="static 有哪些用法？"></a>static 有哪些用法？</h3><p>大家都知道 static 关键字两个基本的用法：静态变量和静态方法。也就是说，被 static 所修饰的变量/方法都属于类的静态资源，类实例所共享。</p>
<p>除了静态变量和静态方法之外，static 也用于静态块，多用于初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 执行相关操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外 static 也多用于修饰内部类，此时称之为静态内部类。</p>
<p>最后一种用法就是静态导包，即 <code>import static</code>。import static 是在 JDK1.5 之后引入的新特性，可以用来指定导入某个类中的静态资源，并且不需要使用类名，可以直接使用资源名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(Math.sin(20)); 传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="static-和-final-的区别"><a href="#static-和-final-的区别" class="headerlink" title="static 和 final 的区别"></a>static 和 final 的区别</h2><table>
<thead>
<tr>
<th>修饰物</th>
<th>关键词</th>
<th>影响</th>
</tr>
</thead>
<tbody><tr>
<td>变量</td>
<td>final</td>
<td>分配到常量池中，程序不可改变其值</td>
</tr>
<tr>
<td>变量</td>
<td>static</td>
<td>分配在内存堆上，引用都会指向这一个地址而不会重新分配内存</td>
</tr>
<tr>
<td>方法</td>
<td>final</td>
<td>子类中将不能被重写</td>
</tr>
<tr>
<td>方法块</td>
<td>static</td>
<td>虚拟机优先加载</td>
</tr>
<tr>
<td>类</td>
<td>final</td>
<td>不能被继承</td>
</tr>
<tr>
<td>类</td>
<td>static</td>
<td>可以直接通过类来调用而不需要 new</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>EDAS ECS 应用托管</title>
    <url>/articles/Java-Framework-EDAS-ECS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>您可以将 Java 应用托管到 EDAS 的 ECS 集群或混合云 ECS 集群。EDAS 为托管的应用提供了生命周期管理、CI/CD、监控、运维等一系列功能。</p>
<span id="more"></span>

<h1 id="应用托管概述"><a href="#应用托管概述" class="headerlink" title="应用托管概述"></a>应用托管概述</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>![ECS应用托管功能总览](Java-Framework-EDAS-ECS/ECS 应用托管概览.png)</p>
<h2 id="ECS-环境类型"><a href="#ECS-环境类型" class="headerlink" title="ECS 环境类型"></a>ECS 环境类型</h2><p>EDAS 支持阿里云 ECS 集群和混合云 ECS 集群。</p>
<ul>
<li>阿里云 ECS 集群：在专有网络 VPC 内创建的集群，由阿里云 ECS 实例组成。更多信息，请参见<a href="https://help.aliyun.com/document_detail/57453.htm#topic2215">使用控制台创建ECS集群</a>。</li>
<li>混合云 ECS 集群：在专有网络 VPC 内创建的集群，包含阿里云 ECS 实例、IDC 或其它云服务提供商的服务器。更多信息，请参见<a href="https://help.aliyun.com/document_detail/90647.htm#task-1425878">创建混合云ECS集群</a>。</li>
</ul>
<h2 id="ECS-环境支持的应用类型"><a href="#ECS-环境支持的应用类型" class="headerlink" title="ECS 环境支持的应用类型"></a>ECS 环境支持的应用类型</h2><p>您可以使用 EDAS 的 ECS 环境托管 Spring Cloud 和 Dubbo 等主流 Java 微服务框架应用，也可以托管 HSF 框架应用。</p>
<h2 id="ECS-环境提供的应用托管功能"><a href="#ECS-环境提供的应用托管功能" class="headerlink" title="ECS 环境提供的应用托管功能"></a>ECS 环境提供的应用托管功能</h2><p>ECS 环境为应用提供完整的生命周期管理、服务治理、监控、运维，以及托管应用所需的资源管理能力。</p>
<table>
<thead>
<tr>
<th align="left">使用场景</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">资源管理</td>
<td align="left">EDAS 是面向应用的 PaaS 平台，为应用提供 ECS 和 K8s 环境及相关资源。EDAS 的 ECS 环境中主要包含命名空间、VPC、集群和 ECS。更多信息，请参见<a href="https://help.aliyun.com/document_detail/199263.htm#concept-v5i-i7a-36o">ECS资源管理概述</a>。</td>
</tr>
<tr>
<td align="left">部署应用</td>
<td align="left">创建和部署（首次部署）：在应用开发、测试完成后，可以在 ECS 集群中创建并部署。更多信息，请参见<a href="https://help.aliyun.com/document_detail/199494.htm#concept-2025121">应用创建和部署概述（ECS）</a>。升级和回滚：应用在 EDAS 中创建并部署后，还会不断迭代，需要升级。如果升级的应用版本发现问题，需要将应用回滚到历史版本。更多信息，请参见<a href="https://help.aliyun.com/document_detail/199496.htm#concept-2025835">升级和回滚应用概述（ECS）</a>。</td>
</tr>
<tr>
<td align="left">CI/CD</td>
<td align="left">应用在不断迭代过程中，需要持续集成（CI）和持续部署（CD）。EDAS 支持通过<a href="https://www.jenkins.io/">Jenkins</a>和<a href="https://www.aliyun.com/product/yunxiao">云效</a>对您部署的应用进行 CI/CD。具体操作，请参见：<a href="https://help.aliyun.com/document_detail/178330.htm#task-2369261">使用云效2020部署Java应用至ECS集群</a><a href="https://help.aliyun.com/document_detail/55479.htm#topic4215">使用Jenkins创建持续集成</a></td>
</tr>
<tr>
<td align="left">应用监控</td>
<td align="left">EDAS 集成了应用实时监控服务 ARMS，为部署在 EDAS 中的应用提供关键指标的监控能力和报警能力。具体操作，请参见<a href="https://help.aliyun.com/document_detail/148863.htm#concept-87109-zh">应用总览</a>。</td>
</tr>
<tr>
<td align="left">应用运维</td>
<td align="left">EDAS 为应用提供了一些列运维功能，包括：<a href="https://help.aliyun.com/document_detail/88169.htm#concept-113076-zh">ECS 集群中的应用生命周期管理</a><a href="https://help.aliyun.com/document_detail/108135.htm#concept-2038440">负载均衡概述</a><a href="https://help.aliyun.com/document_detail/52774.htm#topic2891">对ECS集群中的应用进行弹性伸缩</a><a href="https://help.aliyun.com/document_detail/118764.htm#topic1278">限流降级</a><a href="https://help.aliyun.com/document_detail/99153.htm#topic705">查看应用变更</a><a href="https://help.aliyun.com/document_detail/121171.htm#concept-2038346">日志简介</a></td>
</tr>
</tbody></table>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="ECS-资源管理概述"><a href="#ECS-资源管理概述" class="headerlink" title="ECS 资源管理概述"></a><a href="https://help.aliyun.com/document_detail/199263.html?spm=a2c4g.11186623.6.732.253f575amEYRr1">ECS 资源管理概述</a></h2><h2 id="管理微服务空间"><a href="#管理微服务空间" class="headerlink" title="管理微服务空间"></a>管理微服务空间</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/65495.html?spm=a2c4g.11186623.6.734.128b2177K6rYDh">使用控制台管理微服务空间</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/213305.html?spm=a2c4g.11186623.6.735.4be39bbbL3i2XQ">使用 API 管理微服务空间</a></p>
</li>
</ul>
<h2 id="ECS-集群管理"><a href="#ECS-集群管理" class="headerlink" title="ECS 集群管理"></a>ECS 集群管理</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/57453.html?spm=a2c4g.11186623.6.737.1fad1502LKcABb">使用控制台创建 ECS 集群</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/173807.html?spm=a2c4g.11186623.6.738.12726abfA1V1yn">扩容 ECS 集群</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/213309.html?spm=a2c4g.11186623.6.739.422246a2r4EKd0">使用 API 创建 ECS 集群</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/213310.html?spm=a2c4g.11186623.6.740.6220c943EsLwG7">使用 API 扩容 ECS 集群</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/57452.html?spm=a2c4g.11186623.6.741.1c65287fcM42aD">管理 ECS 集群</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/48905.html?spm=a2c4g.11186623.6.742.734f420c6dPAMC">使用控制台管理 ECS 集群中的应用实例分组</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/214185.html?spm=a2c4g.11186623.6.743.7e3611d9eDmHNC">使用 API 管理 ECS 集群中的应用实例分组</a></p>
</li>
</ul>
<h2 id="ECS-实例管理"><a href="#ECS-实例管理" class="headerlink" title="ECS 实例管理"></a>ECS 实例管理</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/69769.html?spm=a2c4g.11186623.6.745.730541ceG4VnMh">创建 ECS 实例</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/54052.html?spm=a2c4g.11186623.6.746.58ef68dcpqZA4B">为 ECS 实例安装 EDAS Agent</a></p>
</li>
</ul>
<h2 id="创建混合云-ECS-集群"><a href="#创建混合云-ECS-集群" class="headerlink" title="创建混合云 ECS 集群"></a><a href="https://help.aliyun.com/document_detail/90647.html?spm=a2c4g.11186623.6.747.5f7d7e8bUoOnxF">创建混合云 ECS 集群</a></h2><h2 id="管理资源组"><a href="#管理资源组" class="headerlink" title="管理资源组"></a><a href="https://help.aliyun.com/document_detail/54182.html?spm=a2c4g.11186623.6.748.7b8737c9JMJILy">管理资源组</a></h2><h1 id="创建和部署应用"><a href="#创建和部署应用" class="headerlink" title="创建和部署应用"></a>创建和部署应用</h1><ul>
<li><p><a href="https://help.aliyun.com/document_detail/199494.html?spm=a2c4g.11186623.6.750.6aa52977MgCOHx">应用创建和部署概述</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/94515.html?spm=a2c4g.11186623.6.751.28c3312ekGg2EM">在 ECS 集群中创建并部署应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/199495.html?spm=a2c4g.11186623.6.752.55ed2e4bSmq6aO">在混合云中部署应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/212642.html?spm=a2c4g.11186623.6.753.3f0514a5hFfxkx">使用 API 创建应用</a></p>
</li>
</ul>
<h1 id="升级和回滚应用"><a href="#升级和回滚应用" class="headerlink" title="升级和回滚应用"></a>升级和回滚应用</h1><h2 id="升级和回滚应用概述"><a href="#升级和回滚应用概述" class="headerlink" title="升级和回滚应用概述"></a><a href="https://help.aliyun.com/document_detail/199496.html?spm=a2c4g.11186623.6.755.45da6a24QiTMXb">升级和回滚应用概述</a></h2><h2 id="单批发布"><a href="#单批发布" class="headerlink" title="单批发布"></a>单批发布</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/199247.html?spm=a2c4g.11186623.6.757.1c1c1c14ANg4K6">使用控制台升级应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/212641.html?spm=a2c4g.11186623.6.758.77f52bd5tuj94R">使用 API 在 ECS 集群中单批发布应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/98551.html?spm=a2c4g.11186623.6.759.15948ed8hJktBl">在 IntelliJ IDEA 中使用 Cloud Toolkit 部署应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/96007.html?spm=a2c4g.11186623.6.760.63354535QOPv0q">在 Eclipse 中使用 Cloud Toolkit 部署应用至 ECS 集群</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/92242.html?spm=a2c4g.11186623.6.761.776351d8eaAmxZ">使用 toolkit-maven-plugin 插件升级应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/96025.html?spm=a2c4g.11186623.6.762.474532c9bH5UYQ">使用 CLI 快速部署应用至 ECS 集群</a></p>
</li>
</ul>
<h2 id="分批发布"><a href="#分批发布" class="headerlink" title="分批发布"></a>分批发布</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/201454.html?spm=a2c4g.11186623.6.764.7e666fb7Q8MBj7">使用控制台分批发布应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/213315.html?spm=a2c4g.11186623.6.765.61416fb757lMIL">使用 API 在 ECS 集群中分批发布应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/201496.html?spm=a2c4g.11186623.6.766.626d3bdc2YMXKk">使用 toolkit-maven-plugin 插件分批发布应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/201495.html?spm=a2c4g.11186623.6.767.48966b5a2Hs7cH">使用 Cloud Toolkit 分批发布应用</a></p>
</li>
</ul>
<h2 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/150110.html?spm=a2c4g.11186623.6.769.2dcc3c40rtjSi4">使用控制台金丝雀发布</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/213316.html?spm=a2c4g.11186623.6.770.12f0442f4SWXKy">使用 API 金丝雀发布</a></p>
</li>
</ul>
<h2 id="回滚应用"><a href="#回滚应用" class="headerlink" title="回滚应用"></a>回滚应用</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/202339.html?spm=a2c4g.11186623.6.772.645d34b45eNrp2">回滚应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/213317.html?spm=a2c4g.11186623.6.773.3366141cf3L3U9">使用 API 在 ECS 集群中回滚应用到目标历史版本</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/213319.html?spm=a2c4g.11186623.6.774.718d443dwf9nJT">使用 API 在 ECS 集群中终止应用升级变更流程</a></p>
</li>
</ul>
<h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h1><ul>
<li><p><a href="https://help.aliyun.com/document_detail/178330.html?spm=a2c4g.11186623.6.776.4887bfc7w3p95c">使用云效 2020 部署 Java 应用至 ECS 集群</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/55479.html?spm=a2c4g.11186623.6.777.563619c6cwebUx">使用 Jenkins 创建持续集成</a></p>
</li>
</ul>
<h1 id="应用设置"><a href="#应用设置" class="headerlink" title="应用设置"></a>应用设置</h1><ul>
<li><p><a href="https://help.aliyun.com/document_detail/54313.html?spm=a2c4g.11186623.6.779.eaa37de4TrDIOB">设置部署在 ECS 集群中的应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/172008.html?spm=a2c4g.11186623.6.780.46991b20n7g799">设置应用生命周期挂载脚本</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/99340.html?spm=a2c4g.11186623.6.781.7bdc4ba1LOSpzL">健康检查</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/170028.html?spm=a2c4g.11186623.6.782.8bdf5692JmJcou">同可用区优化路由</a></p>
</li>
</ul>
<h1 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h1><h2 id="应用监控概述"><a href="#应用监控概述" class="headerlink" title="应用监控概述"></a><a href="https://help.aliyun.com/document_detail/200400.html?spm=a2c4g.11186623.6.784.166e57d2A7roCd">应用监控概述</a></h2><h2 id="应用总览"><a href="#应用总览" class="headerlink" title="应用总览"></a><a href="https://help.aliyun.com/document_detail/148863.html?spm=a2c4g.11186623.6.785.57fd7ed74DgF0p">应用总览</a></h2><h2 id="应用详情"><a href="#应用详情" class="headerlink" title="应用详情"></a>应用详情</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/203216.html?spm=a2c4g.11186623.6.787.7bbe224cCfAF2M">概览</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/148865.html?spm=a2c4g.11186623.6.788.a05c38f2Jh9Tq5">JVM 监控</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/148866.html?spm=a2c4g.11186623.6.789.2f9214222z5vf1">主机监控</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/203217.html?spm=a2c4g.11186623.6.790.7049736eVTKTzY">SQL 调用分析</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/203218.html?spm=a2c4g.11186623.6.791.349e47b2W014Nj">NoSQL 调用分析</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/203219.html?spm=a2c4g.11186623.6.792.15c25285mFwPTP">错误分析</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/203220.html?spm=a2c4g.11186623.6.793.53f06554tySq2q">上游应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/203221.html?spm=a2c4g.11186623.6.794.68342b2fzhpsDl">下游应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/203222.html?spm=a2c4g.11186623.6.795.50725876lM1pgD">接口快照</a></p>
</li>
</ul>
<h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a><a href="https://help.aliyun.com/document_detail/148867.html?spm=a2c4g.11186623.6.796.297d393ehXw0lR">接口调用</a></h2><h2 id="高级监控"><a href="#高级监控" class="headerlink" title="高级监控"></a><a href="https://help.aliyun.com/document_detail/100587.html?spm=a2c4g.11186623.6.797.40667e35E1Jdqq">高级监控</a></h2><h2 id="报警管理"><a href="#报警管理" class="headerlink" title="报警管理"></a>报警管理</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/172459.html?spm=a2c4g.11186623.6.799.6fd32119wvG6hZ">创建联系人</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/172460.html?spm=a2c4g.11186623.6.800.1e6d63ebZoDDid">创建和管理联系人分组</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/172457.html?spm=a2c4g.11186623.6.801.13fc71cdJWmcLs">创建报警</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/172458.html?spm=a2c4g.11186623.6.802.7a37595aEdn1Ze">管理报警</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/172461.html?spm=a2c4g.11186623.6.803.360f776bcQq6H5">设置钉钉机器人报警</a></p>
</li>
</ul>
<h1 id="应用运维"><a href="#应用运维" class="headerlink" title="应用运维"></a>应用运维</h1><h2 id="ECS-集群中的应用生命周期管理"><a href="#ECS-集群中的应用生命周期管理" class="headerlink" title="ECS 集群中的应用生命周期管理"></a><a href="https://help.aliyun.com/document_detail/88169.html?spm=a2c4g.11186623.6.805.36c738761IYFVD">ECS 集群中的应用生命周期管理</a></h2><h2 id="扩容部署在-ECS-集群中的应用"><a href="#扩容部署在-ECS-集群中的应用" class="headerlink" title="扩容部署在 ECS 集群中的应用"></a><a href="https://help.aliyun.com/document_detail/73039.html?spm=a2c4g.11186623.6.806.53d8dd989YV6F1">扩容部署在 ECS 集群中的应用</a></h2><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/108135.html?spm=a2c4g.11186623.6.808.962e567aqkayJZ">负载均衡概述</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/107831.html?spm=a2c4g.11186623.6.809.63715dfcSduX1d">应用独享负载均衡实例</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/108589.html?spm=a2c4g.11186623.6.810.5b5e6e46Dw7e1q">使用端口实现流量分发（共享负载均衡实例）</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/108669.html?spm=a2c4g.11186623.6.811.7f1b67cbTqh2NA">使用域名或 URL 实现流量分发（共享负载均衡实例）</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/108878.html?spm=a2c4g.11186623.6.812.1c6328f6WiwLsZ">使用 URL 实现应用实例分组的流量分发</a></p>
</li>
</ul>
<h2 id="对-ECS-集群中的应用进行弹性伸缩"><a href="#对-ECS-集群中的应用进行弹性伸缩" class="headerlink" title="对 ECS 集群中的应用进行弹性伸缩"></a><a href="https://help.aliyun.com/document_detail/52774.html?spm=a2c4g.11186623.6.813.36553c85DDdSWX">对 ECS 集群中的应用进行弹性伸缩</a></h2><h2 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a><a href="https://help.aliyun.com/document_detail/118764.html?spm=a2c4g.11186623.6.814.33176dacYPr2NH">限流降级</a></h2><h2 id="运行环境升降级"><a href="#运行环境升降级" class="headerlink" title="运行环境升降级"></a><a href="https://help.aliyun.com/document_detail/43842.html?spm=a2c4g.11186623.6.815.33572bc7LtoRHl">运行环境升降级</a></h2><h2 id="变更记录"><a href="#变更记录" class="headerlink" title="变更记录"></a>变更记录</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/99153.html?spm=a2c4g.11186623.6.817.5a975cfb5lw5SJ">查看应用变更</a></li>
<li><a href="https://help.aliyun.com/document_detail/106573.html?spm=a2c4g.11186623.6.818.555e18cbb7SUft">变更流程错误码说明</a></li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/121171.html?spm=a2c4g.11186623.6.820.3220c4bea2Jg3z">日志简介</a></li>
<li><a href="https://help.aliyun.com/document_detail/43719.html?spm=a2c4g.11186623.6.821.4c655f157t6TAG">日志管理</a></li>
<li><a href="https://help.aliyun.com/document_detail/113163.html?spm=a2c4g.11186623.6.822.1b8e1050j9s6XD">使用 EDAS CLI 下载日志</a></li>
</ul>
<h1 id="ECS-集群使用常见问题"><a href="#ECS-集群使用常见问题" class="headerlink" title="ECS 集群使用常见问题"></a>ECS 集群使用常见问题</h1><h2 id="资源管理-1"><a href="#资源管理-1" class="headerlink" title="资源管理"></a>资源管理</h2><ul>
<li><a href="https://help.aliyun.com/knowledge_detail/43863.html?spm=a2c4g.11186623.6.825.62ba76ecTS0jIH">安装 EDAS Agent 后没有上报信息且未显示 EDAS Agent 的版本号</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/44536.html?spm=a2c4g.11186623.6.826.15572c1dJWVUSE">安装 EDAS Agent 后控制台状态为“未知”或“异常”</a></li>
<li><a href="https://help.aliyun.com/document_detail/42948.html?spm=a2c4g.11186623.6.827.25037ed1CvxYbG">什么是 Docker 实例？和 ECS 独占实例有何区别？</a></li>
<li><a href="https://help.aliyun.com/document_detail/43862.html?spm=a2c4g.11186623.6.828.76d4729fxsvw9R">购买了 EDAS 之后，是否需要另行购买 ECS？</a></li>
<li><a href="https://help.aliyun.com/document_detail/43865.html?spm=a2c4g.11186623.6.829.44af7392EZA8h8">EDAS 的 Java 版本是哪个版本，我能够选择吗？</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/43866.html?spm=a2c4g.11186623.6.830.30ae64cfV6DY1c">Agent 进程停止运行后提示“AGENT 异常”</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/43869.html?spm=a2c4g.11186623.6.831.225f1933A5eQKd">Ali-Tomcat 容器无响应</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/43861.html?spm=a2c4g.11186623.6.832.cd6d56abl5vg0P">在 EDAS 控制台导入 ECS 实例时资源未及时同步</a></li>
<li><a href="https://help.aliyun.com/document_detail/47524.html?spm=a2c4g.11186623.6.833.734e66c2k3ekpJ">应用实例说明</a></li>
<li><a href="https://help.aliyun.com/document_detail/52634.html?spm=a2c4g.11186623.6.834.7f815fb2AuOPy3">安装 Agent 的过程中发现卸载 Java</a></li>
<li><a href="https://help.aliyun.com/document_detail/55872.html?spm=a2c4g.11186623.6.835.35bbb249vnIvnM">日志采集器相关问题</a></li>
</ul>
<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/44025.html?spm=a2c4g.11186623.6.837.2c49500fdy2s0M">重启服务后 EDAS Agent 是否能自动重启？</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/44030.html?spm=a2c4g.11186623.6.838.53b15133Szrj2c">EDAS Agent 无法启动</a></li>
<li><a href="https://help.aliyun.com/document_detail/44032.html?spm=a2c4g.11186623.6.839.8ddc70f13dNhuk">EDAS 是否支持在同一个实例上安装多个应用？</a></li>
<li><a href="https://help.aliyun.com/document_detail/44026.html?spm=a2c4g.11186623.6.840.fcf65d32elyNay">应用部署时提供的发布包 URL 是不是可以随意设置？</a></li>
<li><a href="https://help.aliyun.com/document_detail/44028.html?spm=a2c4g.11186623.6.841.16152fc3Th5N94">启停和部署应用等管理操作失败了怎么办？</a></li>
<li><a href="https://help.aliyun.com/document_detail/44033.html?spm=a2c4g.11186623.6.842.31591d6cvp8p0Z">已买的 ECS 实例没有出现在实例列表中怎么办？</a></li>
<li><a href="https://help.aliyun.com/document_detail/44029.html?spm=a2c4g.11186623.6.843.3e49376dSTMHNS">为什么在 EDAS 控制台上实例的状态是“未知”？</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/43878.html?spm=a2c4g.11186623.6.844.28ab7fbdvT6xM7">服务可以正常调用，但是服务列表不显示</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/43877.html?spm=a2c4g.11186623.6.845.6e6a7b5fCkbFyI">服务列表显示正常，但是调用失败怎么办？</a></li>
<li><a href="https://help.aliyun.com/document_detail/44019.html?spm=a2c4g.11186623.6.846.1cca7f12Qjkhf2">删除应用后是否可以恢复？</a></li>
<li><a href="https://help.aliyun.com/document_detail/43875.html?spm=a2c4g.11186623.6.847.49334cb17BJsyK">如何进行分批发布或者分组发布？</a></li>
<li><a href="https://help.aliyun.com/document_detail/43871.html?spm=a2c4g.11186623.6.848.bc4d79d557JrVc">应用部署在多个实例后，集群中会话如何共享？</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/43873.html?spm=a2c4g.11186623.6.849.37ea67b9LWqE1p">应用部署在多个实例后，如何实现负载均衡？</a></li>
<li><a href="https://help.aliyun.com/document_detail/68940.html?spm=a2c4g.11186623.6.850.575b60557M4jHJ">创建应用时的安全组规则</a></li>
<li><a href="https://help.aliyun.com/document_detail/96072.html?spm=a2c4g.11186623.6.851.56b2799dKPp3Np">如何分批升降级应用的运行环境</a></li>
<li><a href="https://help.aliyun.com/document_detail/143824.html?spm=a2c4g.11186623.6.852.2fdf2b92qh3aWA">快速入门常见问题</a></li>
<li><a href="https://help.aliyun.com/document_detail/147743.html?spm=a2c4g.11186623.6.853.3fde6ec6mUPqCE">应用部署时的默认启动命令参数</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/53066.html?spm=a2c4g.11186623.6.854.2bd31d06f4nUlc">在 EDAS 控制台中对应用进行操作无响应</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/64352.html?spm=a2c4g.11186623.6.855.66893469kEZ6MZ">EDAS 应用变更失败的问题排查</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/73757.html?spm=a2c4g.11186623.6.856.615aaf1fur4hrb">EDAS 应用无法访问页面</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/100850.html?spm=a2c4g.11186623.6.857.69312a9dJgaSql">EDAS 应用进程突然消失</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/131886.html?spm=a2c4g.11186623.6.858.1dfc166cSL3DW2">ECS 集群应用日志清理机制是什么？</a></li>
</ul>
<h2 id="端口占用"><a href="#端口占用" class="headerlink" title="端口占用"></a>端口占用</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/51179.html?spm=a2c4g.11186623.6.860.206c4f1fi3iAy6">ECS 安全组规则</a></li>
</ul>
<h2 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h2><ul>
<li><a href="https://help.aliyun.com/knowledge_detail/100768.html?spm=a2c4g.11186623.6.862.79482a93oZghdR">如何在本地使用 jconsole 或 jvisualvm 监控运行在 ECS 实例上的 JVM 进程</a></li>
</ul>
<h2 id="日志诊断常见问题"><a href="#日志诊断常见问题" class="headerlink" title="日志诊断常见问题"></a>日志诊断常见问题</h2><ul>
<li><a href="https://help.aliyun.com/knowledge_detail/108510.html?spm=a2c4g.11186623.6.864.7037519bhV10vG">Java 应用如何收集 CPU 使用率高的问题信息</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>企业级分布式应用服务 EDAS 简介</title>
    <url>/articles/Java-Framework-EDAS-Introduction.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>企业级分布式应用服务 EDAS（Enterprise Distributed Application Service）是一个应用托管和微服务管理的 PaaS 平台，提供应用开发、部署、监控、运维等全栈式解决方案，支持 Spring Cloud、Dubbo 等微服务运行环境，助力应用轻松上云。</p>
<span id="more"></span>

<h1 id="EDAS-简介"><a href="#EDAS-简介" class="headerlink" title="EDAS 简介"></a>EDAS 简介</h1><!--EDAS 简介视频-->

<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"video":{"url":"https://aliware-images.oss-cn-hangzhou.aliyuncs.com/EDAS/VIDEO/EDAS_mg_animation_Overview.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on("loadstart",function(){console.log("loadstart")})})()</script>

<p>在数字经济时代，为了连接更多消费者，越来越多的企业将业务数字化向消费端延伸。鉴于消费者体量大和需求变化快的特点，业务需求的敏捷开发和资源集约化部署成为企业面临的主要问题。</p>
<p>阿里云原生团队打造的 EDAS 是一站式云原生应用 PaaS 平台，面向分布式架构和数字化在线业务上云需求，EDAS 无缝集成了阿里云容器服务 Kubernetes 版和阿里云 ECS 作为运行时资源，不仅提供了应用生命周期管理和轻量化运维等基础应用托管能力，还支持高可用部署、应用发布版本管理、变更流程跟踪和应用层极致弹性等全流程管控能力，提供一站式 PaaS 体验。</p>
<p>对于 Spring Cloud 和 Dubbo 等 Java 语言的开源微服务框架应用，无需修改任何代码即可迁移至 EDAS，享受金丝雀发布、离群实例摘除、服务鉴权、无损下线、限流降级和全链路流控等高阶微服务治理能力。</p>
<p>此外，EDAS 支持直接部署 PHP 应用和通过服务网格部署多语言微服务应用，为多语言微服务应用提供了应用托管、服务发现、链路追踪和负载均衡等服务管理能力。</p>
<p>EDAS 融合并升级了阿里巴巴应用安全生产三板斧：</p>
<ul>
<li><p>可观测</p>
<ul>
<li>应用总览</li>
<li>变更记录</li>
</ul>
<p>等功能，可帮您实现多维度全流程观测变更过程</p>
</li>
<li><p>可灰度</p>
<ul>
<li>金丝雀发布</li>
<li>灰度发布</li>
</ul>
</li>
<li><p>可回滚</p>
<ul>
<li>日常运行应用支持回滚到历史版本</li>
<li>发布过程支持一键回滚</li>
</ul>
</li>
</ul>
<p>EDAS 实现了应用的监管控一体化，提供了更多纬度的自动监控、智能诊断和报告输出等功能。</p>
<p>结合开源云原生的理念，EDAS 对接了云效和 Jenkins 等多种主流 DevOps 发布系统，实现了应用的持续集成，并且完全兼容 Cloud Toolkit 插件，实现了应用自动化部署。</p>
<p>目前 EDAS 的产品形态包括公有云、专有云、政务云、金融云和混合云等，无论哪一种形态，EDAS 都提供了一整套的智能巡检、全景监控和智能诊断等以应用为中心的运维能力。</p>
<p>EDAS 目前已成功服务众多领域的客户：</p>
<ul>
<li>互联网领域<ul>
<li>社交</li>
<li>娱乐</li>
<li>在线教育等</li>
</ul>
</li>
<li>数字金融领域<ul>
<li>银行</li>
<li>保险</li>
<li>证券基金等</li>
</ul>
</li>
<li>电商领域<ul>
<li>各种可以线上买买买的场景</li>
</ul>
</li>
<li>零售领域<ul>
<li>会员</li>
<li>促销</li>
<li>抢购</li>
<li>秒杀等场景</li>
</ul>
</li>
<li>数字政务领域<ul>
<li>健康码</li>
<li>线上政务办理等</li>
</ul>
</li>
</ul>
<p>上云就上阿里云，云原生就用 EDAS，助理企业实现智慧数字化升级。</p>
<h2 id="应用托管"><a href="#应用托管" class="headerlink" title="应用托管"></a>应用托管</h2><p>应用托管是开发者本身不为应用提供服务器，将应用托管给服务提供商。应用完成开发后，可以托管在 EDAS 上。</p>
<p><img src="Java-Framework-EDAS-Introduction/%E5%BA%94%E7%94%A8%E6%89%98%E7%AE%A1%E6%A6%82%E8%A7%88.png" alt="应用托管概览"></p>
<ul>
<li><p>多种语言支持</p>
<p>EDAS 支持托管 Java 应用，K8s 环境还支持托管 PHP、Node.js、C++ 和 Go 等多语言应用。</p>
</li>
<li><p>多种底层服务器选择</p>
<p>EDAS 无缝集成了 ECS 云服务器和容器服务 Kubernetes 版，可以基于实际托管需求来选择 ECS 集群、K8s 集群，以及混合云集群。</p>
</li>
<li><p>多种发布方式</p>
<ul>
<li>支持使用控制台和 API 来完成创建和部署，并支持 WAR 包、JAR 包和镜像多种部署形式。</li>
<li>支持使用控制台、API和插件完成应用升级，并支持单批发布、分批发布和金丝雀发布。</li>
<li>支持使用云效和 Jenkins 实现应用的 CI/CD。</li>
</ul>
</li>
<li><p>应用生命周期管理</p>
<p>EDAS 提供从创建到运行的应用全生命周期管理服务，包括应用的发布、启动、停止、扩容、缩容和删除等服务，可以轻松运维上千个应用实例。</p>
</li>
<li><p>应用监控</p>
<p>EDAS 集成了应用实时监控服务 ARMS。可以监控部署在 EDAS 中的应用的健康状态和关键指标，并针对监控指标设置告警，及时发现并处理可能存在的异常或故障，以保障应用的健康和可用性。</p>
</li>
<li><p>应用运维</p>
<p>EDAS 为应用提供了一系列运维功能，包括生命周期管理、应用访问方式管理、弹性伸缩、限流降级、负载均衡、变更记录、事件中心、日志管理等。</p>
</li>
</ul>
<p>应用托管的更多信息，请参见：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/199295.htm#concept-2022854">应用托管概述（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/200648.htm#concept-2022850">应用托管概述（ECS）</a></li>
</ul>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>有别于传统的单体式应用架构，微服务架构将应用拆分成多个核心功能，每个功能都可以作为一项独立的服务，由独立团队负责并且可以独立构建和部署，各项服务在运行和出现故障时不会相互影响。微服务使应用更易于扩展和更快地开发，从而加速创新并缩短新功能的发布周期。</p>
<p>EDAS 提供了从开发、部署到治理的完整的微服务解决方案。</p>
<ul>
<li><p>应用开发</p>
<p>EDAS 支持基于 Spring Cloud、Apache Dubbo 以及 HSF 开发的微服务应用。各种框架的微服务应用无需修改任何代码和配置，即可直接部署到 EDAS。</p>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/98591.html">概述</a></li>
</ul>
<h3 id="Apache-Dubbo"><a href="#Apache-Dubbo" class="headerlink" title="Apache Dubbo"></a>Apache Dubbo</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/99299.html">概述</a></li>
</ul>
<h3 id="HSF"><a href="#HSF" class="headerlink" title="HSF"></a>HSF</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/100087.html">概述</a></li>
</ul>
</li>
<li><p>应用部署</p>
<p>EDAS针对微服务应用的开发、运行现状，提供了多种路径，帮助您将微服务应用部署或迁移到EDAS。无论您选择哪种路径，都可以使用EDAS完整的微服务治理能力。</p>
</li>
<li><p>微服务治理</p>
<p>EDAS为各种框架的微服务应用提供了服务查询、调用链查询、离群实例摘除和服务鉴权等完整的微服务治理能力。</p>
<h3 id="Spring-Cloud-1"><a href="#Spring-Cloud-1" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/132165.html">无损下线</a></li>
<li><a href="https://help.aliyun.com/document_detail/150111.html">金丝雀发布（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/150110.html">金丝雀发布（ECS）</a></li>
<li><a href="https://help.aliyun.com/document_detail/145687.html">离群实例摘除</a></li>
</ul>
<h3 id="Apache-Dubbo-1"><a href="#Apache-Dubbo-1" class="headerlink" title="Apache Dubbo"></a>Apache Dubbo</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/131248.html">无损下线</a></li>
<li><a href="https://help.aliyun.com/document_detail/150111.html">金丝雀发布（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/150110.html">金丝雀发布（ECS）</a></li>
<li><a href="https://help.aliyun.com/document_detail/141730.html">离群实例摘除</a></li>
</ul>
<h3 id="HSF-1"><a href="#HSF-1" class="headerlink" title="HSF"></a>HSF</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/102369.html">无损上线</a></li>
<li><a href="https://help.aliyun.com/document_detail/107944.html">全链路流量控制</a></li>
<li><a href="https://help.aliyun.com/document_detail/155533.html">查询调用链</a></li>
<li><a href="https://help.aliyun.com/document_detail/147122.html">离群实例摘除</a></li>
</ul>
</li>
</ul>
<h2 id="云原生应用-PaaS-平台"><a href="#云原生应用-PaaS-平台" class="headerlink" title="云原生应用 PaaS 平台"></a>云原生应用 PaaS 平台</h2><p>云原生是指应用原生被设计为在云上以最佳方式运行，充分发挥云的优势。在云原生时代，PaaS 平台将下沉到基础设施，成为云的一部分。EDAS 正是一个应用托管和微服务管理的 PaaS 平台。</p>
<ul>
<li><p>云服务集成</p>
<p>EDAS 作为应用的一站式 PaaS 平台，集成了众多阿里云服务，以产品和 EDAS 内部组件两种形态为 EDAS 中的应用提供各个层面、维度的功能。</p>
<ul>
<li>产品集成：以独立产品的形式集成，相关资源、功能由各产品（非 EDAS）管理。</li>
<li>组件集成：以 EDAS 的服务组件形式集成，为 EDAS 提供的资源、服务可以在 EDAS 中管理。</li>
</ul>
<p>更多信息，请参见<a href="https://help.aliyun.com/document_detail/200107.htm#concept-2031005">云服务集成概述</a>。</p>
</li>
<li><p>权限管理</p>
<p>在 EDAS 上托管的应用可能包含多个服务或子系统，这些服务或子系统又可能由不同团队、成员进行开发、运维。EDAS 通过账号体系及基于账号体系的一系列权限管理操作，提供企业级的权限管理系统，帮助用户对应用、资源和数据进行必要的隔离和权限控制，以保证其安全性。</p>
<p>更多信息，请参见<a href="https://help.aliyun.com/document_detail/172276.htm#concept-2549991">权限管理概述</a>。</p>
</li>
</ul>
<h2 id="客户原声"><a href="#客户原声" class="headerlink" title="客户原声"></a>客户原声</h2><p>以下是客户对 EDAS 的评价。</p>
<h3 id="中国邮政-CHINAPOST"><a href="#中国邮政-CHINAPOST" class="headerlink" title="中国邮政 CHINAPOST"></a>中国邮政 CHINAPOST</h3><p>依托 EDAS，邮政传统以省为中心的自建系统平滑向分布式微服务架构转型，利用 EDAS 强大的应用管理能力，新一代寄递系统很好地支撑了多种寄递业务的快速发展。2018 年双 11 期间，邮政在 EDAS 上服务日调用量高达数十亿次，整体业务再创新高，在流量高峰冲击下系统平稳有序运行。</p>
<h3 id="福特汽车-FORD"><a href="#福特汽车-FORD" class="headerlink" title="福特汽车 FORD"></a>福特汽车 FORD</h3><p>通过 EDAS 构建的微服务 PaaS 平台很好地支撑了福特汽车新零售业务，建立线上商城，为汽车买家提供一站式服务，打通线上线下流量。借助 EDAS 微服务治理、运维监控及应用生命周期管理等功能，显著提高需求的迭代效率，建立起数据应用、管理、运营三位一体的企业数字化运营中心。</p>
<h3 id="快鱼服饰-FASTFISH"><a href="#快鱼服饰-FASTFISH" class="headerlink" title="快鱼服饰 FASTFISH"></a>快鱼服饰 FASTFISH</h3><p>借助 EDAS 搭建起业内第一个成熟的分布式业务系统，帮助快鱼解决原有多套系统之间商品、渠道等数据不一致等问题，保障系统的快速迭代和敏捷开发，降低研发周期及成本。微服务架构下，很好地支持海量数据及应用的并发，系统效率提高了 25 倍，有效提升了用户的操作体验。</p>
<h2 id="开通-EDAS"><a href="#开通-EDAS" class="headerlink" title="开通 EDAS"></a>开通 EDAS</h2><p>单击下方文本可立即前往 EDAS 开通页面。</p>
<p><strong><a href="https://common-buy.aliyun.com/?commodityCode=edaspostpay#/buy">立即开通 EDAS</a></strong></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>EDAS 是分布式架构和数字化业务上云的首选应用托管平台，具有广泛的应用场景。下面罗列了 EDAS 的典型应用场景。</p>
<h2 id="微服务解决方案"><a href="#微服务解决方案" class="headerlink" title="微服务解决方案"></a>微服务解决方案</h2><p>EDAS 支持 Apache Dubbo（2.6.x及以上版本）、Spring Cloud（Edgware及以上版本）和 HSF 三个主流微服务框架，更多信息，请参见 <a href="https://help.aliyun.com/document_detail/98591.htm#concept-2038250">Spring Cloud概述</a>、<a href="https://help.aliyun.com/document_detail/99299.htm#concept-2038262">Dubbo 概述</a> 和 <a href="https://help.aliyun.com/document_detail/100087.htm#concept-2310116">HSF 概述</a>。EDAS 内置的 HSF 框架为阿里巴巴自研的高效微服务框架，孵化自阿里众多业务场景的最佳实践；同时，零代码入侵就能完成 Apache Dubbo 和 Spring Cloud 应用上云，有效降低运维成本，支持应用的无损上、下线、金丝雀发布，以及流量控制等多种高级特性，助力用户在云上轻松构建微服务应用。</p>
<h3 id="能够解决的问题"><a href="#能够解决的问题" class="headerlink" title="能够解决的问题"></a>能够解决的问题</h3><ul>
<li>基于成熟微服务框架快速构建应用：借助阿里巴巴自研的微服务框架 HSF 在云上构建微服务应用。</li>
<li>Apache Dubbo 和 Spring Cloud 应用上云：无需构建 ZooKeeper、Eureka 和 Consul 等微服务依赖的自建服务，极大降低运维成本。</li>
<li>提供企业级高级特性：提供无损上、下线、金丝雀发布，以及流量控制等多种高级特性</li>
</ul>
<p>图 1. 微服务解决方案架构图<img src="Java-Framework-EDAS-Introduction/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="微服务解决方案架构图"></p>
<h2 id="应用托管解决方案"><a href="#应用托管解决方案" class="headerlink" title="应用托管解决方案"></a>应用托管解决方案</h2><p>免去运维人员逐台登录 ECS 实例的繁杂操作，免集群维护。用户只需要登录 EDAS 控制台，就可以通过 WAR 包、JAR 包或镜像等多种方式快速部署应用，基于 ECS 提供全应用生命周期管理，包括发布、回滚、应用分组管理、多版本并存，并集成监控、日志等能力，极大的提升了 ECS 的集群管理效率。</p>
<h3 id="能够解决的问题-1"><a href="#能够解决的问题-1" class="headerlink" title="能够解决的问题"></a>能够解决的问题</h3><ul>
<li><strong>大幅降低运维成本</strong>：免 IaaS 运维及集群维护，有效降低运维人力成本。</li>
<li><strong>应用全生命周期管理</strong>：可视化管理应用生命周期，应用运行状态了如指掌。</li>
</ul>
<p>图 2. 应用托管解决方案架构图<img src="Java-Framework-EDAS-Introduction/%E5%BA%94%E7%94%A8%E6%89%98%E7%AE%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="应用托管解决方案图"></p>
<h2 id="容器托管解决方案"><a href="#容器托管解决方案" class="headerlink" title="容器托管解决方案"></a>容器托管解决方案</h2><p>EDAS 支持以容器的形式托管应用，无缝对接阿里云容器服务 Kubernetes 版，用户无需理解容器服务底层细节。通过 EDAS 控制台就能完成应用在容器里的全生命周期管理，包括监控、诊断等服务。用户可以低门槛拥抱容器新技术，最大化利用资源。</p>
<h3 id="能够解决的问题-2"><a href="#能够解决的问题-2" class="headerlink" title="能够解决的问题"></a>能够解决的问题</h3><ul>
<li><strong>无缝支持 Kubernetes</strong>：Kubernetes 集群托管给 EDAS，用户仅需关注应用生命周期管理即可。</li>
<li><strong>容器与微服务完美结合</strong>：基于 Kubernetes，快速构建容器上的微服务架构。</li>
<li><strong>无需构建镜像</strong>：支持 WAR 包和 JAR 包直接部署，EDAS 代为构建镜像并部署到 Kubernetes 集群，有效简化流程降低使用门槛。</li>
</ul>
<p>图 3. 容器托管解决方案<img src="Java-Framework-EDAS-Introduction/%E5%AE%B9%E5%99%A8%E6%89%98%E7%AE%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.jpg" alt="容器托管解决方案架构图"></p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/42934.htm#concept-2038209">什么是企业级分布式应用服务 EDAS</a></li>
<li><a href="https://help.aliyun.com/document_detail/200648.htm#concept-2022850">应用托管概述（ECS）</a></li>
<li><a href="https://help.aliyun.com/document_detail/199295.htm#concept-2022854">应用托管概述（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/169229.htm#task-2510189">Spring Cloud 和 Dubbo 框架应用无缝迁移上 EDAS 概述</a></li>
</ul>
<h1 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h1><p>由浅入深，玩转企业级分布式应用服务 EDAS。</p>
<h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><h3 id="EDAS-介绍"><a href="#EDAS-介绍" class="headerlink" title="EDAS 介绍"></a>EDAS 介绍</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/42934.html?spm=a2c4g.11174283.2.6.5b2a4c07vnaxjR">什么是企业级分布式应用服务 EDAS</a></li>
<li><a href="https://help.aliyun.com/document_detail/42939.html?spm=a2c4g.11186623.6.560.489376ecsNEFYJ">应用场景</a></li>
<li><a href="https://help.aliyun.com/document_detail/57568.html?spm=a2c4g.11174283.2.8.5b2a4c07vnaxjR">名词解释</a></li>
</ul>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/134109.html?spm=a2c4g.11174283.2.15.5b2a4c07rlKDsp">部署 Spring Cloud 应用至 ECS 集群</a></li>
<li><a href="https://help.aliyun.com/document_detail/97471.html?spm=a2c4g.11174283.2.16.5b2a4c07rlKDsp">部署 Dubbo 应用至容器服务 K8s 集群</a></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="部署应用至-ECS-集群"><a href="#部署应用至-ECS-集群" class="headerlink" title="部署应用至 ECS 集群"></a>部署应用至 ECS 集群</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/94515.html?spm=a2c4g.11174283.2.17.5b2a4c07rlKDsp">部署 Spring Cloud 应用至 ECS 集群</a></li>
<li><a href="https://help.aliyun.com/document_detail/96025.html?spm=a2c4g.11174283.2.19.5b2a4c07rlKDsp">使用 CLI 快速部署应用至 ECS 集群</a></li>
<li><a href="https://help.aliyun.com/document_detail/98551.html?spm=a2c4g.11174283.2.20.5b2a4c07rlKDsp">在 IntelliJ IDEA 中使用 Cloud Toolkit 快速部署应用至 ECS 集群</a></li>
</ul>
<h3 id="部署应用至-K8s-集群"><a href="#部署应用至-K8s-集群" class="headerlink" title="部署应用至 K8s 集群"></a>部署应用至 K8s 集群</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/157324.html?spm=a2c4g.11174283.2.21.5b2a4c07rlKDsp">在容器服务 K8s 集群中使用镜像方式部署应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/172591.html?spm=a2c4g.11174283.2.22.5b2a4c07rlKDsp">在 Serverless K8s 集群中使用 Jar 包部署应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/128271.html?spm=a2c4g.11174283.2.24.5b2a4c07rlKDsp">使用 Cloud Toolkit 插件快速部署应用至 K8s 集群</a></li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="ECS-集群应用管理"><a href="#ECS-集群应用管理" class="headerlink" title="ECS 集群应用管理"></a>ECS 集群应用管理</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/88169.html?spm=a2c4g.11174283.2.25.5b2a4c07rlKDsp">ECS 集群中的应用生命周期管理</a></li>
<li><a href="https://help.aliyun.com/document_detail/99153.html?spm=a2c4g.11174283.2.26.5b2a4c07rlKDsp">查看应用变更</a></li>
<li><a href="https://help.aliyun.com/document_detail/108135.html?spm=a2c4g.11174283.2.27.5b2a4c07rlKDsp">绑定 SLB</a></li>
<li><a href="https://help.aliyun.com/document_detail/148863.html?spm=a2c4g.11174283.2.28.5b2a4c07rlKDsp">应用监控</a></li>
</ul>
<h3 id="K8s-集群应用管理"><a href="#K8s-集群应用管理" class="headerlink" title="K8s 集群应用管理"></a>K8s 集群应用管理</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/152395.html?spm=a2c4g.11174283.2.29.5b2a4c07rlKDsp">管理应用生命周期</a></li>
<li><a href="https://help.aliyun.com/document_detail/152398.html?spm=a2c4g.11174283.2.30.5b2a4c07rlKDsp">查看应用变更</a></li>
<li><a href="https://help.aliyun.com/knowledge_list/159326.html?spm=a2c4g.11174283.2.31.5b2a4c07rlKDsp">绑定 SLB</a></li>
<li><a href="https://help.aliyun.com/knowledge_list/152399.html?spm=a2c4g.11174283.2.32.5b2a4c07rlKDsp">应用监控</a></li>
</ul>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/62122.html?spm=a2c4g.11174283.2.33.5b2a4c07rlKDsp">ECS 集群 API 概览</a></li>
<li><a href="https://help.aliyun.com/document_detail/165936.html?spm=a2c4g.11174283.2.34.5b2a4c07rlKDsp">K8s 集群 API 概览</a></li>
<li><a href="https://help.aliyun.com/document_detail/62123.html?spm=a2c4g.11174283.2.35.5b2a4c07rlKDsp">Java SDK 接入指南</a></li>
<li><a href="https://help.aliyun.com/document_detail/123354.html?spm=a2c4g.11174283.2.36.5b2a4c07rlKDsp">Python SDK 接入指南</a></li>
<li><a href="https://help.aliyun.com/document_detail/104440.html?spm=a2c4g.11174283.2.37.5b2a4c07rlKDsp">CLI 接入指南</a></li>
<li><a href="https://help.aliyun.com/document_detail/123488.html?spm=a2c4g.11174283.2.38.5b2a4c07rlKDsp">API 调用公共参数</a></li>
</ul>
<h3 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/72618.html?spm=a2c4g.11174283.2.39.5b2a4c07rlKDsp">使用 Spring Cloud 开发应用并托管到 EDAS</a></li>
<li><a href="https://help.aliyun.com/document_detail/97471.html?spm=a2c4g.11174283.2.40.5b2a4c07rlKDsp">使用 Dubbo 开发应用并部署到 EDAS</a></li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>本文主要对 EDAS 涉及的专有名词及术语进行定义和解释，方便您更好地理解相关概念并使用 EDAS。</p>
<ul>
<li><p>Alibaba Cloud Toolkit</p>
<p><a href="https://help.aliyun.com/document_detail/29968.htm#concept-29968-zh">阿里云开发者插件（Alibaba Cloud Toolkit）</a>是一个面向 IntelliJ IDEA、Eclipse 和 Maven 平台的免费插件，旨在帮助开发者在本地开发平台（IDE）中更便捷的使用阿里云，从而高效地开发、测试、诊断并部署应用。</p>
</li>
<li><p>Ali-Tomcat</p>
<p>Ali-Tomcat 是基于 Apache Tomcat 改造的 Servlet 容器。在支持原有核心功能的前提下，Ali-Tomcat 在启动时会自动加载 Pandora 容器以实现了类隔离功能。</p>
</li>
<li><p>CPU 共享比例</p>
<p>CPU 共享是一种在 Docker 化技术中提升单机资源使用率的方法。例如对于一台2核8G的机器宿主机，如果选择 CPU 共享比例为1:2，那么可以在此宿主机上最多分配出四个1核 2G 的 Docker 实例；以此类推，选择1:4，则可以最多分配出八个1核 1G 的 Docker 实例。请注意，无论如何，内存都是独享的，无法共享。</p>
</li>
<li><p>Dubbo</p>
<p>Dubbo 是一个开源的分布式服务框架，提供高性能和透明化的 RPC 远程服务调用方案。</p>
</li>
<li><p>ECS</p>
<p><a href="https://help.aliyun.com/document_detail/25367.htm#EcsWelcome">云服务器 ECS（Elastic Compute Service）</a>是一种简单高效、处理能力可弹性伸缩的计算服务。帮助您快速构建更稳定、安全的应用。</p>
</li>
<li><p>EDAS</p>
<p>企业级分布式应用服务 EDAS（Enterprise Distributed Application Service）是一个应用托管和微服务管理的 PaaS 平台，提供应用开发、部署、监控、运维等全栈式解决方案，同时支持 Dubbo、Spring Cloud 等微服务运行环境，助力您的各类应用轻松上云。</p>
</li>
<li><p>EDAS Agent</p>
<p>EDAS Agent 是安装在用户 ECS 上的 Daemon 程序，主要用于 EDAS 服务集群与部署在相应的 ECS 上的应用程序之间进行通信。在运行的过程中主要承担应用管理、状态回报、信息获取等功能；同时也是 EDAS 控制台与用户应用程序之间信息沟通的主要桥梁。</p>
</li>
<li><p>EDAS Container</p>
<p>EDAS Container 是 EDAS 平台 HSF 应用运行的基础容器，EDAS Container 包含 Ali-Tomcat 和 Pandora。</p>
</li>
<li><p>K8S Namespace</p>
<p>K8S Namespace 通过将系统内部的对象分配到不同的 Namespace 中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群资源的同时还能被分别管理。</p>
</li>
<li><p>Pandora</p>
<p>Pandora 是一个轻量级的隔离容器，也就是 taobao-hsf.sar。它用来隔离应用和中间件、中间件之间的依赖，使其互不影响。EDAS 的 Pandora 中集成了实现服务发现的插件、实现配置推送的插件、实现调用链跟踪的插件等各种中间件产品插件。利用这些插件可以完成对 EDAS 应用的服务监控、治理、跟踪、分析等全方位运维管理。</p>
</li>
<li><p>Pandora Boot</p>
<p>Pandora Boot 是在 Pandora 的基础之上，发展出的更轻量使用 Pandora 的方式。基于 Pandora 和 FatJar 技术，可以直接在 IDE 里启动 Pandora 环境。</p>
</li>
<li><p>Pod</p>
<p>Pod 是 Kubernetes 中最小的部署单元和计费单位，根据应用场景，可以由一个或多个容器组成。当一个 Pod 中有多个容器时，这些容器会共享 Pod 的计算资源、存储空间、IP 和端口。对于计算资源还可以限制各个容器使用的比例。</p>
</li>
<li><p>SLB</p>
<p><a href="https://help.aliyun.com/document_detail/27539.htm#concept-whs-lp4-tdb">负载均衡 SLB（Server Load Balancer）</a>是对多台应用实例进行流量分发的负载均衡服务。可以通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性。</p>
</li>
<li><p>VPC</p>
<p><a href="https://help.aliyun.com/document_detail/34217.htm#concept-kbk-cpz-ndb">专有网络 VPC（Virtual Private Cloud）</a>是基于阿里云创建的自定义私有网络。不同的专有网络之间二层逻辑隔离，您可以在自己创建的专有网络内创建和管理云产品实例，比如 ECS、负载均衡、RDS 等。</p>
</li>
<li><p>变更流程</p>
<p>在 EDAS 上进行应用部署、启动、扩容/缩容等生命周期操作时，应用变更记录将整个变更过程中执行的业务逻辑抽象成为一个流程（Process），以可视化的方式展现。</p>
</li>
<li><p>持续集成</p>
<p>一种软件开发实践，通过该实践，开发人员定期将代码更改并入中央存储库，然后运行自动化构建和测试。</p>
</li>
<li><p>方法追踪</p>
<p>采用 JVM 字节码增强的技术，对选中方法中的所有方法调用增加必要的耗时与调用序列记录，以便观看执行过程中的具体执行序列。</p>
</li>
<li><p>调用链查询</p>
<p>调用链查询用于查看系统中的调用链路状态，尤其是慢业务和出错业务。</p>
</li>
<li><p>分布式链路跟踪</p>
<p>EDAS 鹰眼监控系统能够分析分布式系统的每一次系统调用、消息发送和数据库访问，从而精准发现系统的瓶颈和隐患。</p>
</li>
<li><p>分布式任务管理</p>
<p>SchedulerX 是阿里巴巴中间件团队开发的一款分布式任务调度产品。用户在应用中依赖 SchedulerX-Client，并在 SchedulerX 控制台创建定时任务，进行相应的参数配置后，启动该应用就可以接收到定时任务的周期调度。SchedulerX-Server 集群为调度触发提供高可用性和高稳定性的保证，并且可以实现对用户客户端机器集群进行分布式调度。</p>
</li>
<li><p>付费账号</p>
<p>付费账号是指用于购买 EDAS 产品的账号。一个付费账号可以绑定（最多5个）主账号，付费账号同时也是一个主账号。</p>
</li>
<li><p>服务报表</p>
<p>以租户维度展示当前租户内所有应用的所有服务在近 24 小时内的运行时情况，包括服务调用量、调用耗时和调用出错次数。</p>
</li>
<li><p>服务查询</p>
<p>服务查询用于查询目标机器提供的或者消费的服务。</p>
</li>
<li><p>服务监控</p>
<p>能够针对应用的服务调用情况，对服务的 QPS、响应时间和出错率进行全方面的监控。</p>
</li>
<li><p>服务降级</p>
<p>与服务限流相反，每一个应用会调用许多外部服务，对于这些服务配置降级规则可以实现对劣质服务的精准屏蔽，确保应用自身能够稳定运行，防止劣质的服务依赖影响应用自身的服务能力。EDAS 从响应时间维度对降级规则进行配置，帮助您在应对流量高峰时合理地屏蔽劣质依赖。</p>
</li>
<li><p>服务限流</p>
<p>EDAS 可以对每一个应用提供的众多服务配置限流规则，以实现对服务的流控，确保服务能够稳定运行。限流规则可以从 QPS 和线程两个维度进行配置，帮助您在应对流量高峰时，确保系统能以最大的支撑能力平稳运行。</p>
</li>
<li><p>服务拓扑</p>
<p>通过拓扑图的形式直观的了解不同服务间的相互调用关系及相关性能数据。</p>
</li>
<li><p>高速服务框架</p>
<p>高速服务框架 HSF（High-speed Service Framework）是一款面向企业级互联网架构的分布式服务框架，以高性能网络通信框架为基础，提供了诸如服务发布与注册、服务调用、服务路由、服务鉴权、服务限流、服务降级和服务调用链路跟踪等一系列功能特性。</p>
</li>
<li><p>健康检查</p>
<p>健康检查对容器与应用进行定时检查和汇报，然后将结果上报到控制台，从而帮助您了解集群环境下整个应用的运行状态，排查和定位问题。</p>
</li>
<li><p>基础监控</p>
<p>EDAS 从应用所运行的实例（ECS）上采集数据，对机器的 CPU、内存、负载、网络和磁盘等基础指标进行详细的监控。所有监控均以应用为单位进行数据的统计和处理。</p>
</li>
<li><p>集群</p>
<p>集群指应用运行所需的云资源组合。ECS 集群：ECS 集群中，在一台独立的 ECS 实例上仅允许部署一个应用。Swarm 集群（即将下线，新用户不可创建及使用）：Swarm 是 Docker 公司发布的容器管理工具。Swarm 集群中，在一台独立的 ECS 实例上可以创建多个 Docker 实例，每一个 Docker 实例上允许部署一个应用。容器服务 K8S 集群：通过了 CNCF 标准化测试的 Kubernetes 集群，运行稳定且集成了阿里云其它产品（如 SLB、NAS）。在容器服务中创建 Kubernetes 集群并导入 EDAS 后，您就具备了在 EDAS 中向容器服务 Kubernetes 集群部署应用的能力。</p>
</li>
<li><p>命名空间</p>
<p>命名空间实现资源和服务的隔离。您可以使用命名空间隔离不同环境，如开发、测试和生产环境，以避免影响不同环境下的服务调用和配置推送。</p>
</li>
<li><p>批量运维</p>
<p>在 EDAS 控制台中，可以使用机器指令对安装了 Agent 的 ECS 实例进行批量运维操作。可以按集群、应用和实例批量执行命令，解决多个实例重复运维的烦恼。</p>
</li>
<li><p>轻量级配置及注册中心</p>
<p>一个可以在本地运行的 EDAS 轻量级配置及注册中心，提供服务发现和配置管理功能。</p>
</li>
<li><p>日志采集器</p>
<p>采集系统监控日志用来生成监控数据以及调用链信息的组件。在 VPC 网络中，机器天然与服务器隔离，日志采集器可以打通服务器和本地机器的连接通道。安装一个日志采集器即可采集整个 VPC 里所有机器的数据。</p>
</li>
<li><p>实时日志</p>
<p>实时日志是针对 Docker 容器的一种标准输出的运行时日志。</p>
</li>
<li><p>弹性伸缩</p>
<p>弹性伸缩功能可以感知集群内各个服务器的状态（CPU、RT 和 Load），并根据状态实时实现集群扩容、缩容，在保证服务质量的同时，提升集群系统的可用率。</p>
</li>
<li><p>应用实时监控服务</p>
<p><a href="https://help.aliyun.com/document_detail/42781.htm#concept-42781-zh">应用实时监控服务 ARMS（Application Real-Time Monitoring Service）</a>是一款阿里云应用性能管理（APM）类监控产品。借助 ARMS 可以迅速便捷地为企业构建秒级响应的应用监控能力。</p>
</li>
<li><p>应用监控</p>
<p>用于监控应用的实时流量和历史信息，用户可以通过该信息监控应用的健康状态，从而快速发现、定位问题。</p>
</li>
<li><p>应用配置管理</p>
<p><a href="https://help.aliyun.com/document_detail/59953.htm#concept-y4m-zgv-m2b">应用配置管理 ACM（Application Configuration Management）</a>是一款在分布式架构环境中对应用配置进行集中管理和推送的工具类产品。您可以在 EDAS 中使用 ACM 对应用配置进行集中管理和推送，还可以基于命名空间在不同环境间进行配置的隔离和同步。</p>
</li>
<li><p>应用生命周期</p>
<p>应用是 EDAS 管理的基本单位，一个应用下面通常包含了多个实例。EDAS 提供了完整的应用生命周期管理机制，可以完成应用从发布到运行过程的全面管理，包括应用创建、部署、启动、回滚，扩容缩容和停止下线等操作。</p>
</li>
<li><p>应用实例</p>
<p>应用实例是指用来部署应用的 ECS 实例或者容器实例。比如在 ECS 集群里，一台 ECS 里只有一个应用实例；在 K8S 集群里，一个 Pod 是一个应用实例。</p>
</li>
<li><p>应用实例分组</p>
<p>将一个应用下属所有实例（ECS）进行分组，以便对不同分组中的实例部署不同版本的应用。EDAS 应用实例分组提供应用内实例的分组管理功能。用户可以实现 Beta 发布、AB 测试，灰度发布等运维方式。支持用户从分组角度实现应用生命周期管理、资源监控与告警，可以迅速提升运维效率。</p>
</li>
<li><p>应用运行环境</p>
<p>应用运行的环境，例如 HSF 应用的运行环境 EDAS-Container 或开源应用的运行容器（如 Apache Tomcat）。</p>
</li>
<li><p>应用诊断</p>
<p>EDAS 针对应用提供了详细的问题排查和性能分析，包括提供当前应用运行的单机上的 JVM 堆／非堆内存、类加载（Class Loader）、线程、Tomcat 连接器的统计数据以及方法追踪等。</p>
</li>
<li><p>云服务总线</p>
<p><a href="https://help.aliyun.com/document_detail/161281.htm#concept-268596">云服务总线 CSB（Cloud Service Bus）</a>面向专有云和专有域，帮助企业在自己的多个系统之间，或者与合作伙伴以及第三方的系统之间实现跨系统跨协议的服务能力互通。在 EDAS 中创建 CSB 专享实例，用来管理和控制目标环境内应用对外的服务开放，也可以引入外部服务并进行管理控制；开放 VPC 内的 EDAS 应用，用于在自有开发环境通过公网来测试联调阿里云 VPC 内的 EDAS 应用。</p>
</li>
<li><p>资源组</p>
<p>EDAS 对资源的一种划分方式。资源组可以绑定 ECS、集群和 SLB。您的主账号可以基于资源组对子账号进行授权。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>EDAS K8s 应用托管</title>
    <url>/articles/Java-Framework-EDAS-K8s.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>EDAS 支持以容器的形式托管应用到阿里云 Kubernetes 集群或混合云集群（其他云域或 IDC 内自建 Kubernetes 集群），用户无需理解容器服务底层细节，便可以低门槛拥抱容器技术，最大化地利用资源并完成应用在容器里的全生命周期管理，以及监控、运维等服务。</p>
<p>本文介绍 K8s 环境支持的应用类型和应用托管功能。</p>
<span id="more"></span>

<h1 id="K8s-应用托管概述"><a href="#K8s-应用托管概述" class="headerlink" title="K8s 应用托管概述"></a>K8s 应用托管概述</h1><h2 id="K8s-环境类型"><a href="#K8s-环境类型" class="headerlink" title="K8s 环境类型"></a>K8s 环境类型</h2><p>EDAS 不仅支持在阿里云上使用 Kubernetes 管理容器应用，也支持使用在混合云集群（其他云域或 IDC 内自建 Kubernetes 集群）管理容器应用。</p>
<p>![EDAS支持的K8s集群类型](Java-Framework-EDAS-K8s/EDAS 支持的类型.png)</p>
<ul>
<li><p>阿里云 Kubernetes 集群</p>
<p>EDAS 无缝对接阿里云容器服务 Kubernetes 版，支持导入在容器服务 Kubernetes 版控制台创建的专有版 Kubernetes 集群、托管版 Kubernetes 集群和 Serverless Kubernetes 集群。</p>
</li>
<li><p>混合云集群（其他云域或 IDC 内自建 Kubernetes 集群）</p>
<p>在日常运维过程中，存在同时在云上和 IDC 里拥有多个 Kubernetes 集群，或者同时拥有多个云域上的 Kubernetes 集群的情况。在这种现状下，您可以将这些集群注册到 ACK 控制台，然后再导入到 EDAS。</p>
</li>
</ul>
<p><strong>说明</strong></p>
<p>混合云集群、专有版和托管版 Kubernetes 集群导入到 EDAS 中对应的是容器服务 K8s 集群；Serverless Kubernetes 集群导入到 EDAS 中对应的是 Serverless K8s 集群。</p>
<p>更多阿里云 Kubernetes 集群和混合云集群的相关信息，请参见<a href="https://help.aliyun.com/document_detail/198257.htm#section-9r3-hql-7ag">集群纳管</a>。</p>
<h2 id="K8s-环境支持的应用类型"><a href="#K8s-环境支持的应用类型" class="headerlink" title="K8s 环境支持的应用类型"></a>K8s 环境支持的应用类型</h2><p>EDAS 支持以容器的形式托管 Java 应用、PHP 应用以及多语言（包含 Node.js、Go 和 Python 等多种语言）应用。</p>
<p>![EDAS支持的托管应用类型](Java-Framework-EDAS-K8s/EDAS 支持的托管应用类型.png)</p>
<ul>
<li>Java：支持 JAR 包、WAR 包以及镜像部署，不同的部署方式需选择的应用运行环境也会有所不同。</li>
<li>PHP：支持从源码构建 PHP 应用并托管到 EDAS。</li>
<li>多语言：支持使用自定义的镜像将多语言应用托管到 EDAS。</li>
</ul>
<p>更多托管应用类型的部署方式以及运行环境的信息，请参见<a href="https://help.aliyun.com/document_detail/200124.htm#concept-2019522">创建和部署应用概述（K8s）</a>。</p>
<h2 id="K8s-环境支持的应用托管功能"><a href="#K8s-环境支持的应用托管功能" class="headerlink" title="K8s 环境支持的应用托管功能"></a>K8s 环境支持的应用托管功能</h2><p>您可以将应用托管到阿里云 Kubernetes 集群和混合云集群（其他云域或 IDC 内自建 Kubernetes 集群），并使用 EDAS 为您提供的一系列应用托管能力，包括资源管理、应用部署、CI/CD、应用监控和应用运维等能力。</p>
<p>![EDAS支持的功能](Java-Framework-EDAS-K8s/EDAS 支持的应用托管功能.png)</p>
<table>
<thead>
<tr>
<th align="left">使用场景</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">资源管理</td>
<td align="left">EDAS 是面向应用的 PaaS 平台，为应用提供 ECS 和 K8s 环境及相关资源。EDAS 的 K8s 环境中主要包含命名空间和集群纳管的资源管理功能。更多信息，请参见 <a href="https://help.aliyun.com/document_detail/198257.htm#concept-2019627">K8s 资源管理概述</a>。</td>
</tr>
<tr>
<td align="left">应用部署</td>
<td align="left">创建和部署（首次部署）：完成应用开发和测试后，您可以在 Kubernetes 集群中创建并部署应用。更多信息，请参见<a href="https://help.aliyun.com/document_detail/200124.htm#concept-2019522">创建和部署应用概述（K8s）</a>。升级和回滚：应用在 EDAS 中创建并部署后，还会不断迭代，需要升级。如果升级的应用版本发现问题，需要将应用回滚到历史版本。更多信息，请参见<a href="https://help.aliyun.com/document_detail/200708.htm#concept-2024194">升级和回滚应用概述（K8s）</a>。</td>
</tr>
<tr>
<td align="left">CI/CD</td>
<td align="left">应用在不断迭代过程中，需要持续集成（CI）和持续部署（CD）。EDAS 支持通过 <a href="https://www.jenkins.io/">Jenkins</a> 和<a href="https://www.aliyun.com/product/yunxiao">云效</a>对您部署的应用进行 CI/CD。具体操作，请参见 <a href="https://help.aliyun.com/document_detail/200023.htm#concept-2019628">CI/CD概述（K8s）</a>。</td>
</tr>
<tr>
<td align="left">应用监控</td>
<td align="left">EDAS 集成了应用实时监控服务 ARMS，为部署在 EDAS 中的应用提供关键指标的监控能力和报警能力。更多信息，请参见<a href="https://help.aliyun.com/document_detail/200370.htm#concept-2019630">应用监控概述</a>。</td>
</tr>
<tr>
<td align="left">应用运维</td>
<td align="left">EDAS 为应用提供了一系列运维功能，包括负载均衡、应用扩缩容、限流降级、变更记录、事件中心、日志管理等。更多信息，请参见<a href="https://help.aliyun.com/document_detail/200709.htm#concept-2024553">应用运维概述</a>。</td>
</tr>
</tbody></table>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="K8s-资源管理概述"><a href="#K8s-资源管理概述" class="headerlink" title="K8s 资源管理概述"></a>K8s 资源管理概述</h2><p>EDAS 不仅支持使用阿里云 Kubernetes 集群管理容器应用，也支持使用混合云集群（其他云域或 IDC 内自建集群）管理容器应用。如果您对应用的运行环境有安全隔离的需求，可以创建并使用微服务空间，实现资源和服务的隔离。</p>
<h2 id="微服务空间"><a href="#微服务空间" class="headerlink" title="微服务空间"></a>微服务空间</h2><p>微服务空间为应用提供互相隔离的运行环境，如开发、测试和生产环境等，您可以使用微服务空间实现资源和服务的隔离。</p>
<p>EDAS 默认提供一个默认微服务空间，也支持自建微服务空间。</p>
<h2 id="集群纳管"><a href="#集群纳管" class="headerlink" title="集群纳管"></a>集群纳管</h2><p>EDAS 不仅支持使用阿里云 Kubernetes 集群管理容器应用，也支持使用混合云集群（其他云域或IDC内自建集群）管理容器应用。您只需要将 K8s 集群导入到 EDAS 控制台，无需其他复杂操作，便可以直接托管应用到 K8s 集群。</p>
<p>EDAS 不提供创建 K8s 集群的跳转入口，您需要到<a href="https://cs.console.aliyun.com/">容器服务管理控制台</a>创建阿里云集群或者注册混合云集群，容器服务通过将 Kubernetes 网络和阿里云 VPC 的深度集成，提供了稳定高性能的容器网络，不同 VPC 逻辑上完全隔离。</p>
<ul>
<li><p>阿里云 Kubernetes 集群</p>
<p>EDAS 无缝对接阿里云容器服务 Kubernetes 版，支持导入在容器服务 Kubernetes 版控制台创建的专有版 Kubernetes 集群、托管版 Kubernetes 集群和 Serverless Kubernetes 集群。3 种集群形态的对比详情，请参见<a href="https://help.aliyun.com/document_detail/86737.htm#concept-cbm-1zc-l2b">什么是容器服务Kubernetes版</a>。</p>
<ul>
<li>创建专有版 Kubernetes 集群的具体操作，请参见<a href="https://help.aliyun.com/document_detail/86488.htm#task-skz-qwk-qfb">创建Kubernetes专有版集群</a>。</li>
<li>创建托管版 Kubernetes 集群的具体操作，请参见<a href="https://help.aliyun.com/document_detail/95108.htm#task-skz-qwk-qfb">创建Kubernetes托管版集群</a>。</li>
<li>创建 Serverless Kubernetes 集群的具体操作，请参见<a href="https://help.aliyun.com/document_detail/186945.htm#task-e3c-311-ydb">创建Serverless Kubernetes集群</a>。</li>
</ul>
<p>专有版 Kubernetes 集群和托管版 Kubernetes 集群导入到 EDAS 中对应的是容器服务 K8s 集群，Serverless Kubernetes 集群导入到 EDAS 中对应的是 Serverless K8s 集群。</p>
</li>
<li><p>混合云集群</p>
<p>在日常运维过程中，存在同时在云上和 IDC 里拥有多个 Kubernetes 集群，同时拥有多个云上的 Kubernetes 集群的情况。在这种现状下，您可以将这些集群注册到容器服务 Kubernetes 版控制台，实现统一的安全治理、应用管理和监控、日志等能力，降低运维成本。</p>
<p>注册外部集群到 ACK 控制台的具体操作，请参见<a href="https://help.aliyun.com/document_detail/121053.htm#task-skz-qwk-qfb">创建注册集群并接入本地数据中心集群</a>。</p>
<p>混合云集群导入到 EDAS 对应的是容器服务 K8s 集群。</p>
</li>
</ul>
<blockquote>
<p><strong>说明</strong> 在阿里云 Kubernetes 集群或混合云集群托管应用原理类似，都是将应用托管到一个 Pod 或一组 Pod。</p>
</blockquote>
<h2 id="管理命名空间"><a href="#管理命名空间" class="headerlink" title="管理命名空间"></a>管理命名空间</h2><h3 id="使用控制台管理微服务空间"><a href="#使用控制台管理微服务空间" class="headerlink" title="使用控制台管理微服务空间"></a><a href="https://help.aliyun.com/document_detail/172140.html?spm=a2c4g.11186623.6.586.505b2172LtorTY">使用控制台管理微服务空间</a></h3><h3 id="使用-API-管理微服务空间"><a href="#使用-API-管理微服务空间" class="headerlink" title="使用 API 管理微服务空间"></a><a href="https://help.aliyun.com/document_detail/212424.html?spm=a2c4g.11186623.6.587.1eb69bbbcA00aB">使用 API 管理微服务空间</a></h3><h2 id="K8s-集群管理"><a href="#K8s-集群管理" class="headerlink" title="K8s 集群管理"></a>K8s 集群管理</h2><h3 id="使用控制台管理-K8s-集群"><a href="#使用控制台管理-K8s-集群" class="headerlink" title="使用控制台管理 K8s 集群"></a><a href="https://help.aliyun.com/document_detail/84445.html?spm=a2c4g.11186623.6.589.d5c015029m5K7c">使用控制台管理 K8s 集群</a></h3><h3 id="使用-API-管理-K8s-集群"><a href="#使用-API-管理-K8s-集群" class="headerlink" title="使用 API 管理 K8s 集群"></a><a href="https://help.aliyun.com/document_detail/212451.html?spm=a2c4g.11186623.6.590.54704574zk4gTo">使用 API 管理 K8s 集群</a></h3><h1 id="创建和部署-K8s-应用"><a href="#创建和部署-K8s-应用" class="headerlink" title="创建和部署 K8s 应用"></a>创建和部署 K8s 应用</h1><h2 id="创建和部署-K8s-应用概述"><a href="#创建和部署-K8s-应用概述" class="headerlink" title="创建和部署 K8s 应用概述"></a>创建和部署 K8s 应用概述</h2><p>EDAS 支持使用 ECS 环境和 K8s 环境托管应用，当您选择 K8s 环境托管应用时，EDAS 支持托管 Java 应用、PHP 应用以及多语言（包含 Node.js、Go 和 Python 等多种语言）应用。本文介绍不同应用类型所支持的部署方式。</p>
<h3 id="Java-应用"><a href="#Java-应用" class="headerlink" title="Java 应用"></a>Java 应用</h3><p>Spring Cloud、Dubbo 或 HSF 应用开发完成后，可通过 WAR 包、JAR 包或镜像的方式部署至 K8s 集群。</p>
<table>
<thead>
<tr>
<th align="left">部署方式</th>
<th align="left">介绍</th>
<th align="left">运行环境</th>
<th align="left">监控及治理方案</th>
<th align="left">示例文档</th>
</tr>
</thead>
<tbody><tr>
<td align="left">镜像部署</td>
<td align="left">适用于在 K8s 集群中使用自定义的镜像部署应用。</td>
<td align="left">自定义</td>
<td align="left">默认自动挂载 Java Agent 进行精细化监控，并提供完整微服务治理方案（金丝雀发布、服务鉴权、限流降级等）。</td>
<td align="left"><a href="https://help.aliyun.com/document_detail/157324.htm#task-tu6-g7m-khn">在容器服务 K8s 集群中使用镜像方式部署应用</a></td>
</tr>
<tr>
<td align="left">JAR 包部署</td>
<td align="left">适用于 Dubbo 和 Spring Boot 应用。</td>
<td align="left">Java</td>
<td align="left"><a href="https://help.aliyun.com/document_detail/158047.htm#task-5976">在容器服务 K8s 集群中使用 JAR 包或 WAR 包部署应用</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">WAR 包部署</td>
<td align="left">适用于 Dubbo 和 Spring 应用。</td>
<td align="left">Java、Apache</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">WAR 包或者 FatJar 包部署</td>
<td align="left">适用于部署 HSF 应用。</td>
<td align="left">EDAS-Container</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明</strong> 如果您想在 K8S 环境中同时创建多个 Java 应用，可以调用 InsertK8sApplication 接口创建应用。更多信息，请参见<a href="https://help.aliyun.com/document_detail/85029.htm#doc-api-Edas-InsertK8sApplication">InsertK8sApplication</a>。</p>
</blockquote>
<h3 id="PHP-应用"><a href="#PHP-应用" class="headerlink" title="PHP 应用"></a>PHP 应用</h3><p>目前支持从源码构建 PHP 应用并托管到 EDAS。在部署应用时，需要选择 PHP 版本，EDAS 提供了 PHP 7.3/Apache/Centos 7 运行环境，该运行环境内已经安装了常用的 PHP 插件。</p>
<p>部署 PHP 应用时默认自动挂载 PHP Agent 进行精细化监控，并通过 Istio（Service Mesh）提供完整微服务治理方案（金丝雀发布、服务鉴权、限流降级等）。</p>
<p>示例文档：<a href="https://help.aliyun.com/document_detail/172463.htm#task-2552889">从源码构建PHP应用并部署至容器服务K8s集群</a></p>
<h3 id="多语言应用"><a href="#多语言应用" class="headerlink" title="多语言应用"></a>多语言应用</h3><p>目前支持使用自定义的镜像将多语言应用托管到 EDAS。</p>
<p>部署多语言应用时通过 Istio（Service Mesh）提供完整微服务治理方案（金丝雀发布、服务鉴权、限流降级等）。</p>
<p>示例文档：<a href="https://help.aliyun.com/document_detail/184500.htm#task-2552889">使用自定义镜像部署多语言应用至K8s集群</a>。</p>
<blockquote>
<p><strong>说明</strong> 如果您想同时在 K8s 环境中创建多个多语言应用，可以调用 InsertK8sApplication 接口创建应用。更多信息，请参见<a href="https://help.aliyun.com/document_detail/85029.htm#doc-api-Edas-InsertK8sApplication">InsertK8sApplication</a>。</p>
</blockquote>
<h2 id="Java-应用-1"><a href="#Java-应用-1" class="headerlink" title="Java 应用"></a>Java 应用</h2><h3 id="JAR-包或-WAR-包部署"><a href="#JAR-包或-WAR-包部署" class="headerlink" title="JAR 包或 WAR 包部署"></a>JAR 包或 WAR 包部署</h3><ul>
<li><p><a href="https://help.aliyun.com/document_detail/158047.html?spm=a2c4g.11186623.6.595.1b134ec0q1V3TP">在容器服务 K8s 集群中使用 JAR 包或 WAR 包部署应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/172591.html?spm=a2c4g.11186623.6.596.53762a48wjl79e">在 Serverless K8s 集群中使用 JAR 包或 WAR 包部署应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/212268.html?spm=a2c4g.11186623.2.34.1a686215HJRc9o">使用 API 在 K8s 集群中创建 Java 应用（JAR 包或 WAR 包）</a></p>
</li>
</ul>
<h3 id="镜像部署"><a href="#镜像部署" class="headerlink" title="镜像部署"></a>镜像部署</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/84095.html?spm=a2c4g.11186623.6.599.3d024d98RLHWjJ">制作应用镜像</a></li>
<li><a href="https://help.aliyun.com/document_detail/157324.html?spm=a2c4g.11186623.6.600.5e4012d8OdEb8o">在容器服务 K8s 集群中使用镜像方式部署 Java 应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/172576.html?spm=a2c4g.11186623.6.601.492a7c717sfI5e">在 Serverless K8s 集群中使用镜像方式部署应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/212280.html?spm=a2c4g.11186623.6.602.2618594dBgZZe5">使用 API 在 K8s 集群中创建 Java 应用（镜像）</a></li>
</ul>
<h3 id="转化-Deployment-为-EDAS-应用"><a href="#转化-Deployment-为-EDAS-应用" class="headerlink" title="转化 Deployment 为 EDAS 应用"></a>转化 Deployment 为 EDAS 应用</h3><ul>
<li><a href="https://help.aliyun.com/document_detail/202036.html?spm=a2c4g.11186623.6.604.2e8367b78deXSq">使用控制台转化 Deployment 为 EDAS 应用</a></li>
</ul>
<h2 id="PHP-应用-1"><a href="#PHP-应用-1" class="headerlink" title="PHP 应用"></a>PHP 应用</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/172463.html?spm=a2c4g.11186623.6.606.2535210cTh3dz8">从源码构建 PHP 应用并部署至容器服务 K8s 集群</a></li>
<li><a href="https://help.aliyun.com/document_detail/172449.html?spm=a2c4g.11186623.6.607.345c7df4E3YBxN">如何在使用源码部署应用时配置 SSH 公钥</a></li>
</ul>
<h2 id="多语言应用-1"><a href="#多语言应用-1" class="headerlink" title="多语言应用"></a>多语言应用</h2><ul>
<li><p><a href="https://help.aliyun.com/document_detail/126680.html?spm=a2c4g.11186623.6.609.57f7442cW3r6Pi">部署多语言微服务应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/212305.html?spm=a2c4g.11186623.6.610.3c76488bxAtT6y">使用 API 在 K8s 集群中创建多语言应用</a></p>
</li>
</ul>
<h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/180807.html?spm=a2c4g.11186623.6.612.7cc05456qF60MS">配置调度规则</a></li>
<li><a href="https://help.aliyun.com/document_detail/176955.html?spm=a2c4g.11186623.6.613.35a5cb25YXdN9M">配置启动命令</a></li>
<li><a href="https://help.aliyun.com/document_detail/176962.html?spm=a2c4g.11186623.6.614.72cf482bWxgU75">配置环境变量</a></li>
<li><a href="https://help.aliyun.com/document_detail/177410.html?spm=a2c4g.11186623.6.615.51c1736cMeYZ2R">配置持久化存储</a></li>
<li><a href="https://help.aliyun.com/document_detail/178866.html?spm=a2c4g.11186623.6.616.344d5038PSnsp9">配置本地存储</a></li>
<li><a href="https://help.aliyun.com/document_detail/177589.html?spm=a2c4g.11186623.6.617.576c6762W1jPoJ">配置应用生命周期的钩子和探针</a></li>
<li><a href="https://help.aliyun.com/document_detail/178953.html?spm=a2c4g.11186623.6.618.90692b7djGT4hc">配置日志收集</a></li>
<li><a href="https://help.aliyun.com/document_detail/179323.html?spm=a2c4g.11186623.6.619.390b5030P2C8py">配置 Tomcat</a></li>
<li><a href="https://help.aliyun.com/document_detail/180747.html?spm=a2c4g.11186623.6.620.18ba4060LY7RUK">配置 Java 启动参数</a></li>
<li><a href="https://help.aliyun.com/document_detail/213726.html?spm=a2c4g.11186623.6.621.7b43e97emQbCBi">配置挂载</a></li>
<li><a href="https://help.aliyun.com/document_detail/170030.html?spm=a2c4g.11186623.6.622.30d42675hOL1fP">配置同可用区优先路由</a></li>
<li><a href="https://help.aliyun.com/document_detail/181116.html?spm=a2c4g.11186623.6.623.3d717df8RoXy1K">实现 K8s 集群应用的限流降级</a></li>
</ul>
<h1 id="升级和回滚-K8s-应用"><a href="#升级和回滚-K8s-应用" class="headerlink" title="升级和回滚 K8s 应用"></a>升级和回滚 K8s 应用</h1><h2 id="升级和回滚-K8s-应用概述"><a href="#升级和回滚-K8s-应用概述" class="headerlink" title="升级和回滚 K8s 应用概述"></a><a href="https://help.aliyun.com/document_detail/200708.html?spm=a2c4g.11186623.6.625.24d543c5caAlDf">升级和回滚 K8s 应用概述</a></h2><h2 id="K8s-单批发布"><a href="#K8s-单批发布" class="headerlink" title="K8s 单批发布"></a>K8s 单批发布</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/200710.html?spm=a2c4g.11186623.6.627.250043c5wwhRGp">使用控制台单批发布应用（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/212311.html?spm=a2c4g.11186623.6.628.54fb195f4cqfMB">使用 API 在 K8s 集群中单批发布应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/128271.html?spm=a2c4g.11186623.6.629.63c24542za4K3X">使用 Cloud Toolkit 插件单批发布应用（K8s）</a></li>
</ul>
<h2 id="K8s-分批发布"><a href="#K8s-分批发布" class="headerlink" title="K8s 分批发布"></a>K8s 分批发布</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/114499.html?spm=a2c4g.11186623.6.631.6e1156f7WuwC2z">使用控制台分批发布应用（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/212327.html?spm=a2c4g.11186623.6.632.6bd57bdan9fBgL">使用 API 在 K8s 集群中分批发布应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/142405.html?spm=a2c4g.11186623.6.633.edab36d7NYiZ3i">使用 Toolkit-maven-plugin 插件分批发布应用（K8s）</a></li>
</ul>
<h2 id="K8s-金丝雀发布"><a href="#K8s-金丝雀发布" class="headerlink" title="K8s 金丝雀发布"></a>K8s 金丝雀发布</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/150111.html?spm=a2c4g.11186623.6.635.1e217f74jNIMOe">使用控制台金丝雀发布应用（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/212379.html?spm=a2c4g.11186623.6.636.768a121cHxvPGa">使用 API 在 K8s 集群中金丝雀发布应用</a></li>
</ul>
<h2 id="K8s-回滚应用"><a href="#K8s-回滚应用" class="headerlink" title="K8s 回滚应用"></a>K8s 回滚应用</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/200981.html?spm=a2c4g.11186623.6.638.2f37254bB1CRts">使用控制台回滚应用（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/212406.html?spm=a2c4g.11186623.6.639.6fb34a23OQ4cbi">使用 API 在 K8s 集群中回滚应用到目标历史版本</a></li>
<li><a href="https://help.aliyun.com/document_detail/212419.html?spm=a2c4g.11186623.6.640.4d21484czwBCP1">使用 API 在 K8s 集群中终止应用变更并回滚</a></li>
</ul>
<h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h1><h2 id="CI-CD-概述（K8s）"><a href="#CI-CD-概述（K8s）" class="headerlink" title="CI/CD 概述（K8s）"></a><a href="https://help.aliyun.com/document_detail/200023.html?spm=a2c4g.11186623.6.642.71c71a3cX61p0q">CI/CD 概述（K8s）</a></h2><h2 id="云效"><a href="#云效" class="headerlink" title="云效"></a>云效</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/178296.html?spm=a2c4g.11186623.6.644.2fc81308VFRuns">使用云效 2020 进行持续集成和部署（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/157223.html?spm=a2c4g.11186623.6.645.25977586Sl9p2n">使用云霄 2020 实现其他类型应用的持续集成和部署（K8s）</a></li>
</ul>
<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/199293.html?spm=a2c4g.11186623.6.647.73db2dcewsXp6l">使用 Jenkins 创建持续集成</a></li>
<li><a href="https://help.aliyun.com/document_detail/199555.html?spm=a2c4g.11186623.6.648.2e107de4dNt76v">在 Jenkins 中使用 EDAS 插件构建应用部署的任务</a></li>
<li><a href="https://help.aliyun.com/document_detail/199556.html?spm=a2c4g.11186623.6.649.673d44cb0iFY3Q">在 Jenkins 中使用 edas-jenkins-plugin 部署应用的参数配置</a></li>
</ul>
<h1 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h1><h2 id="应用监控概述"><a href="#应用监控概述" class="headerlink" title="应用监控概述"></a><a href="https://help.aliyun.com/document_detail/200370.html?spm=a2c4g.11186623.6.651.4a295bcdafLAwR">应用监控概述</a></h2><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/152394.html?spm=a2c4g.11186623.6.653.471063eb4nUiZg">查看应用总览</a></li>
<li><a href="https://help.aliyun.com/document_detail/183841.html?spm=a2c4g.11186623.6.654.6b7e215edTGwGT">应用故障自动诊断</a></li>
<li><a href="https://help.aliyun.com/document_detail/162978.html?spm=a2c4g.11186623.6.655.45c84198vCLwSh">查看 Prometheus 监控指标</a></li>
<li>应用实例监控<ul>
<li><a href="https://help.aliyun.com/document_detail/202697.html?spm=a2c4g.11186623.6.657.708e38b7gDeVTE">概览</a></li>
<li><a href="https://help.aliyun.com/document_detail/152400.html?spm=a2c4g.11186623.6.658.178538f2APOhBY">JVM 监控</a></li>
<li><a href="https://help.aliyun.com/document_detail/152401.html?spm=a2c4g.11186623.6.659.c64d1422q8rrPs">主机监控</a></li>
<li><a href="https://help.aliyun.com/document_detail/202706.html?spm=a2c4g.11186623.6.660.64dd736eRTdXdj">Pod 监控</a></li>
<li><a href="https://help.aliyun.com/document_detail/202707.html?spm=a2c4g.11186623.6.661.421f1427erB56C">SQL 调用分析</a></li>
<li><a href="https://help.aliyun.com/document_detail/202708.html?spm=a2c4g.11186623.6.662.1cad47b22k6vrR">NoSQL 调用分析</a></li>
<li><a href="https://help.aliyun.com/document_detail/202709.html?spm=a2c4g.11186623.6.663.76bb5285qeFrJP">异常分析</a></li>
<li><a href="https://help.aliyun.com/document_detail/202712.html?spm=a2c4g.11186623.6.664.57e23991rTLiYz">错误分析</a></li>
<li><a href="https://help.aliyun.com/document_detail/202713.html?spm=a2c4g.11186623.6.665.3dec65542A2Dum">上游应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/202714.html?spm=a2c4g.11186623.6.666.3b1e2b2fztRW6I">下游应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/202715.html?spm=a2c4g.11186623.6.667.461a5876d3UPS6">调用链查询</a></li>
<li><a href="https://help.aliyun.com/document_detail/202716.html?spm=a2c4g.11186623.6.668.199b589akb3HZL">日志</a></li>
<li><a href="https://help.aliyun.com/document_detail/152402.html?spm=a2c4g.11186623.6.669.43905ca6jt0k6r">内存快照</a></li>
</ul>
</li>
<li><a href="https://help.aliyun.com/document_detail/152403.html?spm=a2c4g.11186623.6.670.1f04713aBWsb9W">服务和接口监控</a></li>
<li><a href="https://help.aliyun.com/document_detail/162959.html?spm=a2c4g.11186623.6.671.50847e79RNcYnS">数据库调用监控</a></li>
<li><a href="https://help.aliyun.com/document_detail/257081.html?spm=a2c4g.11186623.6.672.604c16dbx5upjU">NoSQL 调用</a></li>
<li><a href="https://help.aliyun.com/document_detail/257080.html?spm=a2c4g.11186623.6.673.221e742fMHqxA3">外部调用</a></li>
<li><a href="https://help.aliyun.com/document_detail/257079.html?spm=a2c4g.11186623.6.674.5ff12a02XLlFMe">MQ 监控</a></li>
<li>应用诊断<ul>
<li><a href="https://help.aliyun.com/document_detail/152405.html?spm=a2c4g.11186623.6.676.293b422c27ZXAk">实时诊断</a></li>
<li><a href="https://help.aliyun.com/document_detail/153782.html?spm=a2c4g.11186623.6.677.1e286196fNzAMZ">异常分析</a></li>
<li><a href="https://help.aliyun.com/document_detail/153651.html?spm=a2c4g.11186623.6.678.67ef3991tfuwp5">线程分析</a></li>
<li><a href="https://help.aliyun.com/document_detail/209967.html?spm=a2c4g.11186623.6.679.3bee6f802IDjZ3">Arthas 诊断</a></li>
<li><a href="https://help.aliyun.com/document_detail/257078.html?spm=a2c4g.11186623.6.680.45ab45cdiIalGZ">日志分析</a></li>
</ul>
</li>
<li><a href="https://help.aliyun.com/document_detail/160314.html?spm=a2c4g.11186623.6.681.1fa424de5iABAy">高级监控</a></li>
<li><a href="https://help.aliyun.com/document_detail/257076.html?spm=a2c4g.11186623.6.682.28a52119U2S71m">应用环境</a></li>
<li>应用监控设置<ul>
<li><a href="https://help.aliyun.com/document_detail/254832.html?spm=a2c4g.11186623.6.684.16d848b3fpZwWT">自定义配置</a></li>
<li><a href="https://help.aliyun.com/document_detail/254833.html?spm=a2c4g.11186623.6.685.176a449c08bLbn">标签管理</a></li>
<li><a href="https://help.aliyun.com/document_detail/254834.html?spm=a2c4g.11186623.6.686.50eb67465Rz7Ea">监控方法自定义</a></li>
<li><a href="https://help.aliyun.com/document_detail/257077.html?spm=a2c4g.11186623.6.687.a81b6cb2ZuiSCk">自定义参数</a></li>
</ul>
</li>
</ul>
<h2 id="报警"><a href="#报警" class="headerlink" title="报警"></a>报警</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/176097.html?spm=a2c4g.11186623.6.689.4f0a71cdMsMMTX">创建联系人</a></li>
<li><a href="https://help.aliyun.com/document_detail/176098.html?spm=a2c4g.11186623.6.690.77a1595apufMHA">创建和管理联系人分组</a></li>
<li><a href="https://help.aliyun.com/document_detail/152409.html?spm=a2c4g.11186623.6.691.258f776b6S9WIQ">创建报警</a></li>
<li><a href="https://help.aliyun.com/document_detail/176096.html?spm=a2c4g.11186623.6.692.fbd33876y8SQZo">管理报警</a></li>
<li><a href="https://help.aliyun.com/document_detail/176099.html?spm=a2c4g.11186623.6.693.5ec17ed7v1odLk">设置钉钉机器人报警</a></li>
</ul>
<h1 id="应用运维"><a href="#应用运维" class="headerlink" title="应用运维"></a>应用运维</h1><h2 id="应用运维概述"><a href="#应用运维概述" class="headerlink" title="应用运维概述"></a><a href="https://help.aliyun.com/document_detail/200709.html?spm=a2c4g.11186623.6.695.492563ebuQUxu7">应用运维概述</a></h2><h2 id="管理应用生命周期"><a href="#管理应用生命周期" class="headerlink" title="管理应用生命周期"></a><a href="https://help.aliyun.com/document_detail/152395.html?spm=a2c4g.11186623.6.696.4be62cb1AgtqPc">管理应用生命周期</a></h2><h2 id="访问应用（暴露服务）"><a href="#访问应用（暴露服务）" class="headerlink" title="访问应用（暴露服务）"></a>访问应用（暴露服务）</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/152397.html?spm=a2c4g.11186623.6.698.5af83cc1n2EgOv">添加负载均衡 SLB</a></li>
<li><a href="https://help.aliyun.com/document_detail/159328.html?spm=a2c4g.11186623.6.699.63c65b9fHEhLpA">复用负载均衡 SLB</a></li>
<li><a href="https://help.aliyun.com/document_detail/195416.html?spm=a2c4g.11186623.6.700.420a7fd6bu5o8i">添加服务 Service</a></li>
<li><a href="https://help.aliyun.com/document_detail/202119.html?spm=a2c4g.11186623.6.701.d78253da4pfRaz">添加应用路由 Ingress</a></li>
</ul>
<h2 id="应用扩缩容"><a href="#应用扩缩容" class="headerlink" title="应用扩缩容"></a>应用扩缩容</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/152396.html?spm=a2c4g.11186623.6.703.688374e9HNYPKY">手动扩缩容</a></li>
<li><a href="https://help.aliyun.com/document_detail/178448.html?spm=a2c4g.11186623.6.704.756a1773zxdUcZ">自动弹性扩缩容</a></li>
</ul>
<h2 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/155907.html?spm=a2c4g.11186623.6.706.45d51b60yb6ZIE">限流降级简介</a></li>
<li>限流降级原则<ul>
<li><a href="https://help.aliyun.com/document_detail/155992.html?spm=a2c4g.11186623.6.708.220751b8CTREzz">限流降级原则概述</a></li>
<li><a href="https://help.aliyun.com/document_detail/155912.html?spm=a2c4g.11186623.6.709.76fc4367sdK0fo">服务提供方或消费方流控</a></li>
<li><a href="https://help.aliyun.com/document_detail/155913.html?spm=a2c4g.11186623.6.710.363c2617CiRgJ6">削峰填谷</a></li>
<li><a href="https://help.aliyun.com/document_detail/155914.html?spm=a2c4g.11186623.6.711.47dc13cc4A9He7">预热启动（Warm Up）</a></li>
<li><a href="https://help.aliyun.com/document_detail/155915.html?spm=a2c4g.11186623.6.712.70c0c355ATAP5D">关联限流</a></li>
<li><a href="https://help.aliyun.com/document_detail/155989.html?spm=a2c4g.11186623.6.713.5b8929a6xbSH3z">弱依赖降级</a></li>
</ul>
</li>
<li>规则配置<ul>
<li><a href="https://help.aliyun.com/document_detail/155909.html?spm=a2c4g.11186623.6.715.52484ba3TxTkTb">配置流控规则</a></li>
<li><a href="https://help.aliyun.com/document_detail/155917.html?spm=a2c4g.11186623.6.716.54722920eZIoYv">配置降级规则</a></li>
<li><a href="https://help.aliyun.com/document_detail/155920.html?spm=a2c4g.11186623.6.717.485e44efPGRhS2">配置热点规则</a></li>
</ul>
</li>
<li><a href="https://help.aliyun.com/document_detail/174047.html?spm=a2c4g.11186623.6.718.b4fe561cxTiJxs">实现 K8s 集群应用的限流降级</a></li>
<li><a href="https://help.aliyun.com/document_detail/156030.html?spm=a2c4g.11186623.6.719.5b7a21c2AofzL2">查看限流降级操作日志</a></li>
</ul>
<h2 id="变更记录"><a href="#变更记录" class="headerlink" title="变更记录"></a>变更记录</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/152398.html?spm=a2c4g.11186623.6.721.1b7f1b50XRsu5R">查看应用变更</a></li>
<li><a href="https://help.aliyun.com/document_detail/183180.html?spm=a2c4g.11186623.6.722.655d18cbUUQCpj">K8s 集群应用部署失败的原因分析</a></li>
</ul>
<h2 id="事件中心"><a href="#事件中心" class="headerlink" title="事件中心"></a>事件中心</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/152404.html?spm=a2c4g.11186623.6.724.5353a206u0koo2">事件中心</a></li>
</ul>
<h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/150475.html?spm=a2c4g.11186623.6.726.1a5b4cb87U3TGT">查看实时日志</a></li>
<li><a href="https://help.aliyun.com/document_detail/152407.html?spm=a2c4g.11186623.6.727.3e24fd2aMw8aXA">查看日志目录</a></li>
<li><a href="https://help.aliyun.com/document_detail/152408.html?spm=a2c4g.11186623.6.728.43418f82KnrLAX">查看文件日志</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>企业级分布式应用服务 EDAS 应用</title>
    <url>/articles/Java-Framework-EDAS-Operation.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇为了帮助用户体验 EDAS，快速入门介绍如何将 Spring Cloud 和 Apache Dubbo（简称 Dubbo）微服务应用 Demo 快速部署到 EDAS 的不同环境中，每个部署场景均可在 30 分钟内完成。</p>
<p>EDAS 提供 1~5 个免费的按量付费应用实例。如果您开通了 EDAS 按量付费的标准版，并且部署的应用实例不超过 5 个的情况下，使用 EDAS 本身不会产生任何费用，但需要为创建的云服务器 ECS、负载均衡 SLB 而使用的阿里云资源支付费用，直到释放这些资源为止。</p>
<p>EDAS 提供的应用 Demo 中注册中心使用的是 Nacos，您也可以根据需求自建或使用 MSE 托管其它类型的注册中心，如 Eureka 或 ZooKeeper。只要保证注册中心与应用部署环境的网络互通，无需修改任何代码，即可将应用部署到 EDAS，使用 EDAS 提供的应用托管、微服务及云原生应用 PaaS 平台能力，详情请参见<a href="https://help.aliyun.com/document_detail/42934.htm#concept-2038209">什么是企业级分布式应用服务 EDAS</a>。</p>
<span id="more"></span>

<p>![EDAS 使用流程](Java-Framework-EDAS-Operation/EDAS 使用流程.png)</p>
<p><strong>说明</strong></p>
<ul>
<li>默认环境：EDAS 提供的默认 VPC 和默认微服务空间中的默认 ECS 集群。目前 EDAS 仅为 ECS 集群提供了默认环境，K8s 无默认环境。</li>
<li>自定义环境：您创建的 ECS 集群或 K8s 集群。</li>
<li><a href="https://help.aliyun.com/document_detail/189758.html?spm=a2c4g.11186623.6.575.1f4833a3gvQqnc">如何选择合适的部署环境</a></li>
</ul>
<p><strong>链接</strong></p>
<ul>
<li><p><a href="https://help.aliyun.com/document_detail/169358.html">平滑迁移微服务应用至 EDAS</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/157039.html">开发应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/181513.html">在 K8s 环境中部署微服务应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/184500.html?spm=a2c4g.11186623.6.579.20eb168arG1eh6">在 K8s 环境中通过镜像部署多语言微服务应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/134109.html">在默认 ECS 环境中部署微服务应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/135134.html">在自定义 ECS 环境中部署微服务应用</a></p>
</li>
<li><p><a href="https://help.aliyun.com/document_detail/182309.html?spm=a2c4g.11186623.6.580.53675416tWJ8EQ">常见问题</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>EDAS 服务治理</title>
    <url>/articles/Java-Framework-EDAS-Service-Governance.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>服务治理是 EDAS 的重要功能之一。在 EDAS 中，用户可以对 Spring Cloud、Dubbo、HSF 和多语言服务应用进行治理，包括服务查询、调用链查询、离群实例摘除和服务鉴权等。</p>
<span id="more"></span>

<h1 id="Spring-Cloud-服务治理"><a href="#Spring-Cloud-服务治理" class="headerlink" title="Spring Cloud 服务治理"></a>Spring Cloud 服务治理</h1><ul>
<li><p>金丝雀发布</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/199071.html?spm=a2c4g.11186623.6.870.610a45a6FWAcVH">金丝雀发布（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/199076.html?spm=a2c4g.11186623.6.871.598352b0LS6SZo">金丝雀发布（ECS）</a></li>
</ul>
</li>
<li><p>部署和运维</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/132165.html?spm=a2c4g.11186623.6.868.372d42b2dpTxb6">无损下线 Spring Cloud 应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/155526.html?spm=a2c4g.11186623.6.872.fac87f2e6VEUFt">查询 Spring Cloud 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/155530.html?spm=a2c4g.11186623.6.873.575f3c70GBT5uw">查询 Spring Cloud 服务调用链</a></li>
<li><a href="https://help.aliyun.com/document_detail/175625.html?spm=a2c4g.11186623.6.876.d9e51f096M9U8X">查看 Spring Cloud 应用的服务契约及变更通知</a></li>
<li><a href="https://help.aliyun.com/document_detail/178171.html?spm=a2c4g.11186623.6.883.3acc2704SznK71">为 Spring Cloud 服务配置标签路由</a></li>
<li><a href="https://help.aliyun.com/document_detail/202837.html?spm=a2c4g.11186623.6.884.7ee32dedhNJZ4D">为 Spring Cloud 服务配置服务降级</a></li>
</ul>
</li>
<li><p>安全和可用性</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/145687.html?spm=a2c4g.11186623.6.874.17c71829c6xcw6">使用利群实例摘除保障 Spring Cloud 应用的可用性</a></li>
<li><a href="https://help.aliyun.com/document_detail/155527.html?spm=a2c4g.11186623.6.875.16d1262cv2vB3u">使用服务鉴权实现 Spring Cloud 应用的访问控制</a></li>
</ul>
</li>
<li><p>服务测试</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/175622.html?spm=a2c4g.11186623.6.877.58a67b78loMcN0">测试 Spring Cloud 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/197048.html?spm=a2c4g.11186623.6.878.2be31d364Gjuvi">压测 Spring Cloud 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/197050.html?spm=a2c4g.11186623.6.879.739e137fFQDkdx">巡检 Spring Cloud 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/197049.html?spm=a2c4g.11186623.6.880.11961d10AYLpBO">自动化回归 Spring Cloud 服务的测试用例</a></li>
<li><a href="https://help.aliyun.com/document_detail/215554.html?spm=a2c4g.11186623.6.881.7dc3688aTYKTgW">自动化回归 Spring Cloud 服务的测试用例集</a></li>
<li><a href="https://help.aliyun.com/document_detail/266714.html?spm=a2c4g.11186623.6.882.21bb369dHBsCrf">自动化回归 Spring Cloud 服务的脚本化编排</a></li>
</ul>
</li>
<li><p>全链路流量控制</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/207624.html?spm=a2c4g.11186623.6.886.41977f97hWNSWc">全链路流量控制简介</a></li>
<li><a href="https://help.aliyun.com/document_detail/207756.html?spm=a2c4g.11186623.6.887.195b4482JssObx">使用全链路流量控制监控入口应用的流量</a></li>
<li><a href="https://help.aliyun.com/document_detail/207757.html?spm=a2c4g.11186623.6.888.37be3e19EeTSfy">使用全链路流量控制将流量路由到目标应用</a></li>
</ul>
</li>
</ul>
<h1 id="Dubbo-服务治理"><a href="#Dubbo-服务治理" class="headerlink" title="Dubbo 服务治理"></a>Dubbo 服务治理</h1><ul>
<li>金丝雀发布<ul>
<li><a href="https://help.aliyun.com/document_detail/199078.html?spm=a2c4g.11186623.6.892.27cf2d054RwxEH">金丝雀发布（K8s）</a></li>
<li><a href="https://help.aliyun.com/document_detail/199080.html?spm=a2c4g.11186623.6.893.24fb121cF1JKYI">金丝雀发布（ECS）</a></li>
</ul>
</li>
<li>部署和运维<ul>
<li><a href="https://help.aliyun.com/document_detail/131248.html?spm=a2c4g.11186623.6.890.4ef430dc4itVH2">无损下线 Dubbo 应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/155529.html?spm=a2c4g.11186623.6.894.52eb7f2eITZNoH">查询 Dubbo 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/155532.html?spm=a2c4g.11186623.6.895.50b44e74dhhW8D">查询 Dubbo 服务调用链</a></li>
<li><a href="https://help.aliyun.com/document_detail/178172.html?spm=a2c4g.11186623.6.904.12241a4dyU1DFX">为 Dubbo 服务配置标签路由</a></li>
<li><a href="https://help.aliyun.com/document_detail/197980.html?spm=a2c4g.11186623.6.905.429b5723JTlH8q">为 Dubbo 服务动态配置超时时间</a></li>
<li><a href="https://help.aliyun.com/document_detail/202838.html?spm=a2c4g.11186623.6.906.34a86c76ELPQOw">为 Dubbo 服务配置服务降级</a></li>
</ul>
</li>
<li>安全和可用性<ul>
<li><a href="https://help.aliyun.com/document_detail/141730.html?spm=a2c4g.11186623.6.896.47b17d74E4Pirh">使用离群实例摘除保障 Dubbo 应用的可用性</a></li>
<li><a href="https://help.aliyun.com/document_detail/155528.html?spm=a2c4g.11186623.6.897.609d71ebVS5oXN">使用服务鉴权实现 Dubbo 应用的访问控制</a></li>
</ul>
</li>
<li>服务测试<ul>
<li><a href="https://help.aliyun.com/document_detail/175623.html?spm=a2c4g.11186623.6.898.6ded770ew4RPcZ">测试 Dubbo 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/197053.html?spm=a2c4g.11186623.6.899.56813576WuKFyL">压测 Dubbo 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/197052.html?spm=a2c4g.11186623.6.900.35ec1afc1V6Ylk">巡检 Dubbo 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/197051.html?spm=a2c4g.11186623.6.901.15bc4bc16MACax">自动化回归 Dubbo 服务的测试用例</a></li>
<li><a href="https://help.aliyun.com/document_detail/215555.html?spm=a2c4g.11186623.6.902.2ead3de3LiOmUJ">自动化回归 Dubbo 服务的测试用例集</a></li>
<li><a href="https://help.aliyun.com/document_detail/266715.html?spm=a2c4g.11186623.6.903.39b77495sgBMMi">自动化回归 Dubbo 的服务脚本化编排</a></li>
</ul>
</li>
<li>全链路流量监控<ul>
<li><a href="https://help.aliyun.com/document_detail/207627.html?spm=a2c4g.11186623.6.908.278b18dbJ54ZEF">全链路流量控制简介</a></li>
<li><a href="https://help.aliyun.com/document_detail/207758.html?spm=a2c4g.11186623.6.909.3b184482Mb1l1i">使用全链路流量控制监控入口应用的流量</a></li>
<li><a href="https://help.aliyun.com/document_detail/207759.html?spm=a2c4g.11186623.6.910.5cfd3e19xwMj9X">使用全链路流量控制将流量路由到目标应用</a></li>
</ul>
</li>
</ul>
<h1 id="HSF-服务治理"><a href="#HSF-服务治理" class="headerlink" title="HSF 服务治理"></a>HSF 服务治理</h1><ul>
<li>部署和运维<ul>
<li><a href="https://help.aliyun.com/document_detail/145048.html?spm=a2c4g.11186623.6.915.5991689fWPuIZW">无损上线 HSF 应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/155531.html?spm=a2c4g.11186623.6.912.4bb930dcW5mF3D">查询 HSF 服务</a></li>
<li><a href="https://help.aliyun.com/document_detail/155533.html?spm=a2c4g.11186623.6.913.3d774cd9Qendja">查询 HSF 服务调用链</a></li>
<li><a href="https://help.aliyun.com/document_detail/102369.html?spm=a2c4g.11186623.6.916.46a73c2aTkXomh">查看 HSF 服务报表</a></li>
</ul>
</li>
<li>全链路流量控制<ul>
<li><a href="https://help.aliyun.com/document_detail/107944.html?spm=a2c4g.11186623.6.918.a318192b76sjZh">全链路流量控制简介</a></li>
<li><a href="https://help.aliyun.com/document_detail/125778.html?spm=a2c4g.11186623.6.919.7bec44823M3lQM">如何通过全链路流控升级单个应用</a></li>
<li><a href="https://help.aliyun.com/document_detail/131940.html?spm=a2c4g.11186623.6.920.290a440dwxPuZ9">如何使用全链路流量控制排查应用问题</a></li>
<li><a href="https://help.aliyun.com/document_detail/107931.html?spm=a2c4g.11186623.6.921.65774fc7WnnBUx">单应用流量控制</a></li>
<li><a href="https://help.aliyun.com/document_detail/107558.html?spm=a2c4g.11186623.6.922.717d630cLh2FDh">多应用创建流量控制环境</a></li>
<li><a href="https://help.aliyun.com/document_detail/114314.html?spm=a2c4g.11186623.6.923.4ab56a12LrFmky">监控灰度流量</a></li>
<li><a href="https://help.aliyun.com/document_detail/108899.html?spm=a2c4g.11186623.6.924.41fd2811p22qKr">全链路流量控制的约束限制</a></li>
<li><a href="https://help.aliyun.com/document_detail/108686.html?spm=a2c4g.11186623.6.925.44841f70WcDQFL">全链路流量控制策略</a></li>
<li><a href="https://help.aliyun.com/document_detail/110392.html?spm=a2c4g.11186623.6.926.41fd27d0NbckfU">流控规则参数说明</a></li>
</ul>
</li>
<li>安全和可用性<ul>
<li><a href="https://help.aliyun.com/document_detail/147122.html?spm=a2c4g.11186623.6.914.55e468f3bifzia">使用离群实例摘除保障 HSF 应用的可用性</a></li>
</ul>
</li>
</ul>
<h1 id="多语言服务治理"><a href="#多语言服务治理" class="headerlink" title="多语言服务治理"></a>多语言服务治理</h1><ul>
<li>金丝雀发布<ul>
<li><a href="https://help.aliyun.com/document_detail/189257.html?spm=a2c4g.11186623.6.929.60ee3e73BVXNyn">金丝雀发布多语言应用</a></li>
</ul>
</li>
<li>部署和运维<ul>
<li><a href="https://help.aliyun.com/document_detail/189256.html?spm=a2c4g.11186623.6.928.381855acPVgksY">查询多语言应用服务</a></li>
</ul>
</li>
<li>安全和可用性<ul>
<li><a href="https://help.aliyun.com/document_detail/195673.html?spm=a2c4g.11186623.6.930.26b141efr8mh3m">使用服务鉴权实现多语言应用的访问控制</a></li>
<li><a href="https://help.aliyun.com/document_detail/202261.html?spm=a2c4g.11186623.6.931.602d596bzuvkF7">使用离群实例摘除保障多语言应用的可用性</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>HSF 框架简介</title>
    <url>/articles/Java-Framework-HSF-Introduction.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HSF 框架，全称 High Speed Framework，是 Alibaba 内部使用的 RPC 框架，最初于 Dubbo 进行内部竞争，由于多方面的原因最终选择了 HSF。</p>
<p>HSF 作为阿里内部高性能的 RPC 框架，其优点是轻量，高性能，运维成本低的特性，为大规模集群的应用提供了好的基础。</p>
<p>入职前需要掌握的一个框架，HSF，自学的同时也分享给大家。</p>
<span id="more"></span>

<h1 id="HSF-框架简介"><a href="#HSF-框架简介" class="headerlink" title="HSF 框架简介"></a>HSF 框架简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HSF 连通不同的业务系统，解耦系统间的实现依赖。HSF 从分布式应用的层面，统一了服务的发布与调用方式，从而帮助用户更加方便、快速地开发分布式应用，以及提供或使用公共功能模块。HSF 为用户屏蔽了分布式领域中的各种复杂技术细节，如远程通讯、序列化实现、性能损耗、同步与异步调用方式的实现等。</p>
<h2 id="HSF-架构"><a href="#HSF-架构" class="headerlink" title="HSF 架构"></a>HSF 架构</h2><p>HSF 作为一个纯客户端架构的 RPC 框架，没有服务端集群，所有 HSF 服务调用均是通过服务消费方（Consumer）与服务提供方（Provider）点对点进行。为了实现整套分布式服务体系，HSF 还需要依赖以下外部系统。</p>
<p><img src="Java-Framework-HSF-Introduction/p71175.png" alt="EDAS_HSF架构图"></p>
<ul>
<li><p>服务提供方</p>
<p>服务提供方绑定了 12200 端口，用于接受请求并提供服务，同时将地址信息发布到地址注册中心。</p>
</li>
<li><p>服务消费方</p>
<p>服务消费者通过地址注册中心订阅服务，根据订阅到的地址信息发起调用，地址注册中心不参与调用。</p>
</li>
<li><p>EDAS 地址注册中心</p>
<p>HSF 依赖注册中心进行服务发现，如果没有注册中心，HSF 只能完成简单的点对点调用。</p>
<p>服务提供端无法将服务信息对外暴露，服务消费端可能已经明确了待调用的服务，但是无法获取该服务。因此注册中心是服务信息的中介，为服务提供了注册与发现的功能。</p>
</li>
<li><p>EDAS 持久化配置中心</p>
<p>持久化的配置中心用于存储HSF服务的各种治理规则，HSF 客户端在启动的过程中向持久化配置中心订阅服务治理规则，如路由规则、归组规则、权重规则等，从而根据规则对调用过程的选址逻辑进行干预。</p>
</li>
<li><p>EDAS 元数据存储中心</p>
<p>元数据指 HSF 服务对应的方法列表以及参数结构等信息。元数据对 HSF 的调用过程不会产生影响，因此元数据存储中心是可选的。由于服务运维的便捷性，HSF 客户端在启动时会将元数据上报到元数据存储中心，方便服务运维。</p>
</li>
<li><p>EDAS 控制台</p>
<p>EDAS 控制台打通了服务地址注册中心、持久化配置中心、元数据存储中心等，为用户提供了服务运维功能，包括服务查询、服务治理规则管理等，提高HSF服务研发的效率、运维的便捷性。</p>
</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>HSF 作为分布式 RPC 服务框架，支持多种服务的调用方式。</p>
<ul>
<li><p>同步调用</p>
<p>HSF 客户端默认以同步调用的方式消费服务，客户端代码需要同步等待返回结果。</p>
</li>
<li><p>异步调用</p>
<p>对于服务调用的客户端，并非所有 HSF 服务都需要同步等待返回结果。HSF 提供异步调用，帮助客户端无需同步阻塞在 HSF 调用上。HSF 的异步调用，有 Future 调用和 Callback 调用两种。</p>
<ul>
<li><p>Future 调用</p>
<p>客户端在需要获取调用的返回结果时，通过 <code>HSFResponseFuture.getResponse(int timeout)</code> 主动获取结果。</p>
</li>
<li><p>Callback 调用</p>
<p>Callback 调用利用 HSF 内部提供的回调机制，在指定 HSF 服务消费完毕拿到返回结果时，HSF 框架会回调用户实现的<code>HSFResponseCallback</code>接口，客户端通过回调通知的方式获取结果。</p>
</li>
</ul>
</li>
<li><p>泛化调用</p>
<p>对于一般的 HSF 调用来说，HSF 客户端需要依赖服务的二方包，通过依赖二方包中的 API 进行编程调用，获取返回结果。但是泛化调用不需要依赖服务的二方包，可以发起 HSF 调用、获取返回结果。在平台型的产品中，泛化调用的方式可以有效减少平台型产品的二方包依赖，实现系统的轻量级运行。</p>
</li>
<li><p>调用链路 Filter 扩展</p>
<p>HSF 内部设计了调用过滤器，能够主动发现用户的调用过滤器扩展点，将其集成到 HSF 调用链路中，便于扩展方对 HSF 的请求进行扩展处理。</p>
</li>
</ul>
<h2 id="应用开发方式"><a href="#应用开发方式" class="headerlink" title="应用开发方式"></a>应用开发方式</h2><p>使用 HSF 框架开发应用有 Ali-Tomcat 和 Pandora Boot 两种方式。</p>
<ul>
<li>Ali-Tomcat：依赖 Ali-Tomcat 和 Pandora，提供了完整的 HSF 功能，包括服务注册与发现、隐式传参、异步调用、泛化调用和调用链路 Filter 扩展。应用程序须以 WAR 包方式部署。</li>
<li>Pandora Boot：依赖 Pandora，提供了比较完整的 HSF 功能，包括服务注册与发现、异步调用。应用程序编译为可运行的 JAR 包并部署即可。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>巅峰之旅（一）如何学习 Java</title>
    <url>/articles/Java-How-to-Learn-Java.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习是为了什么？</p>
<blockquote>
<p>面向面试学习</p>
<p>面向大厂学习</p>
<p>面向薪资学习</p>
<p>面向提升学习</p>
</blockquote>
<p>我不否认上面的任何一点。尽管从境界，或者说价值观层面，显得越来越高大上，打工人终归还是要恰饭的嘛。</p>
<p>要想恰好饭，就要进大厂；要想更好提升，就要进大厂。</p>
<p>所以不论是提升个人价值、还是创造个人价值的角度，进大厂无疑是所有程序员的梦想。</p>
<p>很多人在工作几年之后，固然日常开发和解决问题的能力都很强，但是从前学习的东西要么忘了、要么没有经过深入的研究。</p>
<p>在大厂面试的时候哪怕心里知道，嘴上也支支吾吾。</p>
<p>更别说很多非八股文的、需要深入理解某些知识，才能在其间游刃有余谈吐自若。</p>
<p>然后再到场景设计编程实现、或者直接丢过来两道没刷过的算法题，当场凉凉。</p>
<span id="more"></span>

<p>从前没有章法，什么都学，但也不知道重点，应该在哪里深入，在去年的几轮面试中折戟……</p>
<p>但无妨，我记录并整理了面经进行复盘，也作为这一系列教程的核心框架。</p>
<ul>
<li>八股文——背就完事儿了，但是要抓重点。</li>
<li>项目及应用——一定要深入你所负责或者熟悉的项目模块，把各个角度都理解透彻（这本身也对工作有益）；如果实在是没有什么拿得出手的项目，就基于之前的项目进行场景扩展，把自己当成一个负责人来思考各种情况。</li>
<li>算法——有技巧地做题，而非瞎几把刷题。</li>
</ul>
<p>今年，在经历了几个公司（均为大厂或独角兽）三十多轮的技术面试之后，终于成功起飞。</p>
<p>接下来的系列知识盘点，一部分我会按照正经的知识体系梳理；但是更多的，我会解构知识体系，通过模拟面试场景，站在面试官的角度去将零碎的知识串成一棵多叉树，希望亲爱的读者你，可以像拎葡萄一样，“<strong>拎起一根，带起一串</strong>”。</p>
<h1 id="学习准备"><a href="#学习准备" class="headerlink" title="学习准备"></a>学习准备</h1><h2 id="思想准备"><a href="#思想准备" class="headerlink" title="思想准备"></a>思想准备</h2><p>这是一段艰苦的旅程。</p>
<p>我真心体会过从深渊向巅峰仰望时的绝望，一次次被打击到，无数个闷在房间内听课、看文档、看书、总结、刷题的深夜，只有我的小猫咪是唯一的慰藉。</p>
<p>告别了生活，告别了娱乐，告别了兴趣爱好……</p>
<p>你要坚信你的付出是值得的，你失去的，总有一天生活会回报给你更好的。</p>
<p>而在此期间，你的成长也是无与伦比的。</p>
<p>希望你看看我在学习期间的<a href="http://chenzihao.me/articles/Essay-Personal-Development.html">个人成长总结</a>。</p>
<h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><h3 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h3><p>首推 ProcessOn，建议买会员，解锁更多使用姿势。</p>
<p>另外，欢迎大家关注我的 <a href="https://www.processon.com/u/599247d8e4b0b83fa25f1298/profile#pc">ProcessOn</a>，这里分享了很多我整理的东西。</p>
<p><img src="Java-How-to-Learn-Java/image-20210717113425389.png" alt="image-20210717113425389"></p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p>Xmind 足够了</p>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>推荐 JetBrains 家的 IDEA。</p>
<p>关于激活或者无限期试用，请关注 <a href="http://chenzihao.me/articles/Tool-best-Mac.html">如何打造宇宙最强 Macbook</a> 中的 <code>JetBrains</code> 部分。</p>
<h2 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h2><p>知识框架，我已经整理在 <a href="https://www.processon.com/view/60c854291efad418c90823f7?fromnew=1#map">ProcessOn</a> 了，请大家关注、收藏。</p>
<p>我已经将需要用到的资料整理到公众号内了，请小伙伴们关注微信公众号 <code>等把深夜熬熟</code>，并发送“博客资料”获取。</p>
<p>微信公众号二维码：</p>
<p><img src="Java-How-to-Learn-Java/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="微信公众号"></p>
<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>我假设你已经有了一定的基础和两年左右的工作经验，默认你了解一些概念性的基础知识，具备一定的开发实战经验。</p>
<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><ul>
<li>Java 简介</li>
<li>Java 语法基础</li>
<li>Java 数据类型</li>
<li>运算符</li>
<li>程序结构</li>
<li>方法和函数</li>
<li>数组</li>
<li>面向对象</li>
<li>异常</li>
<li>集合</li>
<li>泛型</li>
<li>IO 流</li>
<li>网络编程</li>
<li>反射</li>
<li>Java 8 新特性</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>Java 虚拟机</li>
<li>Java 内存结构</li>
<li>Java 内存模型</li>
<li>Java 类加载</li>
<li>GC</li>
<li>JVM 调优</li>
</ul>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h2 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h2><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><strong>小板凳搬好，我们准备开始啦~</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>HSF 应用开发</title>
    <url>/articles/Java-Framework-HSF-Operation.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇介绍 HSF 框架的开发应用。</p>
<span id="more"></span>

<h1 id="HSF-应用开发"><a href="#HSF-应用开发" class="headerlink" title="HSF 应用开发"></a>HSF 应用开发</h1><h2 id="启动轻量级配置及注册中心"><a href="#启动轻量级配置及注册中心" class="headerlink" title="启动轻量级配置及注册中心"></a><a href="https://help.aliyun.com/document_detail/44163.html?spm=a2c4g.11186623.6.1027.27264b33khgdrj">启动轻量级配置及注册中心</a></h2><h2 id="使用-Ali-Tomcat-开发应用"><a href="#使用-Ali-Tomcat-开发应用" class="headerlink" title="使用 Ali-Tomcat 开发应用"></a>使用 Ali-Tomcat 开发应用</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/90754.html?spm=a2c4g.11186623.6.1029.3ada74fbcxOUbd">Ali-Tomcat 概述</a></li>
<li><a href="https://help.aliyun.com/document_detail/99410.html?spm=a2c4g.11186623.6.1030.79cf74fbdM0TKw">安装及开发环境配置</a></li>
<li><a href="https://help.aliyun.com/document_detail/99912.html?spm=a2c4g.11186623.6.1031.6a0e8387dWFkGT">开发 HSF 应用（SDK）</a></li>
</ul>
<h2 id="使用-Pandora-Boot-开发应用"><a href="#使用-Pandora-Boot-开发应用" class="headerlink" title="使用 Pandora Boot 开发应用"></a>使用 Pandora Boot 开发应用</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/91226.html?spm=a2c4g.11186623.6.1033.34185582RnVI3r">Pandora Boot 概述</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/66643.html?spm=a2c4g.11186623.6.1034.44b97f2eH11P9b">配置 EDAS 的私服地址和轻量级配置及注册中心</a></li>
<li><a href="https://help.aliyun.com/document_detail/99943.html?spm=a2c4g.11186623.6.1035.4fe52cefH2qFQw">开发 HSF 应用（Pandora Boot）</a></li>
<li><a href="https://help.aliyun.com/document_detail/99988.html?spm=a2c4g.11186623.6.1036.2f7551ec6REtto">开发 RESTful 应用（不推荐）</a></li>
<li><a href="https://help.aliyun.com/document_detail/68162.html?spm=a2c4g.11186623.6.1037.62413b8bXvRzfU">将 Dubbo 应用迁移到 HSF（不推荐）</a></li>
</ul>
<h2 id="将应用从-HSF-架构迁移到-Dubbo（Ali-Tomcat）"><a href="#将应用从-HSF-架构迁移到-Dubbo（Ali-Tomcat）" class="headerlink" title="将应用从 HSF 架构迁移到 Dubbo（Ali-Tomcat）"></a><a href="https://help.aliyun.com/document_detail/138922.html?spm=a2c4g.11186623.6.1038.7d5f7b59Ba4TPW">将应用从 HSF 架构迁移到 Dubbo（Ali-Tomcat）</a></h2><h2 id="一次调用过程"><a href="#一次调用过程" class="headerlink" title="一次调用过程"></a>一次调用过程</h2><p>HSF 的一次调用过程是从服务消费方发起，经过网络抵达服务提供方，再将服务提供方的结果通过网络携带返回，最终返回给用户。该过程涉及多线程交互，同时也涉及 HSF 中的不同领域对象。</p>
<p>HSF 的一次调用过程如下图所示：</p>
<p><img src="Java-Framework-HSF-Operation/%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="SAE产品HSF应用开发之一次调用过程"></p>
<table>
<thead>
<tr>
<th align="left">过程</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">在客户端线程中将用户的请求参数即请求对象进行序列化，并将序列后的内容存放在请求通信的对象中。 <strong>说明</strong> 请求通信对象对应的是 HSF 协议，包括了请求 ID 等多个与请求对象无关的内容。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">系统将请求通信对象递交给 I/O 线程，并在 I/O 线程中完成编码。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">编码完成后，将内容传递到服务提供方的 I/O 线程。客户端线程会等待结果返回。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">服务提供方的 I/O 线程接收到二进制内容，解码后生成通信请求对象，并将其递交给 HSF 服务端线程。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">在 HSF 服务端线程完成反序列化还原成请求对象。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">发起反射调用，并得到结果，即响应对象。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">响应对象会在 HSF 服务端线程中完成序列化，并存储在通信响应对象中。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">HSF 服务端线程将通信响应对象递交给 I/O 线程，在 I/O 线程中完成编码。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">服务提供方将 I/O 线程中完成编码，发送回服务消费方。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">服务消费方收到二进制内容，在 I/O 线程中完成解码，生成响应通信对象，并唤醒客户端线程。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">客户端线程根据响应通信对象中的内容进行反序列化，用户收到响应对象，一次远程调用结束。</td>
</tr>
</tbody></table>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开发应用前，您已经完成以下工作：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66643.htm#task-2310132">配置 EDAS 的私服地址和轻量级配置及注册中心</a></li>
<li><a href="https://help.aliyun.com/document_detail/44163.htm#task-2310117">启动轻量级配置及注册中心</a></li>
</ul>
<h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>HSF 的 IO 操作是异步操作，客户端同步调用的本质是执行<code>future.get（timeout）</code>操作，等待服务端的结果返回，这里的 <code>timeout</code> 就是客户端生效的超时时间 （默认 3000 ms）。同步调用时序图如下所示：</p>
<p><img src="Java-Framework-HSF-Operation/SAE%E6%9C%8D%E5%8A%A1HSF%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="SAE服务HSF应用开发异步调用"></p>
<p>对于客户端来说，并不是所有的 HSF 服务都是需要同步等待服务端返回结果的，对于这些服务，HSF 提供异步调用的形式，让客户端不必同步阻塞在 HSF 操作上。 异步调用在发起调用时，HSF 服务的调用结果都是返回值的默认值，例如返回类型是 int，则会返回 0，返回类型是 Object，则会返回 null。而真正的结果，是在 HSFResponseFuture 或者回调函数（callback）中获得的。</p>
<h3 id="Future-异步调用"><a href="#Future-异步调用" class="headerlink" title="Future 异步调用"></a>Future 异步调用</h3><p>HSF 发起调用后，用户可以在上下文中获取跟返回结果关联的<code>HSFFuture</code>对象，获取对象后调用 HSFFuture.getResponse(timeout) 获取服务端的返回结果。Future 异步调用的时序图如下所示：</p>
<p><img src="Java-Framework-HSF-Operation/SAE%E5%BA%94%E7%94%A8HSF%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B9%8BFuture%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="SAE应用HSF应用开发之Future异步调用"></p>
<ul>
<li><p>API 形式配置 HSF 服务</p>
<p>HSF 提供了方法级别的异步调用配置，格式为<code>name:$&#123;methodName&#125;;type:future</code>，由于只用方法名字来标识方法，所以并不区分重载的方法。同名的方法都会被设置为同样的调用方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSFApiConsumerBean hsfApiConsumerBean = <span class="keyword">new</span> HSFApiConsumerBean();</span><br><span class="line">hsfApiConsumerBean.setInterfaceName(<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setVersion(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setGroup(<span class="string">&quot;HSF&quot;</span>);</span><br><span class="line"><span class="comment">// [设置] 异步future调用</span></span><br><span class="line">List&lt;String&gt; asyncallMethods = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 格式：name:&#123;methodName&#125;;type:future</span></span><br><span class="line">asyncallMethods.add(<span class="string">&quot;name:queryOrder;type:future&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setAsyncallMethods(asyncallMethods);</span><br><span class="line"></span><br><span class="line">hsfApiConsumerBean.init(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [代理] 获取HSF代理</span></span><br><span class="line">OrderService orderService = (OrderService) hsfApiConsumerBean.getObject();</span><br><span class="line"><span class="comment">// ---------------------- 调用 -----------------------//</span></span><br><span class="line"><span class="comment">// [调用] 发起HSF异步调用, 返回null</span></span><br><span class="line">OrderModel orderModel = orderService.queryOrder(<span class="number">1L</span>);</span><br><span class="line"><span class="comment">// 及时在当前调用上下文中，获取future对象；因为该对象是放在ThreadLocal中，同一线程中后续调用会覆盖future对象，所以要及时取出</span></span><br><span class="line">HSFFuture hsfFuture = HSFResponseFuture.getFuture();</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something else</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里才真正地获取结果，如果调用还未完成，将阻塞等待结果，5000ms是等待结果的最大时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(hsfFuture.getResponse(<span class="number">5000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HSF 默认的超时配置是 3000ms，如果过了超时时间，业务对象未返回，这时调用 HSFFuture.getResponse 会抛出超时异常；HSFFuture.getResponse(timeout)，如果这里的 timeout 时间内，业务结果没有返回，也没有超时，可以调用多次执行 getResponse 去获取结果。</p>
</li>
<li><p>Spring 配置 HSF 服务</p>
<p>Spring 框架在应用中广泛使用，如果不想以 API 的形式配置 HSF 服务，您可以使用 Spring XML 的形式进行配置，上述例子中 API 配置等同于如下 XML 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringConsumerBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaceName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;version&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;group&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HSF&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 订阅服务的接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncallMethods&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>name:queryOrder;type:future<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注解配置 HSF 服务</p>
<p>SpringBoot 广泛使用的今天，使用注解装配 SpringBean 也成为一种选择，HSF 也支持使用注解进行配置，用来订阅服务。</p>
<p>在项目中增加依赖 starter。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pandora-hsf-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通常一个 HSF Consumer 会在多个地方使用，但并不需要在每次使用的地方都用 <code>@HSFConsumer</code> 来标记。只需要写一个统一个 Config 类，然后在其它需要使用的地方，直接 <code>@Autowired</code> 注入即可。上述例子中的 API 配置等同于如下注解配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HsfConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@HSFConsumer(serviceVersion = &quot;1.0.0&quot;, serviceGroup = &quot;HSF&quot;, futureMethods = &quot;sayHelloInFuture&quot;)</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用时直接注入即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">OrderService orderService;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Callback-异步调用"><a href="#Callback-异步调用" class="headerlink" title="Callback 异步调用"></a>Callback 异步调用</h3><p>客户端配置为 callback 方式调用时，需要配置一个实现了 HSFResponseCallback 接口的 listener，结果返回之后，HSF 会调用 HSFResponseCallback 中的方法。时序图如下所示：</p>
<p><img src="Java-Framework-HSF-Operation/Callback%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="Callback异步调用"></p>
<ul>
<li><p>API 形式配置 HSF 服务</p>
<p><strong>callback 的调用上下文</strong></p>
<p>用户在调用前还可以通过 CallbackInvocationContext.setContext(Object obj)，来设置一个关于本次调用的上下文信息，该信息存放在 threadlocal 中。在 listener 的回调函数中，可以通过 CallbackInvocationContext.getContext() 来获取该对象。</p>
<p><strong>回调函数示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackHandler</span> <span class="keyword">implements</span> <span class="title">HSFResponseCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务异常时会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppResponse</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取callback调用时设置的上下文</span></span><br><span class="line">        Object context = CallbackInvocationContext.getContext();</span><br><span class="line">        System.out.println(result.toString() + context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//HSF异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHSFException</span><span class="params">(HSFException e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口 callback 方法配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSFApiConsumerBean hsfApiConsumerBean = <span class="keyword">new</span> HSFApiConsumerBean();</span><br><span class="line">hsfApiConsumerBean.setInterfaceName(<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setVersion(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setGroup(<span class="string">&quot;HSF&quot;</span>);</span><br><span class="line"><span class="comment">// [设置] 异步callback调用</span></span><br><span class="line">List&lt;String&gt; asyncallMethods = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">asyncallMethods.add(<span class="string">&quot;name:queryOrder;type:callback;listener:com.alibaba.middleware.hsf.CallbackHandler&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setAsyncallMethods(asyncallMethods);</span><br><span class="line">hsfApiConsumerBean.init(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// [代理] 获取HSF代理</span></span><br><span class="line">OrderService orderService = (OrderService) hsfApiConsumerBean.getObject();</span><br><span class="line"><span class="comment">// 可选步骤，设置上下文。CallbackHandler中通过api可以获取到CallbackInvocationContext.setContext(&quot;in callback&quot;);</span></span><br><span class="line"><span class="comment">// 发起调用</span></span><br><span class="line">orderService.queryOrder(<span class="number">1L</span>); <span class="comment">// 这里返回的其实是 null</span></span><br><span class="line"><span class="comment">// 清理上下文</span></span><br><span class="line">CallbackInvocationContext.setContext(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// do something else</span></span><br></pre></td></tr></table></figure>

<p>在调用线程中可以设置上下文，然后在 listener 中获取使用。相对于 Future 异步调用，callback 会立即知晓结果的返回。</p>
</li>
<li><p>Spring 配置 HSF 服务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;CallHelloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringConsumerBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 订阅服务的接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaceName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;version&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的归组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;group&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HSF&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncallMethods&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--future的含义为通过Future的方式去获取请求执行的结果，例如先调用下远程的接口，接着在同一线程继续做别的事情，然后再在同一线程中通过Future来获取结果 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--name:methodName;type:future|callback--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>name:queryOrder;type:callback;listener:com.alibaba.middleware.hsf.CallbackHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注解配置 HSF 接口方法为 callback 调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AsyncOn(interfaceName = OrderService.class, methodName = &quot;queryOrder&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackHandler</span> <span class="keyword">implements</span> <span class="title">HSFResponseCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppResponse</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取callback调用时设置的上下文</span></span><br><span class="line">        Object context = CallbackInvocationContext.getContext();</span><br><span class="line">        System.out.println(result.toString() + context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHSFException</span><span class="params">(HSFException e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 回调函数是由单独的线程池（ LinkedBlockingQueue 无限队列）来调用的，不要做太费时间的操作，避免影响其他请求的 onAppResponse 回调。callback 线程默认的 corePoolSize、maxPoolSize 是实例 CPU 数目。 下面的 <em>-D</em> 参数可以去自定义配置。</p>
<ul>
<li>CALLBACK 线程池最小配置：<code>-Dhsf.callback.min.poolsize</code></li>
<li>CALLBACK 线程池最大配置：<code>-Dhsf.callback.max.poolsize</code></li>
</ul>
</li>
</ul>
<h2 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h2><p>相对于需要依赖业务客户端 JAR 包的正常调用，泛化调用不需要依赖二方包，使用其特定的 GenericService 接口，传入需要调用的方法名、方法签名和参数值进行调用服务。 泛化调用适用于一些网关应用（没办法依赖所有服务的二方包），其中 hsfops 服务测试也是依赖泛化调用功能。</p>
<h3 id="前提条件-1"><a href="#前提条件-1" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开发应用前，您已经完成以下工作：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66643.htm#task-2310132">配置 EDAS 的私服地址和轻量级配置及注册中心</a></li>
<li><a href="https://help.aliyun.com/document_detail/44163.htm#task-2310117">启动轻量级配置及注册中心</a></li>
</ul>
<h3 id="API-形式配置-HSF-服务"><a href="#API-形式配置-HSF-服务" class="headerlink" title="API 形式配置 HSF 服务"></a>API 形式配置 HSF 服务</h3><p>将 HSFConsumerBean 配置 <code>generic</code> 为 <code>true</code>，HSF 客户端将忽略加载不到接口的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSFApiConsumerBean hsfApiConsumerBean = <span class="keyword">new</span> HSFApiConsumerBean();</span><br><span class="line">hsfApiConsumerBean.setInterfaceName(<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setVersion(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setGroup(<span class="string">&quot;HSF&quot;</span>);</span><br><span class="line"><span class="comment">// [设置] 泛化配置</span></span><br><span class="line">hsfApiConsumerBean.setGeneric(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.init(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛化接口获取代理</span></span><br><span class="line">GenericService genericOrderService = (GenericService) hsfApiConsumerBean.getObject();</span><br><span class="line"><span class="comment">// ---------------------- 调用 -----------------------//</span></span><br><span class="line"><span class="comment">// [调用] 发起HSF泛化调用, 返回map类型的result</span></span><br><span class="line">Map orderModelMap = (Map) genericOrderService.$invoke(<span class="string">&quot;queryOrder&quot;</span>,</span><br><span class="line">                            <span class="comment">// 方法入参类型数组（xxx.getClass().getName())</span></span><br><span class="line">                            <span class="keyword">new</span> String[] &#123; Long.class.getName() &#125;,</span><br><span class="line">                            <span class="comment">// 参数，如果是pojo，则需要转成Map</span></span><br><span class="line">                            <span class="keyword">new</span> Object[] &#123; <span class="number">1L</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>GenericService 提供的 $invoke 方法包含了真实调用的方法名、入参类型和参数，以便服务端找到该方法。由于没有依赖服务端的 API JAR 包，传入的参数如果是自定义的 DTO，需要转成客户端可以序列化的 <code>Map</code> 类型。</p>
<p>调用方法和参数说明</p>
<ul>
<li><p>方法没有入参，可以只传 <code>methodName</code>: <code>service.$invoke(&quot;sayHello&quot;, null, null)</code>。</p>
</li>
<li><p>方法类型有泛型的，列如 <code>List&lt;String&gt;</code>，只需要传 <code>java.util.List</code>，即 List.class.getName() 的值，不要传成 <code>java.util.List&lt;String&gt;</code>，否则会出现方法找不到的错误。</p>
</li>
<li><p>调用方法在不确定格式的情况下，可以写个单元测试，测试时依赖需要泛化调用的二方包，使用 HSF 提供的工具类 com.taobao.hsf.util.PojoUtils 的 generalize() 方法来生成一个 pojo Bean 的 Map 描述格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map pojoMap = (Map) PojoUtils.generalize(<span class="keyword">new</span> OrderModel());</span><br></pre></td></tr></table></figure></li>
<li><p>传递参数为 pojo 的 demo。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">// 需要是标准的pojo格式，这里省略getter setter</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 直接使用map去构造pojo对应的泛化参数</span></span><br><span class="line">  Map param = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">  param.put(<span class="string">&quot;age&quot;</span>, <span class="number">11</span>);</span><br><span class="line">  param.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Miles&quot;</span>);</span><br><span class="line">  <span class="comment">// 当传递的参数是声明参数类型的子类时，需要传入class字段，标明该pojo的真实类型（服务端需要有该类型）</span></span><br><span class="line">  param.put(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;com.taobao.User&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Spring-配置-HSF-服务"><a href="#Spring-配置-HSF-服务" class="headerlink" title="Spring 配置 HSF 服务"></a>Spring 配置 HSF 服务</h3><p>Spring 框架是在应用中广泛使用的组件，如果不想通过 API 的形式配置 HSF 服务，可以使用 Spring XML 的形式进行配置，上述例子中的 API 配置等同于如下 XML 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;CallHelloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringConsumerBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 订阅服务的接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaceName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;version&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的归组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;group&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HSF&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;generic&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>泛化调用，如果客户端没有接口类，路由规则默认不生效。</p>
</li>
<li><p>泛化调用性能会比正常调用差。</p>
</li>
<li><p>配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-D hsf.generic.throw.exception=true （默认是false, 把异常泛化成map返回）</span><br></pre></td></tr></table></figure>

<p>抛出业务异常。</p>
<p>本地存在异常类，如果不是 RuntimeException 类型或其子类，则会抛出 UndeclaredThrowableException，这是由于 com.taobao.hsf.remoting.service.GenericService 上没有声明该异常，可以通过 getCause 获取真实异。</p>
<p>本地没有该异常类，则抛出 com.taobao.hsf.util.GenericInvocationException。</p>
</li>
</ul>
<h2 id="调用上下文"><a href="#调用上下文" class="headerlink" title="调用上下文"></a>调用上下文</h2><p>请求上下文包括一次调用相关的属性，例如调用的地址，调用方的应用名，超时时间等属性和用户在接口定义的参数之外传递自定义的数据。</p>
<h3 id="设置和获取本次调用上下文"><a href="#设置和获取本次调用上下文" class="headerlink" title="设置和获取本次调用上下文"></a>设置和获取本次调用上下文</h3><p>com.taobao.hsf.util.RequestCtxUtil 提供设置和获取调用上下文的静态方法，基于 ThreadLocal 工作， getXXX 操作会将 XXX 属性从当前 ThreadLocal 变量中 remove，仅作用于当前线程的单次调用。</p>
<p>具体属性的设置和获取如下：</p>
<ul>
<li><p>客户端</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">setRequestTimeout()</td>
<td align="left">设置单次调用的超时时间。</td>
</tr>
<tr>
<td align="left">setUserId()</td>
<td align="left">设置本次调用的单元化服务的 User ID（泛化调用中需要通过此方法配置）。</td>
</tr>
<tr>
<td align="left">getProviderIp()</td>
<td align="left">获取最近一次调用的服务端的 IP。</td>
</tr>
<tr>
<td align="left">setTargetServerIp(String ip)</td>
<td align="left">设置当前线程下一次调用的目标服务器 IP（此 IP 必须包含在内存已提供服务的地址列表里）。</td>
</tr>
<tr>
<td align="left">setDirectTargetServerIp(String targetIp)</td>
<td align="left">设置当前线程下一次调用的目标服务器 IP（绕过注册中心，忽略内存里的地址列表）。</td>
</tr>
</tbody></table>
</li>
<li><p>服务端</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getClientIp()</td>
<td align="left">服务端获取调用方 IP。</td>
</tr>
<tr>
<td align="left">getAppNameOfClient()</td>
<td align="left">服务端获取调用方的应用名。</td>
</tr>
<tr>
<td align="left">isHttpRequest()</td>
<td align="left">是否是 HTTP 调用。</td>
</tr>
<tr>
<td align="left">getHttpHeader(String key)</td>
<td align="left">获取 HTTP 请求的 Header 属性。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="传递自定义请求上下文"><a href="#传递自定义请求上下文" class="headerlink" title="传递自定义请求上下文"></a>传递自定义请求上下文</h3><p>RpcContext 提供一种不修改接口，向服务端额外传递数据的方式。参数可以是自定义的 DO 或者基本类型。要保证对端也有该对应的类型，并且可以能够被序列化。</p>
<ul>
<li><p>客户端发起调用前，设置上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setup context before rpc call</span></span><br><span class="line">RPCContext rpcContext = RPCContext.getClientContext();</span><br><span class="line">rpcContext.putAttachment(<span class="string">&quot;tetantId&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//rpc call，context 也会传到远端</span></span><br><span class="line">orderService.queryOrder(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>服务端业务方法内，获取上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get context data</span></span><br><span class="line">RPCContext rpcContext = RPCContext.getServerContext();</span><br><span class="line">String myContext = (String)rpcContext.getAttachment(<span class="string">&quot;tetantId&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="序列化方式选择"><a href="#序列化方式选择" class="headerlink" title="序列化方式选择"></a>序列化方式选择</h2><p>序列化的过程是将 Java 对象转成 byte 数组在网络中传输，反序列化会将 byte 数组转成 Java 对象。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>序列化的选择需要考虑兼容性，性能等因素，HSF 的序列化方式支持 Java、hessian2，默认是 hessian2。序列化方式的对比和配置（只在服务端配置 HSFApiProviderBean）如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">序列化方式</th>
<th align="left">Maven依赖</th>
<th align="left">配置</th>
<th align="left">兼容性</th>
<th align="left">性能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hessian2</td>
<td align="left"><artifactId>hsf-io-serialize-hessian2</artifactId></td>
<td align="left"><code>setPreferSerializeType(&quot;hessian2&quot;)</code></td>
<td align="left">好</td>
<td align="left">好</td>
</tr>
<tr>
<td align="left">java</td>
<td align="left"><artifactId>hsf-io-serialize-java</artifactId></td>
<td align="left"><code>setPreferSerializeType(&quot;java&quot;)</code></td>
<td align="left">佳</td>
<td align="left">一般</td>
</tr>
</tbody></table>
<h3 id="前提条件-2"><a href="#前提条件-2" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开发应用前，您已经完成以下工作：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66643.htm#task-2310132">配置 EDAS 的私服地址和轻量级配置及注册中心</a></li>
<li><a href="https://help.aliyun.com/document_detail/44163.htm#task-2310117">启动轻量级配置及注册中心</a></li>
</ul>
<h3 id="API-形式配置-HSF-服务-1"><a href="#API-形式配置-HSF-服务-1" class="headerlink" title="API 形式配置 HSF 服务"></a>API 形式配置 HSF 服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSFApiProviderBean hsfApiProviderBean = <span class="keyword">new</span> HSFApiProviderBean();</span><br><span class="line">hsfApiProviderBean.setPreferSerializeType(<span class="string">&quot;hessian2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Spring-配置-HSF-服务-1"><a href="#Spring-配置-HSF-服务-1" class="headerlink" title="Spring 配置 HSF 服务"></a>Spring 配置 HSF 服务</h3><p>Spring 框架是在应用中广泛使用的组件，如果不想通过 API 的形式配置 HSF 服务，可以使用 Spring XML 的形式进行配置，上述例子中的 API 配置等同于如下 XML 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringProviderBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 发布服务的接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的实现对象target必须配置 [ref]，为需要发布为HSF服务的spring bean id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;引用的BeanId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceVersion&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的归组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceGroup&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HSF&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 服务的响应时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置]  服务传输业务对象时的序列化类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;preferSerializeType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hessian2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h2><p>本文介绍开发 HSF 应用过程中如何进行超时配置。</p>
<h3 id="前提条件-3"><a href="#前提条件-3" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开发应用前，您已经完成以下工作：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66643.htm#task-2310132">配置 EDAS 的私服地址和轻量级配置及注册中心</a></li>
<li><a href="https://help.aliyun.com/document_detail/44163.htm#task-2310117">启动轻量级配置及注册中心</a></li>
</ul>
<h3 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息"></a>背景信息</h3><p>有关网络调用的请求，都需要配置超时，HSF 的默认超时时间是 3000ms。客户端和服务端都可以设置超时，默认优先采用客户端的配置，如果客户端没有配置，使用服务端的超时配置。 在服务端设置超时时，需要考虑到业务本身的执行耗时，加上序列化和网络通讯的时间。所以推荐服务端给每个服务都配置个默认的时间。当然客户端也可以根据自己的业务场景配置超时时间，例如一些前端应用，需要用户快速看到结果，可以把超时时间设置小一些。</p>
<p>配置的作用范围、作用域，按照优先级由高到低如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">API</th>
<th align="left">范围</th>
<th align="left">作用域</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">com.taobao.hsf.util.RequestCtxUtil#setRequestTimeout</td>
<td align="left">客户端</td>
<td align="left">单次调用</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">HSFApiConsumerBean#setMethodSpecials</td>
<td align="left">客户端</td>
<td align="left">方法</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HSFApiConsumerBean#setClientTimeout</td>
<td align="left">客户端</td>
<td align="left">接口</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">-D defaultHsfClientTimeout</td>
<td align="left">客户端</td>
<td align="left">所有接口</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">HSFApiProviderBean#setMethodSpecials</td>
<td align="left">服务端</td>
<td align="left">方法</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">HSFApiProviderBean#setClientTimeout</td>
<td align="left">服务端</td>
<td align="left">接口</td>
</tr>
</tbody></table>
<p><strong>说明</strong> 客户端配置优先于服务端，方法优先于接口。</p>
<h3 id="客户端超时配置"><a href="#客户端超时配置" class="headerlink" title="客户端超时配置"></a>客户端超时配置</h3><ul>
<li><p>API 形式配置 HSF 服务。</p>
<p>配置 HSFApiConsumerBean 的 clientTimeout 属性，单位是 ms，我们把接口的超时配置为 1000ms，方法 queryOrder 配置为 100ms，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSFApiConsumerBean consumerBean = <span class="keyword">new</span> HSFApiConsumerBean();</span><br><span class="line"><span class="comment">// 接口级别超时配置</span></span><br><span class="line">consumerBean.setClientTimeout(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//xxx</span></span><br><span class="line">MethodSpecial methodSpecial = <span class="keyword">new</span> MethodSpecial();</span><br><span class="line">methodSpecial.setMethodName(<span class="string">&quot;queryOrder&quot;</span>);</span><br><span class="line"><span class="comment">// 方法级别超时配置，优先于接口超时配置</span></span><br><span class="line">methodSpecial.setClientTimeout(<span class="number">100</span>);</span><br><span class="line">consumerBean.setMethodSpecials(<span class="keyword">new</span> MethodSpecial[]&#123;methodSpecial&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>Spring 配置 HSF 服务。</p>
<p>Spring 框架是在应用中广泛使用的组件，如果不想通过 API 的形式配置 HSF 服务，可以使用 Spring XML 的形式进行配置，上述例子中的 API 配置等同于如下 XML 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;CallHelloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringConsumerBean&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodSpecials&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.model.metadata.MethodSpecial&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;queryOrder&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注解配置。</p>
<p>SpringBoot 广泛使用的今天，使用注解装配 SpringBean 也成为一种选择，HSF 也支持使用注解进行配置，用来订阅服务。</p>
<ol>
<li><p>在项目中增加依赖 starter。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pandora-hsf-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在代码中注解配置。</p>
<p>通常一个 HSF Consumer 需要在多个地方使用，但并不需要在每次使用的地方都用 @HSFConsumer 来标记。只需要写一个统一个 Config 类，然后在其它需要使用的地方，直接 @Autowired 注入即可上述例子中的 API 配置等同于如下注解配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HSFConsumer(clientTimeout = 1000, methodSpecials = @HSFConsumer.ConsumerMethodSpecial(methodName = &quot;queryOrder&quot;, clientTimeout = &quot;100&quot;))</span></span><br><span class="line"><span class="keyword">private</span> OderService orderService;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>客户端全局接口超时配置。</p>
<ul>
<li>在启动参数中添加 <code>-D defaultHsfClientTimeout=100</code></li>
<li>在代码中添加 <code>System.setProperty(&quot;defaultHsfClientTimeout&quot;, “100”)</code></li>
</ul>
</li>
</ul>
<h3 id="服务端方法超时配置"><a href="#服务端方法超时配置" class="headerlink" title="服务端方法超时配置"></a>服务端方法超时配置</h3><ul>
<li><p>API 配置 HSF 服务。</p>
<p>配置 HSFApiProviderBean 的 clientTimeout 属性，单位是 ms，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSFApiProviderBean providerBean = <span class="keyword">new</span> HSFApiProviderBean();</span><br><span class="line"><span class="comment">// 接口级别超时配置</span></span><br><span class="line">providerBean.setClientTimeout(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// xxx</span></span><br><span class="line">MethodSpecial methodSpecial = <span class="keyword">new</span> MethodSpecial();</span><br><span class="line">methodSpecial.setMethodName(<span class="string">&quot;queryOrder&quot;</span>);</span><br><span class="line"><span class="comment">// 方法级别超时配置，优先于接口超时配置</span></span><br><span class="line">methodSpecial.setClientTimeout(<span class="number">100</span>);</span><br><span class="line">providerBean.setMethodSpecials(<span class="keyword">new</span> MethodSpecial[]&#123;methodSpecial&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>Spring 配置 HSF 服务。</p>
<p>Spring 框架是在应用中广泛使用的组件，如果不想通过 API 的形式配置 HSF 服务，可以使用 Spring XML 的形式进行配置，上述例子中的 API 配置等同于如下 XML 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringProviderBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodSpecials&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.model.metadata.MethodSpecial&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;queryOrder&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注解配置 HSF 服务。</p>
<p>注入即可上述例子中的 API 配置等同于如下注解配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HSFProvider(serviceInterface = OrderService.class, clientTimeout = 3000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDAO orderDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderModel <span class="title">queryOrder</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderDAO.queryOrder(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="服务端线程池配置"><a href="#服务端线程池配置" class="headerlink" title="服务端线程池配置"></a>服务端线程池配置</h2><p>本文介绍开发 HSF 应用过程中如何进行服务端线程池配置。</p>
<h3 id="前提条件-4"><a href="#前提条件-4" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开发应用前，您已经完成以下工作：</p>
<ul>
<li><a href="https://help.aliyun.com/document_detail/66643.htm#task-2310132">配置 EDAS 的私服地址和轻量级配置及注册中心</a></li>
<li><a href="https://help.aliyun.com/document_detail/44163.htm#task-2310117">启动轻量级配置及注册中心</a></li>
</ul>
<h3 id="服务线程池业务示意图"><a href="#服务线程池业务示意图" class="headerlink" title="服务线程池业务示意图"></a>服务线程池业务示意图</h3><p>HSF 服务端线程池主要分为 IO 线程和业务线程，其中 IO 线程模型就是 netty reactor 网络模型中使用的。我们主要讨论业务线程池的配置。业务线程池分为默认业务线程池和服务线程池，其中服务线程池是从默认线程池中分割出来的。</p>
<p><img src="Java-Framework-HSF-Operation/%E6%9C%8D%E5%8A%A1%E7%BA%BF%E7%A8%8B%E4%B8%9A%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="服务线程业务示意图"></p>
<h3 id="默认线程池配置"><a href="#默认线程池配置" class="headerlink" title="默认线程池配置"></a>默认线程池配置</h3><p>服务端线程池是用来执行业务逻辑的线程池，线程池默认的 core size 是 50，max size 是 720，keepAliveTime 500s。队列使用的是 SynchronousQueue，没有缓存队列，不会堆积用户请求。 当服务端线程池所有线程（720）都在处理请求时，对于新的请求，会立即拒绝，返回 Thread pool is full 异常。可以使用下面 VM 参数（-D 参数）进行配置。</p>
<ul>
<li>线程池最小配置：<code>-D hsf.server.min.poolsize</code></li>
<li>线程池最大配置：<code>-D hsf.server.max.poolsize</code></li>
<li>线程收敛的存活时间：<code>-D hsf.server.thread.keepalive</code></li>
</ul>
<h3 id="服务线程池配置"><a href="#服务线程池配置" class="headerlink" title="服务线程池配置"></a>服务线程池配置</h3><p>对于一些慢服务、并发高，可以为其单独配置线程池，以免占用过多的业务线程，影响应用的其他服务的调用。</p>
<ul>
<li><p>API 形式配置 HSF 服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSFApiProviderBean hsfApiProviderBean = <span class="keyword">new</span> HSFApiProviderBean();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">hsfApiProviderBean.setCorePoolSize(<span class="string">&quot;50&quot;</span>);</span><br><span class="line">hsfApiProviderBean.setMaxPoolSize(<span class="string">&quot;200&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Spring 配置 HSF 服务</p>
<p>Spring 框架是在应用中广泛使用的组件，如果不想通过 API 的形式配置 HSF 服务，可以使用 Spring XML 的形式进行配置，上述例子中的 API 配置等同于如下 XML 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringProviderBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[设置] 发布服务的接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.alibaba.middleware.hsf.guide.api.service.OrderService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注解配置 HSF 服务</p>
<p>SpringBoot 广泛使用的今天，使用注解装配 SpringBean 也成为一种选择，HSF 也支持使用注解进行配置，用来发布服务。</p>
<ol>
<li><p>在项目中增加依赖 starter。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pandora-hsf-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将 @HSFProvider 配置到实现的类型。</p>
<p>上述例子中的 API 配置等同于如下注解配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HSFProvider(serviceInterface = OrderService.class, corePoolSize = 50, maxPoolSize = 200)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDAO orderDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderModel <span class="title">queryOrder</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderDAO.queryOrder(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="API-手册"><a href="#API-手册" class="headerlink" title="API 手册"></a>API 手册</h2><p>在 HSF 应用的 API 中，最关键的是创建 ProviderBean 和 ConsumerBean 相关的 API。</p>
<h3 id="背景信息-1"><a href="#背景信息-1" class="headerlink" title="背景信息"></a>背景信息</h3><p>根据用户使用的场景不同，主要分为4个关键的类。</p>
<ul>
<li>com.taobao.hsf.app.api.util.HSFApiProviderBean: 通过 API 编程的方式创建 Provider Bean。</li>
<li>com.taobao.hsf.app.api.util.HSFApiConsumerBean: 通过 API 编程的方式创建 Consumer Bean。</li>
<li>com.taobao.hsf.app.spring.util.HSFSpringProviderBean: 通过 Spring 配置的方式创建 Provider Bean。</li>
<li>com.taobao.hsf.app.spring.util.HSFSpringConsumerBean: 通过 Spring 配置的方式创建 Consumer Bean。</li>
</ul>
<p>其中，HSFSpringXxxBean 的配置属性与 HSFApiXxxBean 的 setter 方法相对应。接下来就分别以 ProviderBean 和 ConsumerBean 的视角介绍这 4 个类的 API。</p>
<h3 id="ProviderBean"><a href="#ProviderBean" class="headerlink" title="ProviderBean"></a>ProviderBean</h3><ul>
<li><p>API 编程方式 - HSFApiProviderBean</p>
<p>通过配置并初始化 com.taobao.hsf.app.api.util.HSFApiProviderBean 即可完成 HSF 服务的发布。</p>
<p>对于一个服务，com.taobao.hsf.app.api.util.HSFApiProviderBean 的配置及初始化过程只需配置一次。此外，考虑到 HSFApiProviderBean 对象比较复杂，建议缓存。</p>
<ul>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化并配置Provider Bean</span></span><br><span class="line">HSFApiProviderBean hsfApiProviderBean = <span class="keyword">new</span> HSFApiProviderBean();</span><br><span class="line">hsfApiProviderBean.setServiceInterface(<span class="string">&quot;com.taobao.hsf.test.HelloWorldService&quot;</span>);</span><br><span class="line">hsfApiProviderBean.setTarget(target); <span class="comment">// target 为 serviceInterface 指定接口的实现对象hsfApiProviderBean.setServiceVersion(&quot;1.0.0&quot;);</span></span><br><span class="line">hsfApiProviderBean.setServiceGroup(<span class="string">&quot;HSF&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Provider Bean，发布服务</span></span><br><span class="line">hsfApiProviderBean.init();</span><br></pre></td></tr></table></figure></li>
<li><p>可配置属性表：</p>
<p>除上述示例代码中设置的属性，HSFApiProviderBean 还包含许多其他可配置的属性，均可通过对应的 setter 方法进行设置。</p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">类型</th>
<th align="left">是否必选</th>
<th align="left">默认值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">serviceInterface</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">无</td>
<td align="left">设置 HSF 服务对外提供的业务接口。客户端通过此属性进行订阅。</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">Object</td>
<td align="left">是</td>
<td align="left">无</td>
<td align="left">设置 serviceInterface 指定接口的服务实现对象。</td>
</tr>
<tr>
<td align="left">serviceVersion</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">1.0.0</td>
<td align="left">设置服务的版本号。客户端通过此属性进行订阅。</td>
</tr>
<tr>
<td align="left">serviceGroup</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">HSF</td>
<td align="left">设置服务的组别。客户端通过此属性进行订阅。</td>
</tr>
<tr>
<td align="left">serviceDesc</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">null</td>
<td align="left">设置服务的描述，从而方便管理。</td>
</tr>
<tr>
<td align="left">clientTimeout</td>
<td align="left">int</td>
<td align="left">否</td>
<td align="left">3000</td>
<td align="left">设置响应超时时间（单位：毫秒）。如果服务端在设置的时间内没有返回，则抛出 HSFTimeOutException。</td>
</tr>
<tr>
<td align="left">methodSpecials</td>
<td align="left">MethodSpecial[]</td>
<td align="left">否</td>
<td align="left">空</td>
<td align="left">设置服务中某些方法的响应超时时间。通过设置 MethodSpecial.methodName 指定方法名，通过设置 MethodSpecial.clientTimout 指定当前方法的超时时间，优先级高于当前服务端的 clientTimeout。</td>
</tr>
<tr>
<td align="left">preferSerializeType</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">hessian2</td>
<td align="left">针对 HSF2，设置服务的请求参数和响应结果的序列化方式。可选值有 Java、hessian、hessian2、json 和 kryo。</td>
</tr>
<tr>
<td align="left">corePoolSize</td>
<td align="left">值为整型的String</td>
<td align="left">否</td>
<td align="left">0</td>
<td align="left">配置服务单独的线程池，并指定最小活跃线程数量。若不设置该属性，则默认使用 HSF 服务端的公共线程池。</td>
</tr>
<tr>
<td align="left">maxPoolSize</td>
<td align="left">值为整型的String</td>
<td align="left">否</td>
<td align="left">0</td>
<td align="left">配置服务单独的线程池，并指定最大活跃线程数量。若不设置该属性，则默认使用 HSF 服务端的公共线程池。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Spring 配置方式 - HSFSpringProviderBean</p>
<p>通过在 Spring 配置文件中，配置一个 class 为 com.taobao.hsf.app.spring.util.HSFSpringProviderBean 的 bean，即可完成 HSF 服务的发布。</p>
<p>示例代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorldService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.test.HelloWorldService&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringProviderBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- [必选] 设置HSF服务对外提供的业务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.taobao.hsf.test.HelloWorldService&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [必选] 设置serviceInterface指定接口的服务实现对象，即需要发布为HSF服务的spring bean id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloWorldService&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置服务的版本号，默认为1.0.0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceVersion&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置服务的组别，默认为HSF --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceGroup&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HSF&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置服务的描述，从而方便管理，默认为null --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceDesc&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HelloWorldService providered by HSF&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置响应超时时间（单位：毫秒）。如果服务端在设置的时间内没有返回，则抛出HSFTimeOutException --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认为3000 ms --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置服务中某些方法的响应超时时间。优先级高于上面的clientTimeout --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过设置MethodSpecial.methodName指定方法名，MethodSpecial.clientTimout指定方法的超时时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodSpecials&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.model.metadata.MethodSpecial&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sum&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置服务的请求参数和响应结果的序列化方式。可选值包含java、hessian、hessian2、json和kryo --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认为hessian2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;preferSerializeType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hessian2&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 配置服务单独的线程池，并指定最小活跃线程数量。若不设置该属性，则默认使用HSF服务端的公共线程池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 配置服务单独的线程池，并指定最大活跃线程数量。若不设置该属性，则默认使用HSF服务端的公共线程池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ConsumerBean"><a href="#ConsumerBean" class="headerlink" title="ConsumerBean"></a>ConsumerBean</h3><ul>
<li><p>API 配置方式 - HSFApiConsumerBean</p>
<p>通过配置并初始化 com.taobao.hsf.app.api.util.HSFApiConsumerBean 完成 HSF 服务的订阅。</p>
<p>对于同一个服务，com.taobao.hsf.app.api.util.HSFApiConsumerBean 的配置及初始化过程只需配置一次。</p>
<p>由于 HSFApiConsumerBean 对象内容多，建议将该对象以及获取到的 HSF 代理进行缓存。</p>
<p><strong>说明</strong> 在 HSF 内部 HSFApiConsumerBean 对服务的配置是缓存起来的。即如果对某个订阅的服务进行了多次配置，只有第一次的配置生效。</p>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化并配置 Consumer Bean</span></span><br><span class="line">HSFApiConsumerBean hsfApiConsumerBean = <span class="keyword">new</span> HSFApiConsumerBean();</span><br><span class="line">hsfApiConsumerBean.setInterfaceName(<span class="string">&quot;com.taobao.hsf.test.HelloWorldService&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setVersion(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">hsfApiConsumerBean.setGroup(<span class="string">&quot;HSF&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Consumer Bean，订阅服务</span></span><br><span class="line"><span class="comment">// true表示等待地址推送（超时时间为3000毫秒），默认为false（异步）</span></span><br><span class="line">hsfApiConsumerBean.init(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 HSF 代理</span></span><br><span class="line">HelloWorldService helloWorldService = (HelloWorldService) hsfApiConsumerBean.getObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起 HSF 调用</span></span><br><span class="line">String helloStr = helloWorldService.sayHello(<span class="string">&quot;Li Lei&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>可配置属性表</p>
<p>除上述示例代码中设置的属性，HSFApiConsumerBean 还包含许多其他可配置的属性，均可通过对应的 setter 方法进行设置。</p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">类型</th>
<th align="left">是否必选</th>
<th align="left">默认值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">interfaceName</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">无</td>
<td align="left">设置需要订阅服务的接口名。客户端通过此属性进行订阅。</td>
</tr>
<tr>
<td align="left">version</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">无</td>
<td align="left">设置需要订阅服务的版本号。客户端通过此属性进行订阅。</td>
</tr>
<tr>
<td align="left">group</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">无</td>
<td align="left">设置需要订阅服务的组别。客户端通过此属性进行订阅。</td>
</tr>
<tr>
<td align="left">clientTimeout</td>
<td align="left">int</td>
<td align="left">否</td>
<td align="left">无</td>
<td align="left">设置请求超时时间（单位：毫秒）。如果客户端在设置的时间内没有收到服务端响应，则抛出 HSFTimeOutException。 若客户端设置了clientTimeout，则优先级高于服务端设置的 clientTimeout。否则，在服务的远程调用过程中，使用服务端设置的 clientTimeout。</td>
</tr>
<tr>
<td align="left">methodSpecials</td>
<td align="left">MethodSpecial[]</td>
<td align="left">否</td>
<td align="left">空</td>
<td align="left">设置服务中某些方法的请求超时时间。通过设置 MethodSpecial.methodName 指定方法名，通过设置 MethodSpecial.clientTimout 指定当前方法的超时时间，优先级高于当前客户端的 clientTimeout。</td>
</tr>
<tr>
<td align="left">maxWaitTimeForCsAddress</td>
<td align="left">int</td>
<td align="left">否</td>
<td align="left">无</td>
<td align="left">设置同步等待 ConfigServer 推送地址的时间（单位：毫秒），从而避免因地址还未推送到就发起服务调用造成的 HSFAddressNotFoundException。一般建议设置为 5000 毫秒，即可满足推送等待时间。</td>
</tr>
<tr>
<td align="left">asyncallMethods</td>
<td align="left">List</td>
<td align="left">否</td>
<td align="left">null</td>
<td align="left">设置需要异步调用的方法列表。List中的每一个字符串的格式为：name：方法名 type：异步调用类型 listener：监听器其中 listener 只对 callback 类型的异步调用生效。type 的类型有：future：通过 Future 的方式去获取请求执行的结果。callback：当远程服务的调用完成后，HSF 会使用响应结果回调此处配置的 listener，该 listener 需要实现 HSFResponseCallback 接口。</td>
</tr>
<tr>
<td align="left">proxyStyle</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">jdk</td>
<td align="left">设置服务的代理模式，一般不用配置。如果要拦截这个 consumer bean，需要配置成 javassist。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Spring 配置方式 - HSFSpringConsumerBean</p>
<p>通过在 Spring 配置文件中，配置一个 class为com.taobao.hsf.app.api.util.HSFSpringConsumerBean 的 bean，即可实现服务的订阅。</p>
<p>示例代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorldService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.app.spring.util.HSFSpringConsumerBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- [必选] 设置需要订阅服务的接口名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaceName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.taobao.hsf.test.HelloWorldService&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [必选] 设置需要订阅服务的版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;version&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [必选] 设置需要订阅服务的组别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;group&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HSF&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置请求超时时间（单位：毫秒）。如果客户端在设置的时间内没有收到服务端响应，则抛出HSFTimeOutException --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 若客户端设置了clientTimeout，则优先级高于服务端设置的clientTimeout。否则，在服务的远程调用过程中，使用服务端设置的clientTimeout。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置服务中某些方法的请求超时时间，优先级高于当前客户端的clientTimeout --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过设置MethodSpecial.methodName指定方法名，通过设置MethodSpecial.clientTimout指定当前方法的超时时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodSpecials&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.taobao.hsf.model.metadata.MethodSpecial&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sum&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clientTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置同步等待ConfigServer推送地址的时间（单位：毫秒）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从而避免因地址还未推送到就发起服务调用造成的HSFAddressNotFoundException --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一般建议设置为5000毫秒，即可满足推送等待时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitTimeForCsAddress&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;5000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置需要异步调用的方法列表。List中的每一个字符串的格式为：--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name：方法名 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- type：异步调用类型 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- listener：监听器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其中，listener只对callback类型的异步调用生效--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- type的类型有： --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- future: 通过Future的方式去获取请求执行的结果 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- callback: 当远程服务的调用完成后，HSF会使用响应结果回调此处配置的listener，该listener需要实现HSFResponseCallback接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncallMethods&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>name:sayHello;type:callback;listener:com.taobao.hsf.test.service.HelloWorldServiceCallbackHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- [可选] 设置服务的代理模式，一般不用配置。如果要拦截这个consumer bean，需要配置成javassist --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;proxyStyle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="JVM-D-启动配置参数"><a href="#JVM-D-启动配置参数" class="headerlink" title="JVM -D 启动配置参数"></a>JVM -D 启动配置参数</h2><p>本文介绍 HSF 应用开发时 JVM -D 启动参数的配置信息。</p>
<h3 id="D-hsf-server-port"><a href="#D-hsf-server-port" class="headerlink" title="-D hsf.server.port"></a>-D hsf.server.port</h3><p>指定 HSF 的启动服务绑定端口，默认为 12200。如果在本地启动多个 HSF Provider，则需要修改此端口。</p>
<h3 id="D-hsf-server-max-poolsize"><a href="#D-hsf-server-max-poolsize" class="headerlink" title="-D hsf.server.max.poolsize"></a>-D hsf.server.max.poolsize</h3><p>指定 HSF 的服务端最大线程池大小，默认值为<code>720</code>。</p>
<h3 id="D-hsf-server-min-poolsize"><a href="#D-hsf-server-min-poolsize" class="headerlink" title="-D hsf.server.min.poolsize"></a>-D hsf.server.min.poolsize</h3><p>指定 HSF 的服务端最小线程池大小，默认值为<code>50</code>。</p>
<h3 id="D-hsf-client-localcall"><a href="#D-hsf-client-localcall" class="headerlink" title="-D hsf.client.localcall"></a>-D hsf.client.localcall</h3><p>打开或者关闭本地优先调用，默认值为<code>true</code>。</p>
<h3 id="D-pandora-qos-port"><a href="#D-pandora-qos-port" class="headerlink" title="-D pandora.qos.port"></a>-D pandora.qos.port</h3><p>指定 Pandora 监控端口，默认值为<code>12201</code>。如果在本地启动多个 HSF Provider，则需要修改此端口。</p>
<h3 id="D-hsf-http-enable"><a href="#D-hsf-http-enable" class="headerlink" title="-D hsf.http.enable"></a>-D hsf.http.enable</h3><p>是否开启 HTTP 端口，默认为<code> true</code>。</p>
<h3 id="D-hsf-http-port"><a href="#D-hsf-http-port" class="headerlink" title="-D hsf.http.port"></a>-D hsf.http.port</h3><p>指定 HSF 暴露的 HTTP 接口，默认值为<code>12220</code>。如果在本地启动多个 HSF Provider，则需要修改此端口。</p>
<h3 id="D-hsf-run-mode"><a href="#D-hsf-run-mode" class="headerlink" title="-D hsf.run.mode"></a>-D hsf.run.mode</h3><p>指定 HSF 客户端是否指定 target 进行调用，即绕开 ConfigServer。值为<code>1</code>，表示不允许指定 target 调用；值为<code>0</code>，表示允许指定 target 调用。默认值为<code>1</code>时，不推荐指定为<code>0</code>。</p>
<h3 id="D-hsf-shuthook-wait"><a href="#D-hsf-shuthook-wait" class="headerlink" title="-D hsf.shuthook.wait"></a>-D hsf.shuthook.wait</h3><p>HSF 优雅关闭的等待时间，单位是 ms，默认是<code>10000</code>。</p>
<h3 id="D-hsf-publish-delayed"><a href="#D-hsf-publish-delayed" class="headerlink" title="-D hsf.publish.delayed"></a>-D hsf.publish.delayed</h3><p>是否所有的服务都需要延迟发布，默认是false，不需要延迟发布 。</p>
<h3 id="D-hsf-server-ip"><a href="#D-hsf-server-ip" class="headerlink" title="-D hsf.server.ip"></a>-D hsf.server.ip</h3><p>指定需要绑定的 IP 地址。在多网卡情况下默认绑定第一个网卡，通过该参数指定需要绑定的 IP。</p>
<h3 id="D-HsfBindHost"><a href="#D-HsfBindHost" class="headerlink" title="-D HsfBindHost"></a>-D HsfBindHost</h3><p>指定需要绑定的 Host。在多网卡情况下默认绑定和上报给地址注册中心第一个网卡的IP地址，通过该参数可以指定需要绑定的 Host，列如<code>-DHsfBindHost=0.0.0.0</code>将 HSF Server 端口绑定本机所有网卡。</p>
<h3 id="D-hsf-publish-interval-400"><a href="#D-hsf-publish-interval-400" class="headerlink" title="-D hsf.publish.interval=400"></a>-D hsf.publish.interval=400</h3><p>指定发布服务之间的时间间隔。HSF 服务发布时会瞬间暴露出去，在应用启动时如果承受不住压力，可以配置该参数。默认值是 400，单位 ms。</p>
<h3 id="D-hsf-client-low-water-mark-32-D-hsf-client-high-water-mark-64-D-hsf-server-low-water-mark-32-D-hsf-server-high-water-mark-64"><a href="#D-hsf-client-low-water-mark-32-D-hsf-client-high-water-mark-64-D-hsf-server-low-water-mark-32-D-hsf-server-high-water-mark-64" class="headerlink" title="-D hsf.client.low.water.mark=32 -D hsf.client.high.water.mark=64 -D hsf.server.low.water.mark=32 -D hsf.server.high.water.mark=64"></a>-D hsf.client.low.water.mark=32 -D hsf.client.high.water.mark=64 -D hsf.server.low.water.mark=32 -D hsf.server.high.water.mark=64</h3><p>指定客户端或者服务端的每个 channel 写缓冲的限制。</p>
<ul>
<li>客户端每个 channel 的写缓冲的限制，单位为 KB，一旦超过高水位，channel 禁写，新的请求放弃写出，直接报错。禁写之后，等到缓冲区低于低水位才能恢复。</li>
<li>服务端每个 channel 的写缓冲的限制，单位为 KB，超过高水位时，新的响应放弃写出，客户端收不到响应会超时。缓冲区低于低水位时才能恢复写。</li>
<li>高低水位需成对设置，并且需要高水位大于低水位。</li>
</ul>
<h3 id="D-hsf-generic-remove-class-true"><a href="#D-hsf-generic-remove-class-true" class="headerlink" title="-D hsf.generic.remove.class=true"></a>-D hsf.generic.remove.class=true</h3><p>获取泛化调用的结果，但不输出<code>class</code>字段信息。</p>
<h3 id="D-defaultHsfClientTimeout"><a href="#D-defaultHsfClientTimeout" class="headerlink" title="-D defaultHsfClientTimeout"></a>-D defaultHsfClientTimeout</h3><p>全局的客户端超时配置。</p>
<h3 id="D-hsf-invocation-timeout-sensitive"><a href="#D-hsf-invocation-timeout-sensitive" class="headerlink" title="-D hsf.invocation.timeout.sensitive"></a>-D hsf.invocation.timeout.sensitive</h3><p><code>hsf.invocation.timeout.sensitive</code> 默认值设置为 false，决定 HSF 调用时间是否包含创建连接、选址等耗时逻辑。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>阿里</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 幂等设计</title>
    <url>/articles/Java-Idempotent-Design.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小伙伴们有没有遇到过<strong>生产环境经常出现过重复的数据？</strong>在排查问题的时候，数据又是正常的。这个是何解呢？<strong>怎么会出现这种情况，而且还很难排查问题</strong>。</p>
<p>今天给大家分享一下这里的原因，以及解决方案。</p>
<span id="more"></span>

<h1 id="罪魁祸首"><a href="#罪魁祸首" class="headerlink" title="罪魁祸首"></a>罪魁祸首</h1><p>产生<strong>重复数据或数据不一致</strong>（假定程序业务代码没问题），绝大部分就是发生了<strong>重复的请求</strong>，<strong>重复请求是指同一个请求因为某些原因被多次提交</strong>。导致这个情况会有<strong>几种场景</strong>：</p>
<p>1）<strong>微服务场景</strong>，在我们传统应用架构中调用接口，要么成功，要么失败。但是<strong>在微服务架构下，会有第三个情况【未知】，也就是超时</strong>。如果超时了，<strong>微服务框架会进行重试。</strong></p>
<p>2）用户<strong>交互的时候多次点击</strong>。如：快速点击按钮多次。</p>
<p>3）MQ 消息中间件，<strong>消息重复消费</strong>。</p>
<p>4）第三方平台的接口（如：支付成功回调接口），因为异常也会导致多次异步回调。</p>
<p>5）其他中间件/应用服务根据自身的特性，也有可能进行重试。</p>
<p>我们知道了发生的原因，<strong>本质就是多次请求了，那如何解决呢？</strong></p>
<h1 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a><strong>幂等性</strong></h1><p>有些小伙伴们会想到<strong>幂等</strong>这个词，是的，就是我们在设计某些接口时，要考虑如何保证接口幂等，<strong>那什么是接口幂等呢？</strong></p>
<blockquote>
<p>网上是这样介绍的【接口的幂等性实际上就是<strong>接口可重复调用</strong>,在调用方多次调用的情况下，接口<strong>最终得到的结果是一致的</strong>】</p>
</blockquote>
<p>网上的说法定义，有点不是太正确，我们看下怎么不正确</p>
<blockquote>
<p>如<strong>一个线程请求用户列表接口</strong>：select * from user，返回用户表中的数据，而<strong>另一个线程往用户表插入数据</strong>。那请求用户列表的线程返回的数据每次都不一样，那按照上面的说法，<strong>查询用户列表的接口就不是幂等的，</strong>这显然是不正确的。</p>
</blockquote>
<p>我的理解应该是<strong>多次调用对系统的产生的影响是一样的，即对资源的作用是一样的，但是返回值允许不同。</strong></p>
<h1 id="幂等场景"><a href="#幂等场景" class="headerlink" title="幂等场景"></a><strong>幂等场景</strong></h1><p>我们来看一下 SQL 相关业务<strong>是否幂等？</strong></p>
<p>一. <strong>查询</strong>，select * from user where xxx，不会对数据产生任何变化，<strong>具备幂等性</strong>。</p>
<p>二. <strong>新增</strong>，insert into user(userid,name) values(1,’a’)</p>
<blockquote>
<p>如 <strong>userid 为唯一主键</strong>，即重复操作上面的业务，只会插入一条用户数据，<strong>具备幂等性</strong>。</p>
<p>如 <strong>userid 不是主键</strong>，可以重复，那上面业务多次操作，数据都会新增多条，<strong>不具备幂等性</strong>。</p>
</blockquote>
<p>三. <strong>修改</strong>，区分直接赋值和计算赋值。</p>
<blockquote>
<p>1、<strong>直接赋值</strong>，update user set point = 20 where userid=1，不管执行多少次，point 都一样，<strong>具备幂等性</strong>。</p>
<p>2、<strong>计算赋值</strong>，update user set point = point + 20 where userid=1，每次操作 point 数据都不一样，<strong>不具备幂等性</strong>。</p>
</blockquote>
<p>四. <strong>删除</strong>，delete from user where userid=1，多次操作，结果一样，<strong>具备幂等性。</strong></p>
<blockquote>
<p>上面场景中，我们发现新增没有唯一主键约束的数据，和修改计算赋值型操作都不具备幂等性</p>
</blockquote>
<p><strong>那怎么去解决呢？</strong></p>
<blockquote>
<p>网上介绍很多，但介绍得太简单了，且关键点都没有介绍到。</p>
<p>这里只介绍常用的方案.</p>
</blockquote>
<h1 id="token-机制"><a href="#token-机制" class="headerlink" title="token 机制"></a>token 机制</h1><p>token 方式的流程，上一张图，比较清晰</p>
<p>![何为幂等？如何设计？](Java-Idempotent-Design/token 机制.png)</p>
<p>上图就是 <strong>token + Redis 的幂等方案</strong>，适用绝大部分场景。</p>
<p>主要思想：</p>
<blockquote>
<p>1、服务端<strong>提供了发送 token 的接口</strong>。我们在分析业务的时候，<strong>哪些业务是存在幂等问题的</strong>，就<strong>必须在执行业务前，先去获取 token</strong>，服务器会把 <strong>token 保存到 Redis</strong> 中。（微服务肯定是分布式了，如果单机就适用 JVM 缓存）。</p>
<p>2、然后<strong>调用业务接口请求时，把 token 携带过去</strong>，一般放在请求头部。</p>
<p>3、服务器<strong>判断 token 是否存在 Redis</strong> 中，<strong>存在表示第一次请求</strong>，可以继续执行业务，执行业务完成后，<strong>最后需要把 Redis 中的 token 删除</strong>。</p>
<p>4、如果<strong>判断 token 不存在 Redis</strong> 中，就表示是<strong>重复操作，直接返回重复标记给 client</strong>，这样就保证了业务代码，不被重复执行。</p>
</blockquote>
<p>这种方案是比较常用的方案，也是网上经常介绍的，但是有一点不同的地方：</p>
<blockquote>
<p>网上方案：检验 token 存在（表示第一次请求）后，<strong>就立刻删除 token，再进行业务处理</strong></p>
<p>上面方案：检验 token 存在（表示第一次请求）后，<strong>先进行业务处理，再删除 token</strong></p>
</blockquote>
<p><strong>关键点就是 先删除 token，还是后删除 token。</strong></p>
<p><strong>一、网上方案缺点</strong></p>
<blockquote>
<p>我们看下网上方案，<strong>先删除 token</strong>，这是出现系统问题导致<strong>业务处理出现异常</strong>，业务处理没有成功，接口调用方也没有获取到明确的结果，然后<strong>进行重试，但 token 已经删除掉了</strong>，服务端判断 token 不存在，<strong>认为是重复请求，就直接返回了</strong>，无法进行业务处理了。</p>
</blockquote>
<p><strong>二、上面方案缺点</strong></p>
<blockquote>
<p><strong>后删除 token</strong> 也是会存在问题的，如果进行业务处理成功后，删除 Redis 中的 token 失败了，这样就导致了有可能会发生重复请求，因为 token 没有被删除</p>
</blockquote>
<p>小伙伴们有没有发现，其实上面的问题就是<strong>数据库和缓存 Redis 数据不一致</strong>的问题。</p>
<p>之前在秒杀场景系列中整理了一篇文章，里面详细介绍了<strong>如何解决数据库和缓存 Redis 数据不一致的问题</strong>，小伙伴们可自行查阅。</p>
<blockquote>
<p>其实根据这个场景的业务，可以有个简单的处理方式。<strong>笔者推荐是网上方案先删除 token</strong>，先保证不会因为重复请求，业务数据出现问题。顶多再让用户处理一次。</p>
</blockquote>
<p>出现业务异常，可以让调用方配合处理一下，<strong>重新获取新的 token，再次由业务调用方发起重试请求就 OjbK 了</strong>。</p>
<h2 id="token机制缺点"><a href="#token机制缺点" class="headerlink" title="token机制缺点"></a>token机制缺点</h2><p>小伙伴们有没有发现，<strong>业务请求每次请求，都会有额外的请求（一次获取 token 请求、判断 token 是否存在的业务）</strong>。其实真实的生产环境中，<strong>1 万请求也许只会存在 10 个左右的请求会发生重试</strong>，为了这 10 个请求，我们让 <strong>9990 个请求都发生了额外的请求</strong>。（当然 Redis 性能很好，耗时不会太明显）</p>
<h1 id="乐观锁机制"><a href="#乐观锁机制" class="headerlink" title="乐观锁机制"></a>乐观锁机制</h1><p>关于乐观锁之前也讲过，大家可以去查阅。<strong>乐观锁这里解决了计算赋值型的修改场景</strong>。我们对之前的 SQL 语句进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set point = point + 20, version = version + 1 where userid=1 and version=1</span><br></pre></td></tr></table></figure>

<p><strong>加上了版本号后，就让此计算赋值型业务，具备了幂等性</strong>。</p>
<h2 id="乐观锁机制缺点"><a href="#乐观锁机制缺点" class="headerlink" title="乐观锁机制缺点"></a>乐观锁机制缺点</h2><p>就是在操作业务前，需要先查询出当前的 version 版本</p>
<h1 id="唯一主键机制"><a href="#唯一主键机制" class="headerlink" title="唯一主键机制"></a>唯一主键机制</h1><p>这个机制是<strong>利用了数据库的主键唯一约束的特性</strong>，解决了在 <strong>insert 场景</strong>时幂等问题。但主键的要求不是自增的主键，这样就需要业务<strong>生成全局唯一</strong>的主键，之前的文章也介绍过<strong>分布式唯一主键 ID</strong> 的生成，可自行查阅。</p>
<p>如果是<strong>分库分表场景下</strong>，<strong>路由规则要保证相同请求下</strong>，<strong>落地在同一个数据库和同一表中</strong>，要不然<strong>数据库主键约束就不起效果</strong>了，因为是不同的数据库和表主键不相关。</p>
<p>因为对主键有一定的要求，这个方案就跟业务有点耦合了，<strong>无法用自增主键了</strong>。</p>
<h1 id="去重表机制"><a href="#去重表机制" class="headerlink" title="去重表机制"></a>去重表机制</h1><p><strong>这个方案业务中要有唯一主键</strong>，这个去重表中只要一个字段就行，<strong>设置唯一主键约束</strong>，当然根据业务自行添加其他字段。</p>
<p>主要流程上图</p>
<p><img src="Java-Idempotent-Design/%E5%8E%BB%E9%87%8D%E8%A1%A8%E6%9C%BA%E5%88%B6.png" alt="何为幂等？如何设计？"></p>
<p>上面的主要流程就是 <strong>把唯一主键插入去重表，再进行业务操作，且他们在同一个事务中。</strong>这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，<strong>避免了幂等问题</strong>。</p>
<blockquote>
<p>这里要注意的是，<strong>去重表和业务表应该在同一库中</strong>，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。<strong>这个很好的保证了数据一致性</strong>。</p>
</blockquote>
<p>这个方案也是比较常用的，<strong>去重表是跟业务无关的</strong>，很多业务可以共用同一个去重表，只要规划好唯一主键就行了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面介绍了一些幂等方案，小伙伴们根据自身的业务进行选择，<strong>尽量不要让系统变的复杂</strong>，所以<strong>推荐唯一主键和乐观锁方式，因为实现比较简单</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>巅峰之旅（二）Java 灵魂拷问汇总</title>
    <url>/articles/Java-Interview-Menu.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 各技术栈 の 模拟面试实录汇总目录。</p>
<span id="more"></span>

<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><p>你了解 HashMap 吧？咱们聊聊？</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>了解 Java 内存模型么？你给我介绍一下……</p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>平时工作用过多线程吧？</p>
<p>用过线程池么？用过啊，那你讲讲……；没用过啊……那听说过么？</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>平时用 MySQL 是吧？咱们聊聊索引……</p>
<p>了解 MySQL 的隔离级别么？</p>
<p>看你简历里有写做过 MySQL 优化，你给我讲讲……</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>平时你在哪些场景使用 Redis 的？</p>
<p>聊一下你们公司的 Redis 集群吧……</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h1><p>看你简历里说做过秒杀，你是怎么做的呀？</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系列（二）如何优雅地异步下订单</title>
    <url>/articles/Java-SecKill-Asynchronous.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单的订单异步处理实现"><a href="#简单的订单异步处理实现" class="headerlink" title="简单的订单异步处理实现"></a>简单的订单异步处理实现</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>前面几篇文章，我们从 <strong>「限流角度，缓存角度」</strong> 来优化了用户下单的速度，减少了服务器和数据库的压力。这些处理对于一个秒杀系统都是非常重要的，并且效果立竿见影，那还有什么操作也能有立竿见影的效果呢？答案是对于下单的异步处理。</p>
<p>在秒杀系统用户进行抢购的过程中，由于在同一时间会有大量请求涌入服务器，如果每个请求都立即访问数据库进行扣减库存+写入订单的操作，对数据库的压力是巨大的。</p>
<p>如何减轻数据库的压力呢，<strong>「我们将每一条秒杀的请求存入消息队列（例如RabbitMQ）中，放入消息队列后，给用户返回类似“抢购请求发送成功”的结果。而在消息队列中，我们将收到的下订单请求一个个的写入数据库中」</strong>，比起多线程同步修改数据库的操作，大大缓解了数据库的连接压力，最主要的好处就表现在数据库连接的减少：</p>
<ul>
<li>同步方式：大量请求快速占满数据库框架开启的数据库连接池，同时修改数据库，导致数据库读写性能骤减。</li>
<li>异步方式：一条条消息以顺序的方式写入数据库，连接数几乎不变（当然，也取决于消息队列消费者的数量）。</li>
</ul>
<p><strong>「这种实现可以理解为是一中流量削峰：让数据库按照他的处理能力，从消息队列中拿取消息进行处理。」</strong></p>
<span id="more"></span>

<p>结合之前的四篇秒杀系统文章，这样整个流程图我们就实现了：</p>
<p><img src="Java-SecKill-Asynchronous/%E7%A7%92%E6%9D%80%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="img"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们在源码仓库里，新增一个 Controller 对外接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下单接口：异步处理订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/createUserOrderWithMq&quot;, method = &#123;RequestMethod.GET&#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createUserOrderWithMq</span><span class="params">(<span class="meta">@RequestParam(value = &quot;sid&quot;)</span> Integer sid,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="meta">@RequestParam(value = &quot;userId&quot;)</span> Integer userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查缓存中该用户是否已经下单过</span></span><br><span class="line">        Boolean hasOrder = orderService.checkUserOrderInfoInCache(sid, userId);</span><br><span class="line">        <span class="keyword">if</span> (hasOrder != <span class="keyword">null</span> &amp;&amp; hasOrder) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;该用户已经抢购过&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经抢购过了，不要太贪心.....&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有下单过，检查缓存中商品是否还有库存</span></span><br><span class="line">        log.info(<span class="string">&quot;没有抢购过，检查缓存中商品是否还有库存&quot;</span>);</span><br><span class="line">        Integer count = stockService.getStockCount(sid);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;秒杀请求失败，库存不足.....&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有库存，则将用户id和商品id封装为消息体传给消息队列处理</span></span><br><span class="line">        <span class="comment">// 注意这里的有库存和已经下单都是缓存中的结论，存在不可靠性，在消息队列中会查表再次验证</span></span><br><span class="line">        log.info(<span class="string">&quot;有库存：[&#123;&#125;]&quot;</span>, count);</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;sid&quot;</span>, sid);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        sendToOrderQueue(jsonObject.toJSONString());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;秒杀请求提交成功&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;下单接口：异步处理订单异常：&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;秒杀请求失败，服务器正忙.....&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createUserOrderWithMq 接口整体流程如下：</p>
<ul>
<li>检查缓存中该用户是否已经下单过：在消息队列下单成功后写入 Redis 一条用户 id 和商品 id 绑定的数据</li>
<li>没有下单过，检查缓存中商品是否还有库存</li>
<li>缓存中如果有库存，则将用户 id 和商品 id 封装为消息体 <strong>「传给消息队列处理」</strong></li>
<li>注意：这里的 <strong>「有库存和已经下单」</strong> 都是缓存中的结论，存在不可靠性，在消息队列中会查表再次验证， <strong>「作为兜底逻辑」</strong></li>
</ul>
<p>消息队列是如何接收消息的呢？我们新建一个消息队列，采用第四篇文中使用过的 RabbitMQ，我再稍微贴一下整个创建 RabbitMQ 的流程吧：</p>
<ol>
<li>pom.xml 新增 RabbitMq 的依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>写一个 RabbitMqConfig：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;orderQueue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加一个消费者：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;orderQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMqReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> log log = logFactory.getlog(OrderMqReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;OrderMqReceiver收到消息开始用户下单流程: &quot;</span> + message);</span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(message);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderService.createOrderByMq(jsonObject.getInteger(<span class="string">&quot;sid&quot;</span>),jsonObject.getInteger(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息处理异常：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的下单的操作，在 Service 中完成，我们在 orderService 中新建 createOrderByMq 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrderByMq</span><span class="params">(Integer sid, Integer userId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stock stock;</span><br><span class="line">    <span class="comment">// 校验库存（不要学我在trycatch中做逻辑处理，这样是不优雅的。这里这样处理是为了兼容之前的秒杀系统文章）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stock = checkStock(sid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 乐观锁更新库存</span></span><br><span class="line">    <span class="keyword">boolean</span> updateStock = saleStockOptimistic(stock);</span><br><span class="line">    <span class="keyword">if</span> (!updateStock) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;扣减库存失败，库存已经为0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;扣减库存成功，剩余库存：[&#123;&#125;]&quot;</span>, stock.getCount() - stock.getSale() - <span class="number">1</span>);</span><br><span class="line">    stockService.delStockCountCache(sid);</span><br><span class="line">    log.info(<span class="string">&quot;删除库存缓存&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建订单</span></span><br><span class="line">    log.info(<span class="string">&quot;写入订单至数据库&quot;</span>);</span><br><span class="line">    createOrderWithUserInfoInDB(stock, userId);</span><br><span class="line">    log.info(<span class="string">&quot;写入订单至缓存供查询&quot;</span>);</span><br><span class="line">    createOrderWithUserInfoInCache(stock, userId);</span><br><span class="line">    log.info(<span class="string">&quot;下单完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的下单的操作流程为：</p>
<ul>
<li>校验数据库库存</li>
<li>乐观锁更新库存（其他之前讲到的锁也可以啦）</li>
<li>写入订单至数据库</li>
<li><strong>「写入订单和用户信息至缓存供查询」</strong>：写入后，在外层接口便可以通过判断redis中是否存在用户和商品的抢购信息，来直接给用户返回“你已经抢购过”的消息。</li>
</ul>
<p><strong>「在 Redis 中记录商品和用户的关系，使用了 set 集合，key 是商品 id，而 value 则是用户 id 的集合，当然这样有一些不合理之处：」</strong></p>
<ul>
<li>这种结构默认了一个用户只能抢购一次这个商品</li>
<li>使用 set 集合，在用户过多后，每次检查需要遍历 set，用户过多有性能问题</li>
</ul>
<p>大家知道需要做这种操作就好，具体如何在生产环境的 Redis 中存储这种关系，大家可以深入优化下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">checkUserOrderInfoInCache</span><span class="params">(Integer sid, Integer userId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String key = CacheKey.USER_HAS_ORDER.getKey() + <span class="string">&quot;_&quot;</span> + sid;</span><br><span class="line">    log.info(<span class="string">&quot;检查用户Id：[&#123;&#125;] 是否抢购过商品Id：[&#123;&#125;] 检查Key：[&#123;&#125;]&quot;</span>, userId, sid, key);</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>「整个上述实现只考虑最精简的流程，不把前几篇文章的限流，验证用户等加入进来，并且默认考虑的是每个用户抢购一个商品就不再允许抢购，我的想法是保证每篇文章的独立性和代码的任务最小化，至于最后的整合我相信大佬们自己可以做到。」</strong></p>
<h1 id="非异步与异步下单接口的性能对比"><a href="#非异步与异步下单接口的性能对比" class="headerlink" title="非异步与异步下单接口的性能对比"></a>非异步与异步下单接口的性能对比</h1><p>接下来就是喜闻乐见的<strong>「非正规」</strong>性能测试环节，我们来对异步处理和非异步处理做一个性能对比。</p>
<p>首先，为了测试方便，我把用户购买限制先取消掉，不然我用 JMeter（JMeter 并发测试的使用方式参考 <a href="https://mp.weixin.qq.com/s?__biz=MzU1NTA0NTEwMg==&mid=2247484174&idx=1&sn=235af7ead49a7d33e7fab52e05d5021f&lang=zh_CN&scene=21#wechat_redirect">秒杀系统第一篇文章</a> ）还要来模拟多个用户 id，太麻烦了，不是我们的重点。我们把上面的 Controller 接口这一部分注释掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查缓存中该用户是否已经下单过</span></span><br><span class="line">Boolean hasOrder = orderService.checkUserOrderInfoInCache(sid, userId);</span><br><span class="line"><span class="keyword">if</span> (hasOrder != <span class="keyword">null</span> &amp;&amp; hasOrder) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;该用户已经抢购过&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你已经抢购过了，不要太贪心.....&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们可以用 JMeter 模拟抢购的情况了。</p>
<p><strong>「我们先玩票大的！」</strong> 在我这个 1c4g1m 带宽的云数据库上，<strong>「设置商品数量 5000 个，同时并发访问 10000 次」</strong>。</p>
<p>服务器先跑起来，访问接口是<code>http://localhost:8080/createUserOrderWithMq?sid=1&amp;userId=1</code></p>
<p>启动！</p>
<p>10000 个线程并发，直接把 1M 带宽小水管云数据库打穿了！</p>
<p><img src="Java-SecKill-Asynchronous/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BD%8E%E9%85%8D%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B4%A9%E6%BA%83.png" alt="图片"></p>
<p>对不起对不起，打扰了，我们还是老实一点，不要对这么低配置的数据库有不切实际的幻想。</p>
<p>我们改成 1000 个线程并发，商品库存为 500 个，<strong>「使用常规的非异步下单接口」</strong>：</p>
<p><img src="Java-SecKill-Asynchronous/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%84%E7%9A%84%E9%9D%9E%E5%BC%82%E6%AD%A5%E4%B8%8B%E5%8D%95%E6%8E%A5%E5%8F%A3.png" alt="图片"></p>
<p>对比 1000 个线程并发，<strong>「使用异步订单接口」</strong>：</p>
<p><img src="Java-SecKill-Asynchronous/%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AE%A2%E5%8D%95%E6%8E%A5%E5%8F%A3.png" alt="图片"></p>
<p><strong>「可以看到，非异步的情况下，吞吐量是 37 个请求/秒，而异步情况下，我们的接只是做了两个事情，检查缓存中库存+发消息给消息队列，所以吞吐量为 600 个请求/秒。」</strong></p>
<p>在发送完请求后，消息队列中立刻开始处理消息：</p>
<p><img src="Java-SecKill-Asynchronous/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.png" alt="img"></p>
<p><img src="../../../workSpace/secKill/secKill-doc/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%AE%A2%E5%8D%95%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.assets/640-20210221145615297" alt="图片"></p>
<p>我截图了在 500 个库存刚刚好消耗完的时候的日志，可以看到，一旦库存没有了，消息队列就完成不了扣减库存的操作，就不会将订单写入数据库，也不会向缓存中记录用户已经购买了该商品的消息。</p>
<p><img src="Java-SecKill-Asynchronous/%E5%BA%93%E5%AD%98%E5%8D%96%E5%AE%8C%E6%97%B6%E5%89%8D%E5%90%8E%E6%96%87%E6%97%A5%E5%BF%97.png" alt="图片"></p>
<h1 id="更加优雅的实现"><a href="#更加优雅的实现" class="headerlink" title="更加优雅的实现"></a>更加优雅的实现</h1><p>那么问题来了，我们实现了上面的异步处理后，用户那边得到的结果是怎么样的呢？</p>
<p>用户点击了提交订单，收到了消息：您的订单已经提交成功。然后用户啥也没看见，也没有订单号，用户开始慌了，点到了自己的个人中心——已付款。发现居然没有订单！（因为可能还在队列中处理）</p>
<p>这样的话，用户可能马上就要开始投诉了！太不人性化了，我们不能只为了开发方便，舍弃了用户体验！</p>
<p>所以我们要改进一下，如何改进呢？其实很简单：</p>
<ul>
<li>让前端在提交订单后，显示一个“排队中”，<strong>「就像我们在小米官网抢小米手机那样」</strong></li>
<li>同时，前端不断请求检查用户和商品是否已经有订单的接口，如果得到订单已经处理完成的消息，页面跳转抢购成功。</li>
</ul>
<p>实现起来，我们只要在后端加一个独立的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查缓存中用户是否已经生成订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/checkOrderByUserIdInCache&quot;, method = &#123;RequestMethod.GET&#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkOrderByUserIdInCache</span><span class="params">(<span class="meta">@RequestParam(value = &quot;sid&quot;)</span> Integer sid,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="meta">@RequestParam(value = &quot;userId&quot;)</span> Integer userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查缓存中该用户是否已经下单过</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Boolean hasOrder = orderService.checkUserOrderInfoInCache(sid, userId);</span><br><span class="line">        <span class="keyword">if</span> (hasOrder != <span class="keyword">null</span> &amp;&amp; hasOrder) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;恭喜您，已经抢购成功！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;检查订单异常：&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;很抱歉，你的订单尚未生成，继续排队吧您嘞。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来试验一下，首先我们请求两次下单的接口，大家用 Postman 或者浏览器就好：</p>
<p><a href="http://localhost:8080/createUserOrderWithMq?sid=1&amp;userId=1">http://localhost:8080/createUserOrderWithMq?sid=1&amp;userId=1</a></p>
<p><img src="Java-SecKill-Asynchronous/%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E6%8A%A2%E8%B4%AD%E8%BF%87.png" alt="图片"></p>
<p>可以看到，第一次请求，下单成功了，第二次请求，则会返回已经抢购过。</p>
<p>因为这时候 Redis 已经写入了该用户下过订单的数据：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers seckill_v1_user_has_order_1</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; smembers seckill_v1_user_has_order_1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们为了模拟消息队列处理茫茫多请求的行为，我们在下单的service方法中，让线程休息10秒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrderByMq</span><span class="params">(Integer sid, Integer userId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟多个用户同时抢购，导致消息队列排队等候10秒</span></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成下面的下单流程（省略）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们清除订单信息，开始下单：</p>
<p><a href="http://localhost:8080/createUserOrderWithMq?sid=1&amp;userId=1">http://localhost:8080/createUserOrderWithMq?sid=1&amp;userId=1</a></p>
<p><img src="Java-SecKill-Asynchronous/%E6%B8%85%E9%99%A4%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%E5%90%8E%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82.png" alt="图片"></p>
<p>第一次请求，返回信息如上图。</p>
<p>紧接着前端显示排队中的时候，请求检查是否已经生成订单的接口，接口返回”继续排队“：</p>
<p><img src="Java-SecKill-Asynchronous/%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E7%94%9F%E6%88%90%E8%AE%A2%E5%8D%95.png" alt="图片"></p>
<p>一直刷刷刷接口，10 秒之后，接口返回”恭喜您，抢购成功“，如下图：</p>
<p><img src="Java-SecKill-Asynchronous/%E6%8A%A2%E8%B4%AD%E6%88%90%E5%8A%9F.png" alt="图片"></p>
<p>整个流程就走完了。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>这篇文章介绍了如何在保证用户体验的情况下完成订单异步处理的流程。内容其实不多，深度没有前一篇那么难理解。（我拖更也有一部分原因是因为我觉得上一篇的深度我很难随随便便达到，就不敢随意写文章，有压力。）</p>
<p>希望大家喜欢，目前来看，整个秒杀下订单的主流程我们全部介绍完了。当然里面很多东西都非常基础，比如数据库设计我一直停留在那几个破字段，比如订单的编号，其实不可能用主键 id 来做等等。</p>
<p><strong>「所以之后文章的重点会更加关注某个特定的方面」</strong>，比如：</p>
<ul>
<li>分布式订单唯一编号的生成</li>
<li>网关层面的接口缓存</li>
<li>…</li>
</ul>
<p>当然，其他内容的文章也会不断积累总结啦。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>高并发</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系列（三）数据库与缓存双写问题的思考</title>
    <url>/articles/Java-SecKill-DB-Cache-Inconsistent.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="缓存热点数据"><a href="#缓存热点数据" class="headerlink" title="缓存热点数据"></a>缓存热点数据</h1><p>在秒杀实际的业务中，一定有很多需要做缓存的场景，比如售卖的商品，包括名称、详情等。访问量很大的数据，可以算是“热点”数据了，尤其是一些读取量远大于写入量的数据，更应该被缓存，而不应该让请求打到数据库上。</p>
<span id="more"></span>

<h2 id="为何要使用缓存"><a href="#为何要使用缓存" class="headerlink" title="为何要使用缓存"></a>为何要使用缓存</h2><p>缓存是为了追求“快”而存在的。我们用代码举一个例子。</p>
<p>拿出之前三篇文章的项目代码来，在其中增加两个查询库存的接口 getStockByDB 和 getStockByCache，分别表示从数据库和缓存查询某商品的库存量。</p>
<p>随后我们用 JMeter 进行并发请求测试。（JMeter 的使用请参考第一篇秒杀系统文章）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查询库存：通过数据库查询库存</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getStockByDB/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStockByDB</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count = stockService.getStockCountByDB(sid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;查询库存失败：[&#123;&#125;]&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询库存失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;商品Id: [&#123;&#125;] 剩余库存为: [&#123;&#125;]&quot;</span>, sid, count);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;商品Id: %d 剩余库存为：%d&quot;</span>, sid, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查询库存：通过缓存查询库存</span></span><br><span class="line"><span class="comment">  * 缓存命中：返回库存</span></span><br><span class="line"><span class="comment">  * 缓存未命中：查询数据库写入缓存并返回</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getStockByCache/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStockByCache</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    Integer count;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count = stockService.getStockCountByCache(sid);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">            count = stockService.getStockCountByDB(sid);</span><br><span class="line">            log.info(<span class="string">&quot;缓存未命中，查询数据库，并写入缓存&quot;</span>);</span><br><span class="line">            stockService.setStockCountToCache(sid, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;查询库存失败：[&#123;&#125;]&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询库存失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;商品Id: [&#123;&#125;] 剩余库存为: [&#123;&#125;]&quot;</span>, sid, count);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;商品Id: %d 剩余库存为：%d&quot;</span>, sid, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在设置为 10000 个并发请求的情况下，运行 JMeter，结果首先出现了大量的报错，10000 个请求中 98% 的请求都直接失败了。</p>
<p>打开日志，报错如下：</p>
<p>![图片](Java-SecKill-DB-Cache-Inconsistent/JMeter 报错结果.png)</p>
<p>原来是 SpringBoot 内置的 Tomcat 最大并发数搞的鬼，其默认值为 200，对于 10000 的并发，单机服务实在是力不从心。</p>
<p>当然，你可以修改这里的并发数设置，但是你的小机器仍然可能会扛不住。</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E5%B9%B6%E5%8F%91%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="图片"></p>
<p>将其修改为如下配置后，我的小机器才在通过缓存拿库存的情况下，保证了10000个并发的100%返回请求：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server.tomcat.max-threads=10000</span><br><span class="line">server.tomcat.max-connections=10000</span><br></pre></td></tr></table></figure>



<p>不使用缓存的情况下，吞吐量为 668 个请求每秒，并且有 5% 的请求由于服务压力实在太大，没有返回库存数据：</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%90%9E%E5%90%90%E9%87%8F.png" alt="图片"></p>
<p>使用缓存的情况下，吞吐量为2177个请求每秒：</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%90%9E%E5%90%90%E9%87%8F.png" alt="图片"></p>
<p>在这种“不严谨”的对比下，有缓存对于一台单机，性能提升了 3 倍多，如果在多台机器，更多并发的情况下，由于数据库有了更大的压力，缓存的性能优势应该会更加明显。</p>
<p>测完了这个小实验，我看了眼我挂着 MySQL 的小水管腾讯云服务器，生怕他被这么高流量搞挂。这种突发的流量，指不定会被检测为异常攻击流量呢~</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7.png" alt="图片"></p>
<p>我用的是腾讯云服务器1C4G2M，活动买的，很便宜。</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E4%BA%91%E6%9C%8D%E5%8A%A1%E6%9C%9F%E9%85%8D%E7%BD%AE.png" alt="图片"></p>
<h2 id="哪类数据适合缓存"><a href="#哪类数据适合缓存" class="headerlink" title="哪类数据适合缓存"></a>哪类数据适合缓存</h2><p>缓存量大但又不常变化的数据，比如详情、评论等。对于那些经常变化的数据，其实并不适合缓存，一方面会增加系统的复杂性（缓存的更新，缓存脏数据），另一方面也给系统带来一定的不稳定性（缓存系统的维护）。</p>
<p><strong>「但一些极端情况下，你需要将一些会变动的数据进行缓存，比如想要页面显示准实时的库存数，或者其他一些特殊业务场景。这时候你需要保证缓存不能（一直）有脏数据，这就需要再深入讨论一下。」</strong></p>
<h2 id="缓存的利与弊"><a href="#缓存的利与弊" class="headerlink" title="缓存的利与弊"></a>缓存的利与弊</h2><p>我们到底该不该上缓存的，这其实也是个 trade-off 的问题。</p>
<p>上缓存的优点：</p>
<ul>
<li>能够缩短服务的响应时间，给用户带来更好的体验。</li>
<li>能够增大系统的吞吐量，依然能够提升用户体验。</li>
<li>减轻数据库的压力，防止高峰期数据库被压垮，导致整个线上服务 BOOM！</li>
</ul>
<p>上了缓存，也会引入很多额外的问题：</p>
<ul>
<li>缓存有多种选型，是内存缓存，memcached 还是 Redis，你是否都熟悉，如果不熟悉，无疑增加了维护的难度（本来是个纯洁的数据库系统）。</li>
<li>缓存系统也要考虑分布式，比如 Redis 的分布式缓存还会有很多坑，无疑增加了系统的复杂性。</li>
<li>在特殊场景下，如果对缓存的准确性有非常高的要求，就必须考虑<strong>「缓存和数据库的一致性问题」</strong>。</li>
</ul>
<p><strong>「本文想要重点讨论的，就是缓存和数据库的一致性问题，客观且往下看。」</strong></p>
<h1 id="缓存和数据库双写一致性"><a href="#缓存和数据库双写一致性" class="headerlink" title="缓存和数据库双写一致性"></a>缓存和数据库双写一致性</h1><p>说了这么多缓存的必要性，那么使用缓存是不是就是一个很简单的事情了呢，我之前也一直是这么觉得的，直到遇到了需要缓存与数据库保持强一致的场景，才知道让数据库数据和缓存数据保持一致性是一门很高深的学问。</p>
<p>从远古的硬件缓存，操作系统缓存开始，缓存就是一门独特的学问。这个问题也被业界探讨了非常久，争论至今。我翻阅了很多资料，发现其实这是一个权衡的问题。值得好好讲讲。</p>
<p>以下的讨论会引入几方观点，我会跟着观点来写代码验证所提到的问题。</p>
<h2 id="不使用更新缓存而是删除缓存"><a href="#不使用更新缓存而是删除缓存" class="headerlink" title="不使用更新缓存而是删除缓存"></a>不使用更新缓存而是删除缓存</h2><p>「大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去查缓存，发现不存在后再读取数据库，写入缓存。」</p>
<p>《分布式之数据库和缓存双写一致性方案解析》孤独烟：</p>
<blockquote>
<p>「原因一：线程安全角度」</p>
<p>同时有请求A和请求B进行更新操作，那么会出现</p>
<p>（1）线程A更新了数据库</p>
<p>（2）线程B更新了数据库</p>
<p>（3）线程B更新了缓存</p>
<p>（4）线程A更新了缓存</p>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<p>「原因二：业务场景角度」</p>
<p>有如下两点：</p>
<p>（1）如果是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</p>
<p>（2）如果写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
</blockquote>
<p><strong>「其实如果业务非常简单，只是去数据库拿一个值，写入缓存，那么更新缓存也是可以的。但是，淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。」</strong></p>
<h2 id="先删除缓存，还是先操作数据库？"><a href="#先删除缓存，还是先操作数据库？" class="headerlink" title="先删除缓存，还是先操作数据库？"></a>先删除缓存，还是先操作数据库？</h2><p>「那么问题就来了，我们是先删除缓存，然后再更新数据库，还是先更新数据库，再删缓存呢？」</p>
<p>先来看看大佬们怎么说。</p>
<p>《【58沈剑架构系列】缓存架构设计细节二三事》58沈剑：</p>
<blockquote>
<p>对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：如果出现不一致，谁先做对业务的影响较小，就谁先执行。</p>
<p>假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。</p>
<p>假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。</p>
</blockquote>
<p>沈剑老师说的没有问题，不过「没完全考虑好并发请求时的数据脏读问题」，让我们再来看看孤独烟老师《分布式之数据库和缓存双写一致性方案解析》：</p>
<blockquote>
<p>「先删缓存，再更新数据库」</p>
<p>该方案会导致请求数据不一致</p>
<p>同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求B查询发现缓存不存在</p>
<p>（3）请求B去数据库查询得到旧值</p>
<p>（4）请求B将旧值写入缓存</p>
<p>（5）请求A将新值写入数据库</p>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
</blockquote>
<p>「所以先删缓存，再更新数据库并不是一劳永逸的解决方案，再看看先更新数据库，再删缓存」</p>
<blockquote>
<p>「先更新数据库，再删缓存」这种情况不存在并发问题么？</p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>
<p>（1）缓存刚好失效</p>
<p>（2）请求A查询数据库，得一个旧值</p>
<p>（3）请求B将新值写入数据库</p>
<p>（4）请求B删除缓存</p>
<p>（5）请求A将查到的旧值写入缓存</p>
<p>ok，如果发生上述情况，确实是会发生脏数据。</p>
<p>然而，发生这种情况的概率又有多少呢？</p>
<p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，「数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。」</p>
</blockquote>
<p>「先更新数据库，再删缓存」依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！</p>
<p>所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请「先更新数据库，再删缓存!」</p>
<h2 id="我一定要数据库和缓存数据一致怎么办"><a href="#我一定要数据库和缓存数据一致怎么办" class="headerlink" title="我一定要数据库和缓存数据一致怎么办"></a>我一定要数据库和缓存数据一致怎么办</h2><p>那么，如果我tm非要保证绝对一致性怎么办，先给出结论：</p>
<p>「没有办法做到绝对的一致性，这是由 CAP 理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于 CAP 中的 AP。」</p>
<p>所以，我们得委曲求全，可以去做到 BASE 理论中说的「最终一致性」。</p>
<blockquote>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</p>
<p>因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
</blockquote>
<p>大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库/先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。</p>
<h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p>问：先删除缓存，再更新数据库中避免脏数据？</p>
<p>答案：采用延时双删策略。</p>
<p>上文我们提到，在先删除缓存，再更新数据库的情况下，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p>「那么延时双删怎么解决这个问题呢？」</p>
<blockquote>
<p>（1）先淘汰缓存</p>
<p>（2）再写数据库（这两步和原来一样）</p>
<p>（3）休眠1秒，再次淘汰缓存</p>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p>
</blockquote>
<p>「那么，这个1秒怎么确定的，具体该休眠多久呢？」</p>
<blockquote>
<p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
</blockquote>
<p>「如果你用了 MySQL 的读写分离架构怎么办？」</p>
<blockquote>
<p>在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求A将数据写入数据库了</p>
<p>（3）请求B查询缓存发现，缓存没有值</p>
<p>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
<p>（5）请求B将旧值写入缓存</p>
<p>（6）数据库完成主从同步，从库变为新值</p>
<p>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
</blockquote>
<p>「采用这种同步淘汰策略，吞吐量降低怎么办？」</p>
<blockquote>
<p>那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
</blockquote>
<p>「所以在先删除缓存，再更新数据库的情况下」，可以使用延时双删的策略，来保证脏数据只会存活一段时间，就会被准确的数据覆盖。</p>
<p>「在先更新数据库，再删缓存的情况下」，缓存出现脏数据的情况虽然可能性极小，但也会出现。我们依然可以用延时双删策略，在请求A对缓存写入了脏的旧值之后，再次删除缓存。来保证去掉脏缓存。</p>
<h3 id="删缓存失败了怎么办：重试机制"><a href="#删缓存失败了怎么办：重试机制" class="headerlink" title="删缓存失败了怎么办：重试机制"></a>删缓存失败了怎么办：重试机制</h3><p>看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？</p>
<p>「解决方案就是再加上一个重试机制，保证删除缓存成功。」</p>
<p>参考孤独烟老师给的方案图：</p>
<p>「方案一：」</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E6%96%B9%E6%A1%88%E4%B8%80.png" alt="图片"></p>
<blockquote>
<p>流程如下所示</p>
<p>（1）更新数据库数据</p>
<p>（2）缓存因为种种问题删除失败</p>
<p>（3）将需要删除的key发送至消息队列</p>
<p>（4）自己消费消息，获得需要删除的key</p>
<p>（5）继续重试删除操作，直到成功</p>
<p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
</blockquote>
<p>方案二：</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E6%96%B9%E6%A1%88%E4%BA%8C.png" alt="图片"></p>
<blockquote>
<p>流程如下图所示：</p>
<p>（1）更新数据库数据</p>
<p>（2）数据库会将操作信息写入binlog日志当中</p>
<p>（3）订阅程序提取出所需要的数据以及key</p>
<p>（4）另起一段非业务代码，获得该信息</p>
<p>（5）尝试删除缓存操作，发现删除失败</p>
<p>（6）将这些信息发送至消息队列</p>
<p>（7）重新从消息队列中获得该数据，重试操作。</p>
</blockquote>
<p><strong>「而读取binlog的中间件，可以采用阿里开源的canal」</strong></p>
<p>好了，到这里我们已经把缓存双写一致性的思路彻底梳理了一遍，下面就是我对这几种思路徒手写的实战代码，方便有需要的朋友参考。</p>
<h2 id="实战：先删除缓存，再更新数据库"><a href="#实战：先删除缓存，再更新数据库" class="headerlink" title="实战：先删除缓存，再更新数据库"></a>实战：先删除缓存，再更新数据库</h2><p>终于到了实战，我们在秒杀项目的代码上增加接口：先删除缓存，再更新数据库</p>
<p>OrderController 中新增：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 下单接口：先删除缓存，再更新数据库</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createOrderWithCacheV1/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createOrderWithCacheV1</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 删除库存缓存</span></span><br><span class="line">        stockService.delStockCountCache(sid);</span><br><span class="line">        <span class="comment">// 完成扣库存下单事务</span></span><br><span class="line">        orderService.createPessimisticOrder(sid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;购买失败：[&#123;&#125;]&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;购买成功，剩余库存为: [&#123;&#125;]&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;购买成功，剩余库存为：%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>stockService中新增：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delStockCountCache</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    String hashKey = CacheKey.STOCK_COUNT.getKey() + <span class="string">&quot;_&quot;</span> + id;</span><br><span class="line">    stringRedisTemplate.delete(hashKey);</span><br><span class="line">    log.info(<span class="string">&quot;删除商品id：[&#123;&#125;] 缓存&quot;</span>, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其他涉及的代码都在之前三篇文章中有介绍，并且可以直接去Github拿到项目源码，就不在这里重复贴了。</p>
<h2 id="实战：先更新数据库，再删缓存"><a href="#实战：先更新数据库，再删缓存" class="headerlink" title="实战：先更新数据库，再删缓存"></a>实战：先更新数据库，再删缓存</h2><p>如果是先更新数据库，再删缓存，那么代码只是在业务顺序上颠倒了一下，这里就只贴OrderController中新增：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 下单接口：先更新数据库，再删缓存</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createOrderWithCacheV2/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createOrderWithCacheV2</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 完成扣库存下单事务</span></span><br><span class="line">        orderService.createPessimisticOrder(sid);</span><br><span class="line">        <span class="comment">// 删除库存缓存</span></span><br><span class="line">        stockService.delStockCountCache(sid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;购买失败：[&#123;&#125;]&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;购买成功，剩余库存为: [&#123;&#125;]&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;购买成功，剩余库存为：%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实战：缓存延时双删"><a href="#实战：缓存延时双删" class="headerlink" title="实战：缓存延时双删"></a>实战：缓存延时双删</h2><p>如何做延时双删呢，最好的方法是开设一个线程池，在线程中删除key，而不是使用Thread.sleep进行等待，这样会阻塞用户的请求。</p>
<p>更新前先删除缓存，然后更新数据，再延时删除缓存。</p>
<p>OrderController中新增接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延时时间：预估读数据库数据业务逻辑的耗时，用来做缓存再删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAY_MILLSECONDS = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 下单接口：先删除缓存，再更新数据库，缓存延时双删</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createOrderWithCacheV3/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createOrderWithCacheV3</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 删除库存缓存</span></span><br><span class="line">        stockService.delStockCountCache(sid);</span><br><span class="line">        <span class="comment">// 完成扣库存下单事务</span></span><br><span class="line">        count = orderService.createPessimisticOrder(sid);</span><br><span class="line">        <span class="comment">// 延时指定时间后再次删除缓存</span></span><br><span class="line">        cachedThreadPool.execute(<span class="keyword">new</span> delCacheByThread(sid));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;购买失败：[&#123;&#125;]&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;购买成功，剩余库存为: [&#123;&#125;]&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;购买成功，剩余库存为：%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OrderController中新增线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延时双删线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService cachedThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 缓存再删除线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">delCacheByThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sid;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">delCacheByThread</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sid = sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;异步执行缓存再删除，商品id：[&#123;&#125;]， 首先休眠：[&#123;&#125;] 毫秒&quot;</span>, sid, DELAY_MILLSECONDS);</span><br><span class="line">            Thread.sleep(DELAY_MILLSECONDS);</span><br><span class="line">            stockService.delStockCountCache(sid);</span><br><span class="line">            log.info(<span class="string">&quot;再次删除商品id：[&#123;&#125;] 缓存&quot;</span>, sid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;delCacheByThread执行出错&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>来试验一下，请求接口 createOrderWithCacheV3：</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E8%AF%95%E9%AA%8C%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98.png" alt="图片"></p>
<p>日志中，做到了两次删除：</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E8%AF%95%E9%AA%8C%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E6%97%A5%E5%BF%97.png" alt="图片"></p>
<h2 id="实战：删除缓存重试机制"><a href="#实战：删除缓存重试机制" class="headerlink" title="实战：删除缓存重试机制"></a>实战：删除缓存重试机制</h2><p>上文提到了，要解决删除失败的问题，需要用到消息队列，进行删除操作的重试。这里我们为了达到效果，接入了 RabbitMq，并且需要在接口中写发送消息，并且需要消费者常驻来消费消息。Spring 整合 RabbitMq 还是比较简单的，我把简单的整合代码也贴出来。</p>
<p>pom.xml 新增 RabbitMq 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>写一个RabbitMqConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delCacheQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;delCache&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加一个消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;delCache&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelCacheReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;DelCacheReceiver收到消息: &quot;</span> + message);</span><br><span class="line">        log.info(<span class="string">&quot;DelCacheReceiver开始删除缓存: &quot;</span> + message);</span><br><span class="line">        stockService.delStockCountCache(Integer.parseInt(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OrderController中新增接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 下单接口：先更新数据库，再删缓存，删除缓存重试机制</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createOrderWithCacheV4/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createOrderWithCacheV4</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 完成扣库存下单事务</span></span><br><span class="line">        count = orderService.createPessimisticOrder(sid);</span><br><span class="line">        <span class="comment">// 删除库存缓存</span></span><br><span class="line">        stockService.delStockCountCache(sid);</span><br><span class="line">        <span class="comment">// 延时指定时间后再次删除缓存</span></span><br><span class="line">        <span class="comment">// cachedThreadPool.execute(new delCacheByThread(sid));</span></span><br><span class="line">        <span class="comment">// 假设上述再次删除缓存没成功，通知消息队列进行删除缓存</span></span><br><span class="line">        sendDelCache(String.valueOf(sid));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;购买失败：[&#123;&#125;]&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;购买成功，剩余库存为: [&#123;&#125;]&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;购买成功，剩余库存为：%d&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>访问createOrderWithCacheV4：</p>
<p><img src="Java-SecKill-DB-Cache-Inconsistent/%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E5%AE%9E%E6%88%98.png" alt="图片"></p>
<p>可以看到，我们先完成了下单，然后删除了缓存，并且假设延迟删除缓存失败了，发送给消息队列重试的消息，消息队列收到消息后再去删除缓存。</p>
<h2 id="实战：读取binlog异步删除缓存"><a href="#实战：读取binlog异步删除缓存" class="headerlink" title="实战：读取binlog异步删除缓存"></a>实战：读取binlog异步删除缓存</h2><p>我们需要用到阿里开源的canal来读取binlog进行缓存的异步删除。</p>
<p>不过很蛋疼的是，这次文章的工作量实在有点太大了，连续写代码和整理文字身体有点吃不消了，不知道你们有没有学累。我准备把canal之后单开一个文章写，可能就是第五篇，也可能是单开一个canal的文章。我得先休息会，这里就留一个坑把。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>更新缓存的的Design Pattern有四种：Cache aside，Read through，Write through，Write behind caching，这里有陈皓的总结文章可以进行学习。</p>
<p><a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>引用陈浩《缓存更新的套路》最后的总结语作为小结：</p>
<blockquote>
<p>分布式系统里要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率</p>
<p>缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP，BASE理论。</p>
<p>异构数据库本来就没办法强一致，「只是尽可能减少时间窗口，达到最终一致性」。</p>
<p>还有别忘了设置过期时间，这是个兜底方案</p>
</blockquote>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文总结了秒杀系统中关于缓存数据的思考和实现，并探讨了缓存数据库双写一致性问题。</p>
<p>「可以总结为如下几点：」</p>
<ul>
<li>对于读多写少的数据，请使用缓存。</li>
<li>为了保持一致性，会导致系统吞吐量的下降。</li>
<li>为了保持一致性，会导致业务代码逻辑复杂。</li>
<li>缓存做不到绝对一致性，但可以做到最终一致性。</li>
<li>对于需要保证缓存数据库数据一致的情况，请尽量考虑对一致性到底有多高要求，选定合适的方案，避免过度设计。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>秒杀系列（零）高并发设计</title>
    <url>/articles/Java-SecKill-Distributed-Design.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>秒杀系列开篇文章，整理分布式微服务设计中，面对高并发场景的一系列潜在问题和处理思路。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不论是日常工作还是大场面试中，分布式问题应该是每个程序猿要刻在基因里的意识。</p>
<p>在通过相关技术的学习和日常工作中的梳理之后，笔者希望以成体系的方式，把分布式微服务架构在面对高并发等场景下的各类问题和相关的处理思路，模拟并展现出来。希望能带给小伙伴们思考。</p>
<p>为了做这系列梳理，笔者采取了大家都熟悉的高并发场景：<strong>秒杀 + 积分</strong>，以此降低大家对于业务的理解门槛，更加专注于技术和问题本身的思考。</p>
<h1 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a>业务场景描述</h1><p>万级用户参加一个商品秒杀活动，简化问题为：几件商品，库存 100 - 1000 不定，用户在几秒内参与抢购，不可超卖，但允许一定程度上卖不完。</p>
<p>成功秒杀下订单的用户，还可获取相应积分，1 元 = 1 积分。</p>
<h2 id="需求拆解"><a href="#需求拆解" class="headerlink" title="需求拆解"></a>需求拆解</h2><ol>
<li>数据库设计</li>
<li>系统设计</li>
<li>接口设计</li>
<li>压力测试</li>
</ol>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>库存系统、订单系统、积分系统</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>查询、下订单、扣积分</p>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>JMeter</p>
<h1 id="业务场景技术分析"><a href="#业务场景技术分析" class="headerlink" title="业务场景技术分析"></a>业务场景技术分析</h1><ul>
<li><p>QPS 较高，涉及<strong>高并发</strong>场景</p>
</li>
<li><p>分布式请求，涉及<strong>分布式锁</strong>的应用</p>
</li>
<li><p>多系统交互，涉及<strong>分布式数据一致性</strong>问题</p>
</li>
<li><p>数据库 <strong>MySQL</strong></p>
</li>
<li><p>缓存中间件 <strong>Redis</strong></p>
</li>
<li><p>消息中间件 <strong>RabbitMQ</strong></p>
</li>
</ul>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>本项目已在 <a href="https://github.com/MrShadowalker/secKill">Github</a> 上开源，项目中已有足够的注释和相关文档，欢迎 Star、Fork、Follow，为本项目做出贡献者，我会请您喝咖啡呀~~</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>高并发</tag>
        <tag>分布式</tag>
        <tag>数据一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系列（一）防止超卖</title>
    <url>/articles/Java-SecKill-Prevent-Oversold.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h1><p>秒杀系统相信网上已经介绍了很多了，我也不想粘贴很多定义过来了。</p>
<p>废话少说，秒杀系统主要应用在商品抢购的场景，比如：</p>
<ul>
<li>电商抢购限量商品</li>
<li>卖周董演唱会的门票</li>
<li>火车票抢座</li>
<li>……</li>
</ul>
<p>秒杀系统抽象来说就是以下几个步骤：</p>
<ul>
<li>用户选定商品下单</li>
<li>校验库存</li>
<li>扣库存</li>
<li>创建用户订单</li>
<li>用户支付等后续步骤</li>
</ul>
<p>听起来就是个用户买商品的流程而已嘛！确实，所以我们为啥要说它是个专门的系统呢？</p>
<span id="more"></span>

<h2 id="为什么要做所谓的“系统”"><a href="#为什么要做所谓的“系统”" class="headerlink" title="为什么要做所谓的“系统”"></a>为什么要做所谓的“系统”</h2><p>如果你的项目流量非常小，完全不用担心有并发的购买请求，那么做这样一个系统意义不大。</p>
<p>但如果你的系统要像 12306 那样，接受高并发访问和下单的考验，那么你就需要一套完整的流程保护措施，来保证你系统在用户流量高峰期不会被搞挂了。（就像 12306 刚开始网络售票那几年一样）</p>
<p>这些措施有什么呢：</p>
<ul>
<li><p>严格防止超卖：库存 100 件你卖了 120 件，等着辞职吧。</p>
</li>
<li><p>防止黑产：防止不怀好意的人群通过各种技术手段把你本该下发给群众的利益全收入了囊中。</p>
</li>
<li><p>保证用户体验：高并发下，别网页打不开了，支付不成功了，购物车进不去了，地址改不了了。</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>这些问题非常之大，涉及到各种技术，也不是一下子就能讲完的，甚至根本就没法讲完。</p>
<p>之前列举的措施中，如果防止黑产和网页卡顿等现象出现，其实用户也能一定程度上理解，毕竟秒杀都很可能会卡顿和抢不到，最多大家没参与到活动，口吐芬芳一波。</p>
<p>但是，如果要是超卖了，本该拿到商品的用户可就不乐意了，轻则亏本发货，重则起诉赔偿，哪一样都吃不了兜着走。</p>
<p>以下开始从零开始搭建秒杀系统 demo。</p>
<h1 id="数据库建表（简版）"><a href="#数据库建表（简版）" class="headerlink" title="数据库建表（简版）"></a>数据库建表（简版）</h1><h2 id="库存表-stock"><a href="#库存表-stock" class="headerlink" title="库存表 stock"></a>库存表 stock</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `stock`;</span><br><span class="line">CREATE TABLE `stock` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;,</span><br><span class="line">  `count` int(11) NOT NULL COMMENT &#x27;库存&#x27;,</span><br><span class="line">  `sale` int(11) NOT NULL COMMENT &#x27;已售&#x27;,</span><br><span class="line">  `version` int(11) NOT NULL COMMENT &#x27;乐观锁，版本号&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="订单表-stock-order"><a href="#订单表-stock-order" class="headerlink" title="订单表 stock_order"></a>订单表 stock_order</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `stock_order`;</span><br><span class="line">CREATE TABLE `stock_order`</span><br><span class="line">(</span><br><span class="line">    `id`          int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `sid`         int(11)          NOT NULL COMMENT &#x27;库存ID&#x27;,</span><br><span class="line">    `name`        varchar(30)      NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;商品名称&#x27;,</span><br><span class="line">    `create_time` timestamp        NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE = InnoDB</span><br><span class="line">  DEFAULT CHARSET = utf8;</span><br></pre></td></tr></table></figure>



<h1 id="防止超卖"><a href="#防止超卖" class="headerlink" title="防止超卖"></a>防止超卖</h1><h2 id="通过-HTTP-接口发起购买请求"><a href="#通过-HTTP-接口发起购买请求" class="headerlink" title="通过 HTTP 接口发起购买请求"></a>通过 HTTP 接口发起购买请求</h2><p>只是个 demo，所以采用 Spring MVC + MyBatis 结构。</p>
<h3 id="先用常规方案做一个购买请求接口"><a href="#先用常规方案做一个购买请求接口" class="headerlink" title="先用常规方案做一个购买请求接口"></a>先用常规方案做一个购买请求接口</h3><h4 id="Controller-层-V0"><a href="#Controller-层-V0" class="headerlink" title="Controller 层 V0"></a>Controller 层 V0</h4><p>提供一个接口，入参为商品 ID</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/createWrongOrder/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createWrongOrder</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;购买物品编号sid =【&#123;&#125;】&quot;</span>,sid);</span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        id = orderService.createWrongOrder(sid);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单id:【&#123;&#125;】&quot;</span>,id);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Exception&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Service-层-V0"><a href="#Service-层-V0" class="headerlink" title="Service 层 V0"></a>Service 层 V0</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createWrongOrder</span><span class="params">(<span class="keyword">int</span> sid)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 校验库存</span></span><br><span class="line">    Stock stock = checkStock(sid);</span><br><span class="line">    <span class="comment">// 扣库存</span></span><br><span class="line">    saleStock(stock);</span><br><span class="line">    <span class="comment">// 创建订单</span></span><br><span class="line">    <span class="keyword">int</span> id = createWrongOrder(stock);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stock <span class="title">checkStock</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    Stock stock = stockService.getStockById(sid);</span><br><span class="line">    <span class="keyword">if</span>(stock.getSale().equals(stock.getCount())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">saleStock</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">    stock.setSale(stock.getSale() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> stockService.updateStockById(stock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createWrongOrder</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">    StockOrder order = <span class="keyword">new</span> StockOrder();</span><br><span class="line">    order.setSid(stock.getId());</span><br><span class="line">    order.setName(stock.getName());</span><br><span class="line">    <span class="keyword">int</span> id = orderMapper.insertSelective(order);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试：发起并发购买请求，复现超卖问题"><a href="#测试：发起并发购买请求，复现超卖问题" class="headerlink" title="测试：发起并发购买请求，复现超卖问题"></a>测试：发起并发购买请求，复现超卖问题</h3><p>推荐使用【 <a href="https://jmeter.apache.org/">JMeter</a> 】来模拟大量用户同时请求购买接口的场景。</p>
<p>为啥不使用 Postman？因为暂时不支持并发请求，只能顺序请求。</p>
<p>如何通过 JMeter 进行压测，可参考这篇 【 <a href="https://www.cnblogs.com/stulzq/p/8971531.html">JMeter 压测教程</a> 】。</p>
<p>同时开启 1000 线程，抢数据库插入的 <strong>100 台</strong> iPhone，结果卖了 <strong>16 台</strong>，但是创建了 <strong>1000 个</strong>订单。</p>
<p>哭唧唧……是该表扬 Spring 强大的并发处理能力，还是该口吐芬芳 MySQL 这么成熟的数据库却不会给自己锁库存……</p>
<h3 id="避免超卖问题：更新商品库存的版本号"><a href="#避免超卖问题：更新商品库存的版本号" class="headerlink" title="避免超卖问题：更新商品库存的版本号"></a>避免超卖问题：更新商品库存的版本号</h3><p>为解决上述超卖问题，有几种方案：</p>
<ul>
<li>悲观锁：在 Service 层给表更新添加事务，这样每个线程更新请求的时候先锁表的这一行，更新完库存之后释放锁。</li>
</ul>
<p>缺点：性能问题，1000 个线程存在阻塞。需要乐观锁。</p>
<ul>
<li>乐观锁：一般有两种方案，CAS 和 version。最简单的办法就是，给每个商品库存一个版本号 version 字段。</li>
</ul>
<p>修改之前的代码，createWrongOrder 修改为新的悲观锁/乐观锁方案 ~</p>
<h3 id="悲观锁和乐观锁两种方案的分析与比较"><a href="#悲观锁和乐观锁两种方案的分析与比较" class="headerlink" title="悲观锁和乐观锁两种方案的分析与比较"></a>悲观锁和乐观锁两种方案的分析与比较</h3><blockquote>
<ul>
<li><p>悲观锁（Pessimistic Lock），顾名思义就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在操作之前先上锁。</p>
</li>
<li><p>乐观锁（Optimistic Lock），顾名思义就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。</p>
</li>
</ul>
</blockquote>
<p><strong>两种锁各有优缺点，不能单纯定义哪个好于哪个，需要结合实际业务场景做选择。</strong></p>
<ul>
<li>乐观锁比较适合数据修改比较少，读取比较频繁的场景，即使出现了少量的冲突，也省去了大量锁开销，能提高系统吞吐量。</li>
<li>但是如果经常发生冲突（写数据比较多的情况下），上层应用不断 retry，这样反而降低了性能，对于这种情况，悲观锁可能更合适。</li>
</ul>
<h4 id="悲观锁方案"><a href="#悲观锁方案" class="headerlink" title="悲观锁方案"></a>悲观锁方案</h4><h5 id="Controller-层-V1"><a href="#Controller-层-V1" class="headerlink" title="Controller 层 V1"></a>Controller 层 V1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务for update更新库存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createPessimisticOrder/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createPessimisticOrder</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        id = orderService.createPessimisticOrder(sid);</span><br><span class="line">        log.info(<span class="string">&quot;购买成功，剩余库存为:【&#123;&#125;】&quot;</span>,id);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;购买失败:【&#123;&#125;】&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;购买失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;购买成功，剩余库存为：%d&quot;</span>,id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Service-层-V1"><a href="#Service-层-V1" class="headerlink" title="Service 层 V1"></a>Service 层 V1</h5><p>Service 中，给卖商品流程加上事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createPessimisticOrder</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验库存(悲观锁for update)</span></span><br><span class="line">    Stock stock = checkStockForUpdate(sid);</span><br><span class="line">    <span class="comment">// 更新库存</span></span><br><span class="line">    saleStock(stock);</span><br><span class="line">    <span class="comment">// 创建订单</span></span><br><span class="line">    <span class="keyword">int</span> id = createOrder(stock);</span><br><span class="line">    <span class="keyword">return</span> stock.getCount() - (stock.getSale());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查库存 ForUpdate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stock <span class="title">checkStockForUpdate</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    Stock stock = stockService.getStockByIdForUpdate(sid);</span><br><span class="line">    <span class="keyword">if</span>(stock.getSale().equals(stock.getCount())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新库存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saleStock</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">    stock.setSale(stock.getSale() + <span class="number">1</span>);</span><br><span class="line">    stockService.updateStockById(stock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stock</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">    StockOrder order = <span class="keyword">new</span> StockOrder();</span><br><span class="line">    order.setSid(stock.getId());</span><br><span class="line">    order.setName(stock.getName());</span><br><span class="line">    <span class="keyword">int</span> id = orderMapper.insertSelective(order);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用 Spring 的事务，<code>@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED)</code><br>，如果遇到回滚，则返回Exception，并且事务传播使用 <code>PROPAGATION_REQUIRED —— 支持当前事务，如果当前没有事务，就新建一个事务</code>，关于 Spring 事务传播机制可以自行查阅资料。</p>
<h5 id="悲观锁方案测试"><a href="#悲观锁方案测试" class="headerlink" title="悲观锁方案测试"></a>悲观锁方案测试</h5><p>设置 100 个商品，清空订单表，使用 JMeter 更改请求接口为悲观锁接口，发起 200 个请求。</p>
<p>结果：200 个请求，100 个返回抢购成功，100 个返回抢购失败，并且商品卖给了前 100 个进来的请求，十分有序。</p>
<p>所以，悲观锁在大量请求的请求下，有着更好的卖出成功率。</p>
<p>但是需要注意的是，如果请求量巨大，悲观锁会导致后面的请求进行了长时间的阻塞等待，用户就必须在页面等待，很像是”假死”，可以通过配合令牌桶限流，或者是给用户显著的等待提示来优化。</p>
<h4 id="乐观锁版本号方案"><a href="#乐观锁版本号方案" class="headerlink" title="乐观锁版本号方案"></a>乐观锁版本号方案</h4><h5 id="Controller-层-V2"><a href="#Controller-层-V2" class="headerlink" title="Controller 层 V2"></a>Controller 层 V2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁更新库存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/createOptimisticOrder/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createOptimisticOrder</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        id = orderService.createOptimisticOrder(sid);</span><br><span class="line">        log.info(<span class="string">&quot;购买成功，剩余库存为:【&#123;&#125;】&quot;</span>, id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;购买失败:【&#123;&#125;】&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;购买成功，剩余库存为：%d&quot;</span>, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Service-层-V2"><a href="#Service-层-V2" class="headerlink" title="Service 层 V2"></a>Service 层 V2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createOptimisticOrder</span><span class="params">(<span class="keyword">int</span> sid)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 校验库存</span></span><br><span class="line">    Stock stock = checkStock(sid);</span><br><span class="line">    <span class="comment">// 乐观锁更新库存</span></span><br><span class="line">    saleStockOptimistic(stock);</span><br><span class="line">    <span class="comment">// 创建订单</span></span><br><span class="line">    <span class="keyword">int</span> id = createOrder(stock);</span><br><span class="line">    <span class="keyword">return</span> stock.getCount() - (stock.getSale() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saleStockOptimistic</span><span class="params">(Stock stock)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;查询数据库，尝试更新库存&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> count = stockService.updateStockByOptimistic(stock);</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;并发更新库存失败，version不匹配&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByOptimistic&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.shadowalker.seckilldao.dao.Stock&quot;</span>&gt;</span></span><br><span class="line">    UPDATE stock</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        sale = sale + 1,</span><br><span class="line">        version = version + 1,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;id, jdbcType=INTEGER&#125;</span><br><span class="line">    AND version = #&#123;version, jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在实际减库存的 SQL 操作中，首先判断 version 是否是我们查询库存时候的 version，如果是，扣减库存，秒杀成功；如果 version 变了，则不更新数据库，秒杀失败。</p>
<h5 id="乐观锁不需要版本号字段方案-Mapper"><a href="#乐观锁不需要版本号字段方案-Mapper" class="headerlink" title="乐观锁不需要版本号字段方案 Mapper"></a>乐观锁不需要版本号字段方案 Mapper</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateByOptimistic&quot; parameterType=&quot;org.shadowalker.seckilldao.dao.Stock&quot;&gt;</span><br><span class="line">UPDATE stock</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      sale = sale + 1,</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    WHERE id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">    AND sale = #&#123;sale,jdbcType=INTEGER&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<h5 id="乐观锁版本号方案测试：重新发起并发购买请求，验证正确秒杀"><a href="#乐观锁版本号方案测试：重新发起并发购买请求，验证正确秒杀" class="headerlink" title="乐观锁版本号方案测试：重新发起并发购买请求，验证正确秒杀"></a>乐观锁版本号方案测试：重新发起并发购买请求，验证正确秒杀</h5><p>库存恢复 <strong>100 台</strong>，清空订单表，通过 JMeter 重新发起 <strong>1000次</strong>并发请求。</p>
<p>结果：卖出去 <strong>39 台</strong>，库存 version 更新为 39，创建了 <strong>39 个订单</strong>。没有超卖。</p>
<p>说明：由于并发访问的原因，很多线程更新库存失败了，所以在这种设计下，1000 人同时发起购买，只有 39 个人能买到。</p>
<p>其实这完全 OK，一方面用户其实无感知，另一方面还减少了秒杀造成的低收益甚至是亏本（本身秒杀就是为了提升人气和引流的），最关键的是，防止了超卖。</p>
<p>当然，如果用户更多的话，最终大概率是可以全部卖完的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>高并发</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 jar、war、ear 包的作用与区别</title>
    <url>/articles/Java-jar-war-ear.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">jar</th>
<th align="center">war</th>
<th align="center">ear</th>
</tr>
</thead>
<tbody><tr>
<td align="center">英文</td>
<td align="center">Java Archive file</td>
<td align="center">Web Archive file</td>
<td align="center">Enterprise Archive file</td>
</tr>
<tr>
<td align="center">包含内容</td>
<td align="center">class、properties文件，是文件封装的最小单元；包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等</td>
<td align="center">Servlet、JSP页面、JSP标记库、jar库文件、Html/XML文档和其他公用资源文件，如图片、音频文件等</td>
<td align="center">除了包含jar、war以外，还包括EJB组件</td>
</tr>
<tr>
<td align="center">部署文件</td>
<td align="center">application-client.xml</td>
<td align="center">web.xml</td>
<td align="center">application.xml</td>
</tr>
<tr>
<td align="center">容器</td>
<td align="center">应用服务器（application servers）</td>
<td align="center">小型服务程序容器（servlet containers）</td>
<td align="center">EJB容器（EJB containers）</td>
</tr>
<tr>
<td align="center">级别</td>
<td align="center">小</td>
<td align="center">中</td>
<td align="center">大</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="war-文件的使用"><a href="#war-文件的使用" class="headerlink" title="war 文件的使用"></a>war 文件的使用</h2><ul>
<li>生成 war 包文件命令</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">jar -cvf web.war 被打包文件</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 war 包内容命令</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">jar -tf web.war</span><br></pre></td></tr></table></figure>

<ul>
<li>解压 war 包文件命令</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">jar -xf web.war　　</span><br></pre></td></tr></table></figure>

<p>也可使用 winrar 软件选择 zip 压缩方式，并将压缩文件后缀名改为 war 即可压缩生成 war 文件。</p>
<p>同样使用 winrar 软件可以打开 war 文件，或者解压 war 文件。</p>
<p>使用 jar 命令与 winrar 软件的区别在于前者在压缩文件的同时会生成 META-INF 文件夹，内包含 MANIFEST.MF 文件。</p>
<h2 id="ear-文件的打包"><a href="#ear-文件的打包" class="headerlink" title="ear 文件的打包"></a>ear 文件的打包</h2><p>ear 文件包括整个 JSP 项目，内含多个 EJB Module（jar文件）和 Web Module（WAR文件）。</p>
<p>ear 文件的生成可以使用 winrar（windows平台上的软件）以 zip 压缩方式或者从命令行以 jar 命令来生成。</p>
<p>操作步骤：</p>
<ul>
<li><p>先打包成 war 和 jar，并写好 application.xml，放到 META-INF 目录下。</p>
</li>
<li><p>打包命令：（进入文件所在目录）</p>
</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">jar cf application.ear application.war application.jar META-INF\application.xml</span><br></pre></td></tr></table></figure>

<p>application.xml 是用来描述 ear 中包括的 war 和 jar 等包文件。</p>
<ul>
<li>解包命令</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">jar xf application.ear -C 目标路径</span><br></pre></td></tr></table></figure>

<p>以下附上 Weblogic 自带的 petstore 的 application.xml 代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">application</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&#x27;-//Sun Microsystems, Inc.//DTD J2EE Application 1.2//EN&#x27;</span> <span class="meta-string">&#x27;http://java.sun.com/j2ee/dtds/application_1_2.dtd&#x27;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">application</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>estore<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Application description<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">ejb</span>&gt;</span>customerEjb.jar<span class="tag">&lt;/<span class="name">ejb</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">ejb</span>&gt;</span>mailerEjb.jar<span class="tag">&lt;/<span class="name">ejb</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">web</span>&gt;</span> </span><br><span class="line">             <span class="tag">&lt;<span class="name">web-uri</span>&gt;</span>petstore.war<span class="tag">&lt;/<span class="name">web-uri</span>&gt;</span> </span><br><span class="line">             <span class="tag">&lt;<span class="name">context-root</span>&gt;</span>estore<span class="tag">&lt;/<span class="name">context-root</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;/<span class="name">web</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">ejb</span>&gt;</span>petstoreEjb.jar<span class="tag">&lt;/<span class="name">ejb</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">ejb</span>&gt;</span>signonEjb.jar<span class="tag">&lt;/<span class="name">ejb</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">ejb</span>&gt;</span>personalizationEjb.jar<span class="tag">&lt;/<span class="name">ejb</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">ejb</span>&gt;</span>inventoryEjb.jar<span class="tag">&lt;/<span class="name">ejb</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">ejb</span>&gt;</span>shoppingcartEjb.jar<span class="tag">&lt;/<span class="name">ejb</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">security-role</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>the gold customer role<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">role-name</span>&gt;</span>gold_customer<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">security-role</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">security-role</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>the customer role<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">role-name</span>&gt;</span>customer<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">security-role</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">security-role</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">role-name</span>&gt;</span>administrator<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">security-role</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h1><h2 id="jar、war、ear-作用与区别"><a href="#jar、war、ear-作用与区别" class="headerlink" title="jar、war、ear 作用与区别"></a>jar、war、ear 作用与区别</h2><h3 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h3><p>把开发时要引用通用 Java 类及资源做封装，打成包后便于存放管理；</p>
<h3 id="war"><a href="#war" class="headerlink" title="war"></a>war</h3><p>一个(web)完整的应用，通常是网站或 WEB 平台，打成包部署到容器中；</p>
<h3 id="ear"><a href="#ear" class="headerlink" title="ear"></a>ear</h3><p>企业级应用，实际上 EAR 包中包含 WAR 包和几个企业级项目的配置文件而已，服务器中间件通常选择 WebSphere 等都会使用 EAR 包。</p>
<p>通常是 EJB 打成 ear 包。</p>
<h2 id="打包方式"><a href="#打包方式" class="headerlink" title="打包方式"></a>打包方式</h2><ul>
<li><p>所有的包都是用 jar 命令制作，只不过目标文件的扩展名不一样。</p>
</li>
<li><p>也可以用 Ant 来构建。</p>
</li>
<li><p>Windows 平台 winrar 命令。</p>
</li>
</ul>
<h2 id="何时使用-war-包"><a href="#何时使用-war-包" class="headerlink" title="何时使用 war 包"></a>何时使用 war 包</h2><p>在项目在没有完全开发完成时，不适合使用 war 文件，因为你的类会由于调试之类的经常被修改，来回创建 war 包很麻烦。</p>
<p>当项目完全开发完成后续无需修改时，可以创建 war 包。</p>
<p>这个时候 war 包文件就相当于一个 web 应用程序；而 jar 文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。</p>
]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 优化</title>
    <url>/articles/Java-optimization.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="代码优化的目标"><a href="#代码优化的目标" class="headerlink" title="代码优化的目标"></a>代码优化的目标</h1><ul>
<li>减小代码体积</li>
<li>提高代码运行效率</li>
</ul>
<span id="more"></span>

<h1 id="代码优化细节"><a href="#代码优化细节" class="headerlink" title="代码优化细节"></a>代码优化细节</h1><h2 id="尽量指定类、方法的final修饰符"><a href="#尽量指定类、方法的final修饰符" class="headerlink" title="尽量指定类、方法的final修饰符"></a>尽量指定类、方法的final修饰符</h2><p>带有 final 修饰符的类是不可派生的。在 Java 核心 API 中，有许多应用 final 的例子，如 java.lang.String ，整个类都是 final 的。为类指定 final 修饰符可以让类不可以被继承，为方法指定 final 修饰符可以让方法不可以被重写。如果指定了一个类为 final ，则该类所有的方法都是 final 的。Java 编译器会寻找机会内联所有的 final 方法，内联对于提升 Java 运行效率作用重大，具体参见 Java 运行期优化。此举能够使性能平均提升50%。</p>
<h2 id="尽量重用对象"><a href="#尽量重用对象" class="headerlink" title="尽量重用对象"></a>尽量重用对象</h2><p>特别是 String 对象的使用，出现字符串连接时应该使用 StringBuilder、StringBuffer 代替。由于 Java 虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p>
<h2 id="尽可能使用局部变量"><a href="#尽可能使用局部变量" class="headerlink" title="尽可能使用局部变量"></a>尽可能使用局部变量</h2><p>调用方法时传递的参数以及在调用中差UN关键的临时变量都保存在占中，速度较快；其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<h2 id="及时关闭流"><a href="#及时关闭流" class="headerlink" title="及时关闭流"></a>及时关闭流</h2><p>Java 编程过程中，进行数据库连接、I/O 流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统很大的开销，稍有不慎，将会导致严重后果。</p>
<h2 id="进来能够减少对变量的重复计算"><a href="#进来能够减少对变量的重复计算" class="headerlink" title="进来能够减少对变量的重复计算"></a>进来能够减少对变量的重复计算</h2><p>明确一个概念，对方法的调用，即使方法中只有一个语句，也是有消耗的，包括创建栈帧、调用方法是保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>建议替换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> length = list.size(); i &lt; length; i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在list.size()很大的时候，就减少了许多消耗。</p>
<h2 id="尽量采用懒加载的策略，即在需要时才创建"><a href="#尽量采用懒加载的策略，即在需要时才创建" class="headerlink" title="尽量采用懒加载的策略，即在需要时才创建"></a>尽量采用懒加载的策略，即在需要时才创建</h2><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可替换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">    String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="慎用异常"><a href="#慎用异常" class="headerlink" title="慎用异常"></a>慎用异常</h2><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable 接口的构造函数调用名为 fillInStackTrace() 的本地同步方法， fillInStackTrace() 方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java 虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p>
<p>不要在循环中使用 try-catch，应该将其放在最外层，除非不得已。</p>
<h2 id="关于内容长度"><a href="#关于内容长度" class="headerlink" title="关于内容长度"></a>关于内容长度</h2><p>如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度，比如：ArrayList、StringBuilder、StringBuffer、HashMap、HashSet等。</p>
<p>以StringBuilder为例：</p>
<ul>
<li>StringBuilder()    // 默认分配 16 个字符的空间</li>
<li>StringBuilder(int size)    // 默认分配 size 个字符的空间</li>
<li>StringBuilder(String str)    // 默认分配 16+str.length() 个字符的空间</li>
</ul>
<p>可以通过类（这里指的不仅仅是上面的 StringBuilder）来设定他的初始化变容量，这样可以明显地提升性能。以 StringBuilder 为例，length 表示当前的 StringBuilder 能保持的字符数量。因为当 StringBuilder 达到最大容量时，会将自身容量增加到当前的 2 倍再加 2，无论何时只要 StringBuilder 达到他的最大容量，就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中——然鹅这是十分耗费性能的操作。那么，如果能预估到字符数组中要存放 5000 个字符而不指定长度，最接近 5000 的 2 次幂是 4096，忽略每次扩容加的 2，那么：</p>
<ul>
<li>在 4096 基础上，在申请 8194 个大小的字符数组，加起来相当于一次申请了 12290 个大小的字符数组，如果一开始就能指定 5000 个大小的字符数组，就能节省一倍以上的空间。</li>
<li>把原来的 4096 个字符拷贝到新的字符数组中去，又浪费了性能。</li>
</ul>
<p>会发现，如果不指定字符长度，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是代码优化很重要的一部分。但是注意像 HashMap 这种是以数组+链表实现的集合，别把初始大小和估计的大小设置的一样，因为一个 table 上只连接一个对象的可能性几乎为 0。初始大小建议设置为 2 的 N 次幂，如果能估计到有 2000 个元素，设置成 new HashMap(128)、new HashMap(256) 都是可以的。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>复制大量数据时，使用 System.arraycopy() 命令。</p>
<h2 id="乘法和除法使用移位操作"><a href="#乘法和除法使用移位操作" class="headerlink" title="乘法和除法使用移位操作"></a>乘法和除法使用移位操作</h2><p>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) &#123;</span><br><span class="line">    a = val * <span class="number">8</span>;</span><br><span class="line">    b = val / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用移位操作可以极大地提升性能，因为在计算机底层，对位的操作是最方便、最快的。因此修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val +=<span class="number">5</span>) &#123;</span><br><span class="line">    a = val &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    b = val &gt;&gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移位操作虽然快，但是可能会使得代码不好理解，因此如果使用最好加上相应的注释。</p>
<h2 id="循环内不要不断创建对象引用"><a href="#循环内不要不断创建对象引用" class="headerlink" title="循环内不要不断创建对象引用"></a>循环内不要不断创建对象引用</h2><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法会导致内存中有 count 个 Object 对象引用存在，count 很大的话，就消耗内存了，建议修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，内存中只有一个 Object 对象引用，每次 new Object() 的时候，Object 对象引用指向不同的 Object 而已，但内存中只有一个，这样就大大节省内存空间了。</p>
<h2 id="关于-array-和-ArrayList"><a href="#关于-array-和-ArrayList" class="headerlink" title="关于 array 和 ArrayList"></a>关于 array 和 ArrayList</h2><p>基于效率和类型检查的考虑，应尽可能使用 array，无法确定数组大小时才使用 ArrayList。</p>
<h2 id="集合类型选择"><a href="#集合类型选择" class="headerlink" title="集合类型选择"></a>集合类型选择</h2><p>尽量使用 HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用 Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销。</p>
<h2 id="不要将数组声明为-public，static，final"><a href="#不要将数组声明为-public，static，final" class="headerlink" title="不要将数组声明为 public，static，final"></a>不要将数组声明为 public，static，final</h2><p>因为毫无意义。这样只是定义了引用为 static、final，数组的内容还是可以随意改变的，将数组声明为 public 更是一个安全漏洞，这意味着这个数组可以被外部类所改变。</p>
<h2 id="进来那个在合适的场合使用单例"><a href="#进来那个在合适的场合使用单例" class="headerlink" title="进来那个在合适的场合使用单例"></a>进来那个在合适的场合使用单例</h2><p>使用单例可以减轻加载的负担、缩短加载时间、提高加载效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>
<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问。</li>
<li>控制实例的产生，以达到节约资源的目的。</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</li>
</ul>
<h2 id="尽量避免随意使用静态变量"><a href="#尽量避免随意使用静态变量" class="headerlink" title="尽量避免随意使用静态变量"></a>尽量避免随意使用静态变量</h2><p>当某个对象被定义为 static 的变量所引用，那么 gc 通常是不会回收这个对象所占有的堆内存的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时静态变量 B 的生命周期与 A 类相同，如果 A 类不被卸载，那么引用 B 指向的 B 对象会常驻内存，知道程序终止。</p>
<h2 id="及时清除不再需要的会话"><a href="#及时清除不再需要的会话" class="headerlink" title="及时清除不再需要的会话"></a>及时清除不再需要的会话</h2><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为 30 分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据 MRU（最近频繁使用）算法把不分不活跃的会话转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用 HttpSession 的 invalidate() 方法清楚会话。</p>
<h2 id="实现-RandomAccess-接口的集合比如-ArrayList，应当使用最普通的-foreach-循环来遍历"><a href="#实现-RandomAccess-接口的集合比如-ArrayList，应当使用最普通的-foreach-循环来遍历" class="headerlink" title="实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 foreach 循环来遍历"></a>实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 foreach 循环来遍历</h2><p>这是 JDK 推荐给用户的。JDK API 对于 RandomAccess 接口的解释是：实现 RandowAccess 接口用来表明其支持快速随机访问，此接口的主要目的是允许一般算法更改其行为，从而将其应用到随机或连续访问列表式能提供良好的性能。实际经验表明，实现 RandomAccess 接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用 foreach 循环；反过来，如果是顺序访问的，则使用 Iterator 效率更高。可以使用类似如下的代码做判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach 循环的底层实现原理就是迭代器 Iterator ；可变长度参数以及 foreach 循环原理。所以后半句“反过来，如果是顺序访问的，则使用 Iterator 效率会更高”的意思就是顺序访问的那些类实例，使用 foreach 循环去遍历。</p>
<h2 id="使用同步代码块替代同步方法"><a href="#使用同步代码块替代同步方法" class="headerlink" title="使用同步代码块替代同步方法"></a>使用同步代码块替代同步方法</h2><p>这点在多线程模块中的 synchronized 锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
<h2 id="将常量声明为-static-final，并以大写命名"><a href="#将常量声明为-static-final，并以大写命名" class="headerlink" title="将常量声明为 static final，并以大写命名"></a>将常量声明为 static final，并以大写命名</h2><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量。</p>
<h2 id="不要创建一些不使用的对象，不要导入一些不使用的类"><a href="#不要创建一些不使用的对象，不要导入一些不使用的类" class="headerlink" title="不要创建一些不使用的对象，不要导入一些不使用的类"></a>不要创建一些不使用的对象，不要导入一些不使用的类</h2><p>这毫无意义，如果代码中出现 “The value of the local variable i is not used”、“The import java.util is never used”，那么请删除这些无用的内容。</p>
<h2 id="程序运行过程中避免使用反射"><a href="#程序运行过程中避免使用反射" class="headerlink" title="程序运行过程中避免使用反射"></a>程序运行过程中避免使用反射</h2><p>反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，<br>特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存——用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p>
<h2 id="使用数据库连接池和线程池"><a href="#使用数据库连接池和线程池" class="headerlink" title="使用数据库连接池和线程池"></a>使用数据库连接池和线程池</h2><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。</p>
<h2 id="使用带缓冲的输入输出流进行-IO-操作"><a href="#使用带缓冲的输入输出流进行-IO-操作" class="headerlink" title="使用带缓冲的输入输出流进行 IO 操作"></a>使用带缓冲的输入输出流进行 IO 操作</h2><p>带缓冲的输入输出流，即 BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升 IO 效率。</p>
<h2 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h2><p>顺序插入和随机访问比较多的场景使用 ArrayList，元素删除和中间插入比较多的场景使用 LinkedList 这个，理解 ArrayList 和 LinkedList 的原理就知道了。</p>
<h2 id="不要让-public-方法中有太多的形参"><a href="#不要让-public-方法中有太多的形参" class="headerlink" title="不要让 public 方法中有太多的形参"></a>不要让 public 方法中有太多的形参</h2><p>public 方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p>
<ul>
<li>违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</li>
<li>参数太多势必导致方法调用的出错概率增加<br>至于这个”太多”指的是多少个，3、4 个吧。比如我们用 JDBC 写一个 insertStudentInfo 方法，有 10 个学生信息字段要插入 Student 表中，可以把这 10 个参数封装在一个实体类中，作为 insert 方法的形参。</li>
</ul>
<h2 id="字符串变量和字符串常量-equals-的时候将字符串常量写在前面"><a href="#字符串变量和字符串常量-equals-的时候将字符串常量写在前面" class="headerlink" title="字符串变量和字符串常量 equals 的时候将字符串常量写在前面"></a>字符串变量和字符串常量 equals 的时候将字符串常量写在前面</h2><p>这是一个比较常见的小技巧了，如果有以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;119&quot;</span>; </span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;119&quot;</span>)) &#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>建议修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;119&quot;</span>; </span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;119&quot;</span>.equals(str)) &#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="不要对数组使用-toString-方法"><a href="#不要对数组使用-toString-方法" class="headerlink" title="不要对数组使用 toString() 方法"></a>不要对数组使用 toString() 方法</h2><p>看一下对数组使用toString()打印出来的是什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">111</span>, <span class="number">123</span>, <span class="number">234</span>&#125;; </span><br><span class="line">    System.out.println(is.toString()); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>本意是想打印出数组内容，却有可能因为数组引用 is 为空而导致空指针异常。不过虽然对数组 toString() 没有意义，但是对集合 toString() 是可以打印出集合里面的内容的，因为集合的父类 AbstractCollections<E> 重写了 Object 的 toString() 方法。</p>
<h2 id="公用的集合类中不使用的数据一定要及时-remove-掉"><a href="#公用的集合类中不使用的数据一定要及时-remove-掉" class="headerlink" title="公用的集合类中不使用的数据一定要及时 remove 掉"></a>公用的集合类中不使用的数据一定要及时 remove 掉</h2><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去 remove 掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p>
]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑DIY系列——电脑硬件——显卡</title>
    <url>/articles/PC-DIY-Graphics-Card.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>电脑组装</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>显卡</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑DIY系列——电脑硬件</title>
    <url>/articles/PC-DIY-Hardware.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h1><p>对于一个程序猿+骨灰级游戏玩家来说，一台兼具高性能及高性价比的电脑是必须的。自己拥有动手能力，懂得硬件组成，了解性能相关参数，长期关注各大品牌配件，会分析价格趋势，知道一点行业内幕，算是基本达标了。</p>
<span id="more"></span>

<p>为什么要DIY，这个大家都懂的。京东、淘宝、苏宁不是没有整机，但是永远会用厂商卖不出去的低性能低性价比配件，达不到自己的需求，且外观不是自己想要的样子；至于实体店呢，就一个问题，你敢去么，且不说懂得相关知识的人去了也被忽悠，大多数店甚至会楼下拉客楼上宰客不买把你围起来，至于小白那您就更别想了。</p>
<p>基于此，DIY才是坠吼的，既能买到符合自己需求的高性价比配件，又能享受装机的快乐♂时光，何乐而不为呢？</p>
<h1 id="台式机优势"><a href="#台式机优势" class="headerlink" title="台式机优势"></a>台式机优势</h1><p>有笔电有Macbook有iMac，台式机的优势何在呢？</p>
<p>首先自己的设备说一下。</p>
<p>一台Dell灵越系列笔电，大一的时候买的，8G内存760显卡，实在撑不住了，已经不能忍了。其实单机还好，卡是卡了点，20+fps，我也能狗得住，但是有一天打开了LOL载入了十几分钟，然后我还咩有加载好，这把已经输了23333，那时候自己组一台机子的愿望越来越强烈。而且我也好想玩“别人家的”巫师3，别人家的老滚，别人家的GTA，别人家的……啊……</p>
<p>一台公司配备的Lenovo办公笔电，垃圾配置不说也罢，编译个项目要一分半钟，开启服务器五十秒，嗯，放弃了。</p>
<p>一台MacBook Pro，平时敲敲代码也不错，没有独显玩个小游戏都要爆炸，冬天暖手不错。</p>
<p>好多人说，笔记本方便啊，想带去哪带去哪，但是我想说，你在外面玩游戏么？别是在逗我吧。也就办办公、学学习用一下咯，MacBook Pro已经完全胜任。</p>
<p>干脆在家里组个机子，买个2K32寸大屏，靠床上拿着无线手柄打游戏。啥你说怎么不买主机？Sorry我不要，性价比啊兄弟。两千的主机只能打个游戏，别的啥也干不了；其次，我几千组的机子性能完虐主机好吧？</p>
<p>大概总结一下，组机好处：</p>
<ul>
<li>反正在外面就算带着笔电也不怎么能打游戏，还不如组个台式在家里舒舒服服玩。</li>
<li>比起昂贵的游戏本，台式可以再较低的价格做到同样甚至更好的性能，至少，台式机可以轻松解决温度、噪音问题。</li>
<li>可以自主屏幕大小，一台廉价的24寸1080P的IPS显示器可能比那些2K睾跪的17寸笔记本显示器看起来更舒服，还能保护视力。</li>
<li>拆装升级方便，配件升级随时换，有着无数升级的潜力和空间。喵？你说外置显卡外置内存？你抱着个大插槽坞用笔电？怕不是风扇转起来能把周围空气都融化掉，顺便吸引周围人关爱智障的目光。</li>
<li>工作效率更高，甚至可以花4k+就配置出一套Ryzen1700工作机，即使不超频，渲染效率依然惊人，笔记本很少能打到Ryzen1700这种渲染效率，你甚至会发现渲染速度是Mac的几倍，于是你就想扔掉Mac了，可以寄给我，我愿意当接盘侠。还可以加钱买到很好的显卡，轻松解决建模问题。</li>
<li>各司其职。Mac就该干学习、工作的事情；笔记本没啥卵用，就是方便外带临时用一下；台式就打游戏或者做渲染。</li>
</ul>
<h1 id="消费观念"><a href="#消费观念" class="headerlink" title="消费观念"></a>消费观念</h1><p>大概也就这么几种消费心理呗~</p>
<ul>
<li>舍不得换，我的7XX还能再战几年= =</li>
<li>先换个便宜点的，9XX系列，1XXX明年明年就出，再观望一下~</li>
<li>草，买买买，为信仰充值，啥都最高配置，哪怕先贷个万把块钱！</li>
<li>嗯，现在有几千块钱，刚刚好花完，选择性价比高的一套配置。</li>
</ul>
<p>插♂一句嘴，囿于经济状况而无法选择更好的配置的盆友，我就不再提了，看到某些不经过我大脑的话不要不开心，好好努力学习努力工作哦，以后会有实力为自己的生活锦上添花的，加油！！！</p>
<p>首先声明，我理解各种消费观念，但是我选择自己的理念。以下仅面向有一定经济实力的朋友的消费观念，发表一些个人的观点看法，当然每个人都有自己的理念，有不同意见可以在下面留言吖。</p>
<p>嘛，第一种，兄弟，作为男孩子，或者作为男人，你连自己都舍不得给自己花钱，怎么变成有趣的人，拥有有趣的灵魂。其实我之前也是这样的人，也不能说这样的男孩子真的无趣，因为有些人确实是为经济所困，那么这样也是无奈之举。但是如果有一定的经济能力，还有这样的心态，请出门左转，走好不送。这里挖个坑，以后会写一篇文章剖析一下这样的心理。</p>
<p>第二种，是较为克制的消费观念，永远跟不上潮流，舍不得买本世代因为觉得会变成上世代，自己却永远用着上世代的便宜货又观望着次世代，次世代出来了自己的老货已经要进棺材了。于是先凑合几年，再循环下去。不说啥，我觉得这样性价比最低。</p>
<p>第三种，土豪请让我抱抱大腿。除了土豪剩下的大概就是要交好多智商税的。让自己背着外债难受不说，现在的主流3A大作在有优化的前提下，几千块钱的高性价比配置已经足够高特效流畅运行了，没有特殊需求的话，性能溢出，有个卵用啊？多余的钱不如拿去看看书学习学习，实在想花钱买个单反镜头啥的也好，要么玩耳机音响吧，大把烧钱的地方，不愁花不完。</p>
<p>第四种，理性消费。我的理念是，<strong>在自己经济条件允许范围内选择最贵的最高性价比的。</strong>比如我下个月发工资，7k+，我会选择再贷3k，总共10k+，这个价位在我心理是可以接受的，而且再下个月也还得起。首先不会给我经济方面带来太多困扰，也能比预期配置更好一些，贷款更早买到，早用早享受，反正迟早要买不是么？</p>
<p><strong>以下会基于10k左右预算来选择主机相关硬件配置。</strong></p>
<h1 id="电脑硬件组成"><a href="#电脑硬件组成" class="headerlink" title="电脑硬件组成"></a>电脑硬件组成</h1><p>在此声明哈，一般选择DIY的，七成游戏需求，二成软件需求，一成没需求。我只是个程序猿不是设计师或者什么别的师，软件需求的配置我不懂我也不瞎BB，没需求的请根据经济条件随意组装，<strong>以下仅面向游戏需求。</strong></p>
<p>一般也就这些需要准备啦，每一个后面列出的是我个人的选择，简单列举一下：</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>电脑的大脑，其重要性可想而知。</p>
<p>个人推荐：Intel i7 8600K 散片 ￥1800</p>
<p>高端领域，2130元的4c8t的i7 7700K大战2080元8c16t的Ryzen 1700，7700K虽然核心和线程少，但是可以超频到 4.9-5.1G，可以说是地表单核性能最强的CPU，而Ryzen虽然核心线程多了一倍，但是频率上限依然还是3.9G-4.1G。也就是说，7700K和1700的战斗，就是强力单核大战核心数量的战争。</p>
<p>单纯玩大型游戏的话，4c8t已经非常够用了，核心数目再多也难以利用，这时候7700K依然是非常好的选择，某些专业软件只能利用极少的核心线程数，那选择7700K也是毫无悬念。7700K的另一个优点是默认频率4.2G，不超频就已经非常生猛，而Ryzen 1700不超频的话默认频率只有3.0G。同样地，如果涉及到直播或者重度的渲染等，依然推荐Ryzen 1700。</p>
<p>i5-8600K 大战 i7-7700K，价格相当如何选？下面从几个方面谈谈我的观点。</p>
<p>价格：八代酷睿上市之后价格并非传闻那样加量不加价，目前国行价格对比官方指导价而言简直是贵出天际，这个应该跟前期供货紧不无关系，等大量到货特别是散片全面开卖之后价格相信会回落到合理的位置，而 i7-7700K 也因为八代酷睿目前价格较高的缘故而未见明显下降，由此相信 i7-7700K 的价格会一直坚挺直到八代酷睿大量供货。</p>
<p>性能：i7-7700K 凭借更高的默频，在测试中能够保持单核性能领先，但多核性能方面会由于核心数量的劣势而不敌 i5-8600K，而且随着频率的提高，这个劣势会进一步扩大。在目前大部分主流软件都能发挥多核心性能的前提下，i5-8600K 比 i7-7700K 快是没有悬念的。</p>
<p>平台：目前 i5-8600K 必须搭配 Z370 芯片组主板，而 i7-7700K 则可以选择成熟的 Z270 甚至是 Z170 芯片组主板，因此在 CPU 的选择上就必须考虑到整套平台的搭配。从目前来说，i7-7700K 可选择的主板灵活性更大，主板价格也更便宜，而主板上的差价足以抵消 CPU 的差价，因此两套平台的性价比依然是半斤八两。</p>
<p>经过一轮的分析，目前 i5-8600K 与 i7-7700K 两者都没有压倒性的优势，但从长远来说，选择 i5-8600K 的话未来还能保留主板升级到 i7-8700K 甚至更高的型号，而 i7-7700K 则已经是该平台的极限，要升级得连主板一起换，所以从新购机的角度来说，我会选择 i5-8600K，而 i7-7700K 则适合手上已经有兼容的主板并希望能够提升 CPU 性能的用户去选择。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>是连接CPU 和其他设备的通道，起到缓冲和数据交换作用。 当CPU在工作时，需要从硬盘等外部存储器上读取数据，但由于硬盘这个“仓库”太大，加上离CPU也很“远”，运输“原料”数据的速度就比较慢，导致CPU的生产效率大打折扣！为了解决这个问题，人们便在CPU与外部存储器之间，建了一个“小仓库”——内存。</p>
<p>个人推荐：美商海盗船(USCORSAIR) 复仇者LPX DDR4 3000 16GB(8Gx2条) 台式机内存 CL15 1550元</p>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>保证你看毛骗不卡的。</p>
<p>个人推荐：索泰（ZOTAC）GeForce GTX1070Ti-8GD5 至尊PLUS 吃鸡显卡 1607-1683MHz/8008MHz 8G/256bit GDDR5 3500元</p>
<p>另开文讲讲显卡。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>个人推荐：微星Z370  GAMING PLUS ￥1080 不要这个&gt;.&lt;</p>
<p>华擎 Z370 Pro4  ￥800左右但是很垃圾 不要这个&gt;.&lt;</p>
<p>华擎 Z370 Killer Sli 不要这个。</p>
<p>技嘉 Z370 AORUS Ultra Gaming 就这个了，加上8600<br>k应该是3400以内才对。</p>
<p>技嘉1300</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>主要功能就是存你那些毛骗的。</p>
<p>个人推荐：希捷 ST1000DM010 1T新酷鱼1Tb台式机械电脑硬盘 300元</p>
<p>虽然WD也不错但是别买。不解释。</p>
<h2 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h2><p>三星40%市场占有率，全方位吊打各种。价格略高，但性价比不错。</p>
<p>个人推荐：三星 PM961 NVMe 256G PCIE M.2 非SM 669元</p>
<p>不解释。</p>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>必须京东。</p>
<p>个人推荐：全汉蓝暴经典550W  ￥300</p>
<p>为啥必须京东，包退换。</p>
<h2 id="散热"><a href="#散热" class="headerlink" title="散热"></a>散热</h2><p>个人推荐：超频3 东海X5   ￥80</p>
<h2 id="风道"><a href="#风道" class="headerlink" title="风道"></a>风道</h2><p>个人推荐：先马魔灯RGB *3  ￥75</p>
<h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><p>个人推荐：先马塞恩3 ￥159</p>
<h2 id="音箱"><a href="#音箱" class="headerlink" title="音箱"></a>音箱</h2><p>显示器内置音箱，暂时不需要。主板自带魔音，以后会搭配一个好一点的音箱，但这玩意儿听说贼烧钱。所以等有钱的时候再烧吧。</p>
<h2 id="耳机"><a href="#耳机" class="headerlink" title="耳机"></a>耳机</h2><p>个人推荐：爱科技（AKG）Y50 便携头戴式耳机 重低音 线控耳麦 立体声耳机 HIFI音乐耳机  650元</p>
<p>耳机也是个烧钱的玩意儿……但是选一个好耳机让自己放松一下还是不错的。</p>
<h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>个人推荐：暂时没啥需求，有一个双飞燕光轴 300元左右</p>
<p>以后会买个青轴，敲代码、写文章、扰民用，一个黑轴打游戏。到时候再做推荐。</p>
<h2 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h2><p>个人推荐：雷蛇（Razer）蝰蛇2000 游戏鼠标 黑色版 160元左右</p>
<h2 id="手柄"><a href="#手柄" class="headerlink" title="手柄"></a>手柄</h2><p>个人推荐：微软Xbox无线控制器 特遣奇兵限量版 360元 京东</p>
<h2 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h2><p>保证你看毛骗是清晰的。</p>
<p>个人推荐：AOC 爱攻II AG322QCX 31.5英寸 2K高清 144Hz ΔE&lt;3 1800R 大屏曲面 3700元左右</p>
<p>普通显示器刷新率60fps，玩起第一人称射击、赛车类游戏的时候你懂的……所以144Hz是必要的。</p>
<p>2K画质对于追求画面的童鞋来说也是标配，没什么毛病。</p>
<p>32英寸曲面大屏，不论是看电影、玩游戏，那种沉浸感感受到一次之后就用不了别的了。除非有一天你用4K 35英寸曲面大屏全方位吊打，但是呢，你觉得4K+144Hz，一般人买得起么？</p>
<p>而且内置音箱，虽然略微鸡肋，但有时候也是必要的。</p>
<p>综合来看，对于画面细节、游戏流畅度、氛围有较高需求的盆友，不要错过这一款诶。</p>
<blockquote>
<p>攒机总结：</p>
<ul>
<li><p>CPU：Intel i5 8600k  ￥1800</p>
</li>
<li><p>内存：美商海盗船(USCORSAIR) 复仇者LPX DDR4 3000Mhz 16GB(8Gx2条) 台式机内存 CL15？？？ ￥1580</p>
</li>
<li><p>显卡：ZOTAC GeForce GTX1070Ti-8GD5 至尊PLUS ￥3500</p>
</li>
<li><p>主板：技嘉 Z370 Aorus Ultra Gaming 3 ￥1299</p>
</li>
<li><p>硬盘：希捷 ST1000DM010 1T新酷鱼1Tb 7200转 ￥300</p>
</li>
<li><p>固态：三星 PM961 NVMe 256G PCIE M.2 非SM ￥690</p>
</li>
<li><p>电源：全汉蓝暴经典550W  ￥300</p>
</li>
<li><p>散热：超频3 东海X5 ￥80</p>
</li>
<li><p>风道：先马魔灯RGB *3  ￥75</p>
</li>
<li><p>机箱：先马塞恩3 ￥160</p>
</li>
<li><p><strong>以上总价：9885元</strong></p>
</li>
<li><p>显示器：AOC 爱攻II AG322QCX 31.5英寸 2K高清 144Hz ΔE&lt;3 1800R 大屏曲面 ￥3700</p>
</li>
<li><p>手柄：微软Xbox无线控制器 特遣奇兵限量版 ￥360</p>
</li>
<li><p>鼠标：雷蛇（Razer）蝰蛇2000 游戏鼠标 黑色版 ￥160</p>
</li>
<li><p>键盘：随便一个青轴 ￥300</p>
</li>
</ul>
<p><strong>以上总价：14375元</strong></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">艹。穷了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>东西还是蛮多的，以后会分类整理各个配件的对比，大家可以后续关注。</p>
<h1 id="潜规则"><a href="#潜规则" class="headerlink" title="潜规则"></a>潜规则</h1><p>啥玩意儿都有潜规则，电脑硬件这玩意儿，水太深了。这里随便列一点，大家感受一下。</p>
<h2 id="容量大电脑性能就好？"><a href="#容量大电脑性能就好？" class="headerlink" title="容量大电脑性能就好？"></a>容量大电脑性能就好？</h2><p>不能否认的是，内存容量太小确实会对系统的运行速度造成影响，所以我们也很容易被商家给出的“**G内存”这样的字眼唬住，但事实上内存并不能完全代表电脑的性能。</p>
<p>能对电脑性能产生决定性影响的，是CPU和显卡性能，以及硬盘的读写速率。例如，同样是1TB硬盘，机械硬盘的读写速度不会超过130MB/s，而PCI-E固态硬盘的读取速度则可以超过3.5GB/s，这其中的速度差异有多大可想而知。</p>
<h2 id="看脸色乱报价"><a href="#看脸色乱报价" class="headerlink" title="看脸色乱报价"></a>看脸色乱报价</h2><p>在购买之前，最好先查询清楚该零件的实际价格。有部分商家会根据消费者的表情、说话语气以及反应胡乱进行报价。</p>
<p>报高报低都有可能。你以为报低了他们就没得赚吗？错了！价格报得低，可以让消费者在自己店里组装，再通过其他方面的收费来补回损失。而报价高的时候，则贬低低价产品质量，传达价格虽高但质量绝对有保证的意思。</p>
<p>许多人会觉得多花点钱也无所谓，毕竟质量好就耐用，也是划算的。但其实有时候价格与电脑的质量关系不大。</p>
<h2 id="更换产品的型号"><a href="#更换产品的型号" class="headerlink" title="更换产品的型号"></a>更换产品的型号</h2><p>这个就比较典型了。装过机的人应该都知道，硬件产品众多，产品型号也多得让人眼花缭乱。</p>
<p>例如一款GTX 1060，就有3GB、6GB两个版本，更有至少五大品牌，价格相差甚远。</p>
<p>即使你拿着写好的配置单去配电脑，他们也有各种借口建议你更改产品型号，例如“你原先想要的型号没有货”、“另一种其实更搭”等等。</p>
<p>当你同意更换后，可能就会以一线牌子的价格，买到拆机件、二手件，所以对于商家给出的更换型号的建议，必须保持警惕！</p>
<h2 id="直接更换产品"><a href="#直接更换产品" class="headerlink" title="直接更换产品"></a>直接更换产品</h2><p>各产品的价格利润大不相同。商家当然希望消费者能购买高利润产品，甚至是高利润的劣质产品！如果商家能将你成功说服，只能说他们厉害或者你意志不坚定，但如果他们未经你同意擅自更换掉你的产品，那可以说就很无良了！</p>
<blockquote>
<p>言归正传，对于不懂DIY组装电脑的朋友，只能任由商家用一些专业术语把你绕得云里雾里，反正机器一盖，对电脑不懂的人也很难发现其中的猫腻。所以说，自行组装电脑的水真的很深，如果选择装机，一定要事先做好功课，别等组装的时候任由电脑商宰割！</p>
</blockquote>
<h1 id="一些要额外考虑的问题"><a href="#一些要额外考虑的问题" class="headerlink" title="一些要额外考虑的问题"></a>一些要额外考虑的问题</h1><h2 id="限电问题"><a href="#限电问题" class="headerlink" title="限电问题"></a>限电问题</h2><p>这个放学校寝室或者线路老化的老房子可能还是要考虑的问题，不过，一般没有人会考虑这个吧？</p>
<h2 id="温度和噪音"><a href="#温度和噪音" class="headerlink" title="温度和噪音"></a>温度和噪音</h2><p>带着100%转速温度还90+摄氏度的显卡？你确定你不是来报复社会的？</p>
<p>请相信，笔记本小风扇再转，也转不过满转速的台式机风扇；笔记本再热，也只会影响笔记本周围物件，而一台高温的台式机，真的可以和取暖器一争高下，建议南方没有暖气的盆友考虑置购一台，真可以当暖气了。</p>
<p>另外说一句，实在想要机械键盘，请不要买青轴！！！噪音大的青州键盘绝对是破坏各种关系的一大利器，即使家人白天不在意但是当夜深人静大家都睡觉的时候，而你用青轴啪啪啪，我可以保证，这真的是作死；而在学校寝室和办公室，你相信我，你会死得很惨。</p>
<h2 id="体积问题"><a href="#体积问题" class="headerlink" title="体积问题"></a>体积问题</h2><p>某些机箱、显示器的尺寸，桌子下面塞不下，放桌子上又影响视觉效果和体验。建议有个大点的桌子，且用且珍惜。</p>
<h2 id="整洁问题"><a href="#整洁问题" class="headerlink" title="整洁问题"></a>整洁问题</h2><p>拥有一台狂拽酷炫吊炸天的外观的机箱和显示器，打开一看线材乱七八糟，桌子上也散着一大堆缠来绕去的线，既脏又不美观。对于影音、工作、单机游戏为主的玩家，完全可以用无线网卡+无线键鼠+无线手柄。</p>
<h2 id="升级问题"><a href="#升级问题" class="headerlink" title="升级问题"></a>升级问题</h2><p>因为台式机便捷的升级方式，在当初配置的时候请尽量购买较高性能的配件，否则，不求稳瞎折腾，你会花无数钱在上面。</p>
<h1 id="一些误区"><a href="#一些误区" class="headerlink" title="一些误区"></a>一些误区</h1><h2 id="电源转化率和额定功率以及限电问题"><a href="#电源转化率和额定功率以及限电问题" class="headerlink" title="电源转化率和额定功率以及限电问题"></a>电源转化率和额定功率以及限电问题</h2><p>实时的转化率=电源输出的功率/电源消耗的功率。电源转化率越高越省电，因为这相当于电源“浪费”的电更少了。</p>
<p>很多人问，麦迪瓦数的地段电源是省电么？错！！瓦数低反而费电，地段电源转化率也低。举个栗子，同样输出300W，垃圾杂牌额定350W的电源可能会消耗400W的电量，因为它在高负载下转化率低，需要浪费更多的电。对于学校寝室来讲，如果寝室限电刚好是400W，会直接引起断电。而如果选择不错的电源，在输出300W的时候可能只会消耗320W的电量，不会引起断电，而且也相对节省电能。电源负载50~60%的时候转化率最高，最节能，所以也最不容易超过限电额度。</p>
<p>一定要搞清楚的问题是，额定550W并不表示它一直输出550W的功率，这只表示它长期稳定工作的最大功率，懂“最大”这个词的意思吧？</p>
<p>电源负载太高转化率也会变低，更重要的是会变得不稳定。某些实体店奸商总喜欢推荐垃圾杂牌低瓦数电源，美名其曰“能带动就行”。</p>
<p><strong>请不要在电源上省钱</strong>，300+的电源，一点也不贵！</p>
<p>另外针对还在学校寝室的盆友说一句，<strong>越是限电越要买好电源，越是限电越要买瓦数充裕的电源</strong>，那种低瓦数垃圾电源只会给你带来更多麻烦！</p>
<h1 id="一些小建议"><a href="#一些小建议" class="headerlink" title="一些小建议"></a>一些小建议</h1><ul>
<li>看了刚才的潜规则，你还敢去实体店？乖乖跟着dalao的配置清单淘宝京东苏宁去吧。</li>
<li>但是有一种实体店可以去，推荐去斗鱼装机区的大主播，选择在自己城市的，那么多人看着，一般也不会太坑。攒下来整个机子，我原价13000左右的现在9800左右就能解决，也不错。</li>
<li>网购其实水也很深，但大体选择人气店旗舰店就好。</li>
<li>记得买之前问问商家有没有“暗车”。不动自行百度。挖个坑，以后分门别类比较各种配件的时候我会加上当前的暗车价格。</li>
<li>CPU不要买包装卡，买散片，跟店家联系，加点钱让他帮你选个高配。</li>
<li>上面说过的，电源不要买低瓦数垃圾电源。</li>
<li>……慢慢补充吧。</li>
</ul>
]]></content>
      <categories>
        <category>电脑组装</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑DIY系列——电脑硬件——内存</title>
    <url>/articles/PC-DIY-RAM.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>啊啊啊内存真特喵大坑。</p>
<p>首先，内存真贵，看到价格我就跟吃了翔一样难受。</p>
<p>曾经DDR3 8G 150元一根，以前也没有组机需求，也觉得电子配件这玩意儿，价格应该是一跌再跌吧，结果涨到200、300、甚至突破400，从前以为是购物节先涨价后降价的套路吧。</p>
<p>然而400多还没有降价的时候，已经觉得天要塌了。然而……</p>
<p>曾经微星700元的B150M MORTAR送8G D4的芝奇大钢牙或者英睿达白马甲。然而……</p>
<p>沃日喃妈哟，吖儿咯，现在大厂8G最低价800，动辄900+上千的价格，黑人问号.jpg……</p>
<p>其实看到价格趋势之后，屯一批货的做法才是更正确的，亚马逊、海淘随意，反正比京东淘宝价格低，以后加价转手，然而没钱。笑。</p>
<p>关于内存选择，挖坑，以后填。</p>
]]></content>
      <categories>
        <category>电脑组装</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑DIY系列——电脑硬件——一些不同价位的成套配置</title>
    <url>/articles/PC-DIY-Sets.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有时候实在懒得看太多品牌，一件一件去对比，还要关注价格趋势啥的，所以纵览各种贴吧论坛，搬运一些dalao的推荐配置。</p>
<p>同理，只针对于游戏玩家。设计师和无需求的不管。</p>
<span id="more"></span>

<h1 id="本文食用攻略和注意事项"><a href="#本文食用攻略和注意事项" class="headerlink" title="本文食用攻略和注意事项"></a>本文食用攻略和注意事项</h1><ul>
<li>照着买就行了，别纠结。</li>
<li>不再推荐任何可能会翻车的配件，但是昂达1050Ti这种爵士乞丐除外，只要价格降到位，没有不能推荐的产品（笑。</li>
<li>不过分追求性价比而选择小众品牌，尽量全部选择大品牌。为了方便，同类产品只选择一款。</li>
<li>没有特别注明就是在淘宝买，注明京东就是京东买。所有电源毫无疑问京东，因为电源是最需要保修的，尽管损坏率很低，首先淘宝不比京东便宜，其次淘宝坑爹的退货很难受，而京东电源出问题了大多数是直接换新。</li>
</ul>
<h1 id="入门级办公配置"><a href="#入门级办公配置" class="headerlink" title="入门级办公配置"></a>入门级办公配置</h1><ul>
<li>CPU：G4560散片 405元 / G4600散片 445元</li>
</ul>
<p>尽管现在比最低价时涨了100元，然而性价比依然可以接受，跑分和实际使用证明这U完全可以匹敌I3 6100，这U一下子让I3 6100，i3 7100变得完全没有任何购买价值！<br>G4600比G4560性能强一丝丝，核显强一大截，当然还是被独显吊打，买G4600还是G4560都行。</p>
<ul>
<li>主板：微星H110M PRO VD 320元</li>
</ul>
<p>便宜，性价比不错，至少供电不缩，4+2供电已经可以带起7700K，然而如果你真用这板子去带7700K的话我只能说洗洗睡吧，凡事求稳，这板子我只推荐来带G4560，撑死7500，缺乏供电散热片而且没有M.2接口。</p>
<ul>
<li>内存：光威DDR4 8G 2133，560元…………….</li>
</ul>
<p>内存不重要，用起来都差不多，这价格……</p>
<ul>
<li>散热器：土狼绿箭GH400，60元。</li>
</ul>
<p>可能是能买到的最便宜的塔式温控静音塔式散热</p>
<ul>
<li>显卡：核显 0元</li>
</ul>
<p>（笑）</p>
<ul>
<li>机箱：金河田预见n6 plus，129元的垃圾机箱</li>
</ul>
<p>可能是广告做的最好看的机箱。</p>
<ul>
<li>电源：首席玩家500W火玫瑰，169元。JD</li>
</ul>
<p>可能是垃圾电源里唯一的良心，必须京东买，换了随时换新。</p>
<ul>
<li><p>机械硬盘：西数（或希捷）1T 300元</p>
</li>
<li><p>固态硬盘：闪迪Z400s 120G 370元</p>
</li>
</ul>
<p>低端入门级固态，不过依然能为系统带来巨大的提升。如果预算实在不够，固态和机械硬盘去掉一个吧。</p>
<p><strong>总计：2313元</strong></p>
<h1 id="低端游戏配置"><a href="#低端游戏配置" class="headerlink" title="低端游戏配置"></a>低端游戏配置</h1><p>对于大多数人而言，推荐低端游戏配置。先别生气，低端不一定代表性能差。</p>
<h2 id="入门级游戏配置：3000元左右"><a href="#入门级游戏配置：3000元左右" class="headerlink" title="入门级游戏配置：3000元左右"></a>入门级游戏配置：3000元左右</h2><p>只是在上面办公配置的基础上加了显卡，换了更好的电源和内存。该配置试用大多数网游，即使是守望这样的游戏只要不追求全特效也毫无压力。预算不足又追求性价比，就选这套。</p>
<p>吃鸡需要12G内存，再穷也要拼死再买个4G的内存加上去。</p>
<ul>
<li>CPU：G4560散片 405元 / G4600散片 445元</li>
</ul>
<p>尽管现在比最低价时涨了100元，然而性价比依然可以接受，跑分和实际使用证明这U完全可以匹敌I3 6100，这U一下子让I3 6100，i3 7100变得完全没有任何购买价值！<br>G4600比G4560性能强一丝丝，核显强一大截，当然还是被独显吊打，买G4600还是G4560都行。<br>因为有独显了，所以核显无意义。</p>
<ul>
<li>主板：微星H110M PRO VD 320元</li>
</ul>
<p>便宜，性价比不错，至少供电不缩，4+2供电已经可以带起7700K，然而如果你真用这板子去带7700K的话我只能说洗洗睡吧，凡是求稳，这板子我只推荐来带G4560，撑死7500，缺乏供电散热片而且没有M.2接口。</p>
<ul>
<li>内存：英睿达8G ddr4 2400，600元。</li>
</ul>
<p>所有不超频的配置，都用这个条子！同价位里可能是最吼的做工，就问你们支持不支持。</p>
<ul>
<li>散热器：土狼绿箭GH400，60元。</li>
</ul>
<p>可能是能买到的最便宜的塔式温控静音塔式散热。</p>
<ul>
<li>显卡：昂达1050ti 4G神盾 899元 </li>
</ul>
<p>这就是乞丐，毫无疑问的乞丐，但是性价比秒天秒地。缺点是噪音略大，频率也很低。昂达1050ti彻底改变了1050ti，具有跨时代意义！不想提昂达家另一个乞丐，那噪音可不是略大两个字能形容的） 七彩虹/索泰/影驰等等双风扇的1050ti 4G，950元。比昂达贵50，在静音上好很多，不要买太贵的1050ti，没意思。显卡可以砍价，请注意。直接还价950。</p>
<ul>
<li>机箱：金河田预见n6 plus，129元的垃圾机箱</li>
</ul>
<p>可能是广告做的最好看的机箱。</p>
<ul>
<li>电源：航嘉jumper450B，269元。JD</li>
</ul>
<p>低端电源里的良心，必须京东买，一定要注意看清楚是450B不是450S！</p>
<ul>
<li><p>机械硬盘：西数（或希捷）1T 300元 （选配）</p>
</li>
<li><p>固态硬盘：闪迪Z400s 120G 370元</p>
</li>
</ul>
<p>低端入门级固态，不过依然能为系统带来巨大的提升。如果预算实在不够，固态和机械硬盘去掉一个吧</p>
<p><strong>总计：3054元（不包含1T硬盘）</strong></p>
<h2 id="中特效游戏配置：3500左右"><a href="#中特效游戏配置：3500左右" class="headerlink" title="中特效游戏配置：3500左右"></a>中特效游戏配置：3500左右</h2><blockquote>
<p>这套配置可以胜任一切网游，以中或者中偏高的特效带动目前99%的大型单机。游戏性能和最便宜的那款一万四千多元的外星人笔记本差不多（甚至略胜）。</p>
</blockquote>
<blockquote>
<p>这套配置可以胜任轻度中度的渲染/建模/音频视频制作工作。</p>
</blockquote>
<ul>
<li>主板：微星H110M pro vd/vh 310元</li>
<li>CPU：G4600 430元</li>
<li>内存：英睿达8G DDR4 2400 460元（现在已经700元一根了…没办法）</li>
<li>显卡：索泰gtx1060 3g毁灭者 1450元</li>
<li>硬盘：希捷1T 300元（选配）</li>
<li>固态：东芝Q200EX 600元</li>
<li>电源：酷冷至尊GX450 300元</li>
<li>散热器：GH400 60元</li>
<li>机箱：先马米立方 200元</li>
</ul>
<p><strong>主机总计：3410元</strong></p>
<p>显示器：惠普(hp)23es 23英寸 800元</p>
<p>电源和显示器京东买，其他淘宝，显示器是随便选的，只要是正规品牌23寸IPS都行。</p>
<p>简单解释一下：</p>
<p>G4600，去年（2016）它是性价比之王，今年（2017）它还是，Ryzen没有撼动它的地位，八代U也不太可能打败它。3.6G，双核四线程，尽管它只是奔腾，性能超过了大多数笔记本低压i7，如果考虑到发热降频问题，老款的标压i7也不一定能打败它。而3.6G的高频率，在使用体验上甚至可能超过某些奇葩台式机I5，没错，我说的就是坑神i5-6400，实体店奸商的最爱。然而G4600只需要430元，而i5-6400奸商还要卖到近1000元，没错，现在还有实体店在卖6400。而且，G4600发热还很低，功耗也不高（当然远高于笔记本低压i7）。</p>
<p>微星H110M pro vd/vh，vd和vh几乎没区别。这是一款性价比非常高的主板，除了坠重要的供电很足以外，其他都缩了。没有m.2接口，反正sata的固态也够用了。只有两个内存槽，但是单8g基本够用，双8g已经能解决99.99%的问题了，而且双内存槽的主板比较窄，可以装进某些ITX机箱。低端主板淘宝买微星还是比较靠谱的，保修仅仅次于华硕强于技嘉和华擎等（华擎技嘉保修相对麻烦，这两个牌子一般推荐京东买，等于加钱购买京东的保修，京东质保绝对靠谱），但是价格却比华硕低很多，4+2供电也能保证将来i7-7700降价后可以换上i7-7700.</p>
<p>主板可以考虑换成微星B250M MORTAR，500元，做工非常豪华的B250M主板，价格也很低，相比上文的H110最大优点是可以支持M.2固态，其次是主板散热和供电都很好，带7700K轻松随意。（这并不意味着H110M就不能带7700K）</p>
<p>内存硬盘电源固态没什么好说的，都是选用大品牌做工扎实的型号。电源稍微买贵了点，总比BOOM好，这款电源三百元内算是做工数一数二，而且相当安静。</p>
<p>散热GH400，土狼的散热，小众超频，优点就是便宜且非常安静，散热效果比STB120 T400i之类的差，但是也很便宜，以后升级i7 -7700的话，GH400也能一战。但是7700K还是推荐上T400i或者STB120.极度不推荐红海mini这种吵死人的散热。</p>
<p>先马米立方，尺寸360x267x333mm，其实不小，外观和做工还算过的器，但是对比我经常推荐的中塔机箱——先马坦克而言，米立方确实可以算是小巧可爱了。坦克的尺寸是：486×200×502mm。 米立方支持303mm显卡和180mm散热，几乎等于支持所有散热器和绝大多数显卡，但是主板必须是任意规格的MATX版型，不支持大主板。</p>
<p><strong>如果预算不够</strong></p>
<p>首先考虑主板和内存，主板换映泰H110MD PRO DDR3 ，325元，用料不如之前的微星H110，不过反正大家都是低端，就别争高下了。这板子主要是支持ddr3内存。所以内存换 宇瞻1600 ddr3 4g普调两根，150一根。省出135元。好吧，其实DDR3和DDR4基本没区别。</p>
<p>其次，电源考虑京东买首席玩家500W火玫瑰，170元，省135+130=265元</p>
<p>再次，显卡考虑昂达1050ti 4G神盾，900元。性能比1060 3G大概降低40%. 省出265+500=765元。<br>显卡要买双风扇一样大的，不要买那种风扇一大一小的，尽管他们都叫昂达神盾。</p>
<p>更小的机箱,乔思伯C2，169元，做工渣渣，但是外观看起来还不错，至少对得起价格。这款机箱比先马米立方还要小，而且只能支持双内存槽的MATX主板和更小的ITX主板，支持210mm显卡和80mm散热器，这意味着，只有双风扇显卡和下压式散热才能被容纳。勉强可以塞进索泰1060 3G毁灭者，真的很勉强，大力出奇迹…….此外，该机箱风道不好，不适合发热高的配置（上文那套配置发热极低）</p>
<p>所以，机箱选择C2的话，散热我推荐 id cooling S50，价格100元。下压式中比较好的散热，当然，它的效果是不如侧吹式的GH400，毕竟GH400要比S50大很多。</p>
<p>一个建议，装机请带手套，这机箱内部锐利无比，会划伤手。</p>
<h2 id="入门级体验配置-Intel：3700元左右"><a href="#入门级体验配置-Intel：3700元左右" class="headerlink" title="入门级体验配置-Intel：3700元左右"></a>入门级体验配置-Intel：3700元左右</h2><p>Intel现在不见得有什么好处，唯一的好处就是….额，品牌比较大</p>
<p>在3000元左右入门级配置基础上，性能增幅不明显，主要是全方面改进体验，并且预留了极大的升级空间，如果你不差钱，我建议买这套。</p>
<ul>
<li>CPU：G4560散片 405元 / G4600散片 445元</li>
</ul>
<p>尽管现在比最低价时涨了100元，然而性价比依然可以接受，跑分和实际使用证明这U完全可以匹敌I3 6100，这U一下子让I3 6100，i3 7100变得完全没有任何购买价值！<br>G4600比G4560性能强一丝丝，核显强一大截，当然还是被独显吊打，买G4600还是G4560都行。</p>
<p>因为有独显了，所以核显无意义。</p>
<ul>
<li>主板：微星B250M MORTAR 500元 JD购买</li>
</ul>
<p>暂时是B250M中最值得购买的一款，做工非常出色，接口齐全，将来升级7700K毫无问题。</p>
<ul>
<li>内存：英睿达8G ddr4 2400，600元。</li>
</ul>
<p>所有不超频的配置，都用这个条子！同价位里可能是最吼的做工，就问你们支持不支持。</p>
<ul>
<li>散热器：STB120 双风扇，125元</li>
</ul>
<p>百元最强散热，压r7-1700都没问题，牛刀现在用来杀鸡。</p>
<ul>
<li>显卡：微星1050ti 4G红龙 1100元</li>
</ul>
<p>外观，温控，静音，频率都很出色，如果价格能低点就更好了。470D已经买不到了，请不要再提了，好么？</p>
<ul>
<li>机箱：先马坦克 200元</li>
</ul>
<p>没什么好说的，推荐了N年的机箱，毫无出色之处，也没有什么缺点。</p>
<ul>
<li>电源：酷冷至尊GX450 JD</li>
</ul>
<p>彦祖标配电源，以后换7700K+1070都可以不换电源，牛逼不？</p>
<ul>
<li><p>机械硬盘：西数（或希捷）1T 300元</p>
</li>
<li><p>固态硬盘：PM961 128G 470元 </p>
</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。这固态是OEM流出，类似CPU散片，京东上肯定没有，要去淘宝买。有通电或者全新都无所谓的。</p>
<p><strong>总计：3700元（不含1T硬盘）</strong></p>
<h2 id="3700元入门级体验配置-AMD"><a href="#3700元入门级体验配置-AMD" class="headerlink" title="3700元入门级体验配置-AMD"></a>3700元入门级体验配置-AMD</h2><p>AMD现在稳如狗了，除非内存支持上还有一丁点不足。</p>
<ul>
<li><p>CPU主板套装：R3 1200+微星B350M PROVD PLUS套装 960元</p>
</li>
<li><p>主板：和CPU的套装，AMD的U买套装比较划得来。</p>
</li>
</ul>
<p>r3-1200多线能力狂虐G4560，体现在大型单机或者多任务处理上，单核能力r3-1200可以通过超频来弥补，达到和G4560一样甚至超过G4560的水平。<br>r3 1200+b350m可以说性能上完虐g4560+b250m了，但是需要你进行超频，超频并不难。如果仅仅是做简单的office，玩炉石传说之类的，超频意义不大，而且显然G4560这种简单无脑稳如狗的CPU更适合日常办公学习。</p>
<ul>
<li>内存：英睿达8G ddr4 2400，600元。</li>
</ul>
<p>所有不超频的配置，都用这个条子！同价位里可能是最吼的做工，就问你们支持不支持，实际上，B350M主板可以对英睿达白马甲超频，但是新手建议强行超内存。</p>
<ul>
<li>散热器：STB120 双风扇，125元</li>
</ul>
<p>百元最强散热，压r7-1700都没问题，牛刀现在用来杀鸡。</p>
<ul>
<li>显卡：微星1050ti 4G红龙 1100元</li>
</ul>
<p>外观，温控，静音，频率都很出色，如果价格能低点就更好了。470D已经买不到了，请不要再提了，好么？</p>
<ul>
<li>机箱：先马坦克 200元</li>
</ul>
<p>没什么好说的，推荐了N年的机箱，毫无出色之处，也没有什么缺点。</p>
<ul>
<li>电源：酷冷至尊GX450 JD</li>
</ul>
<p>彦祖标配电源，以后换7700K+1070都可以不换电源，牛逼不？</p>
<ul>
<li><p>机械硬盘：西数（或希捷）1T 300元</p>
</li>
<li><p>固态硬盘：PM961 128G 470元</p>
</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。</p>
<p><strong>总计： 3715元（不含1T硬盘）</strong></p>
<h1 id="中端主流游戏配置"><a href="#中端主流游戏配置" class="headerlink" title="中端主流游戏配置"></a>中端主流游戏配置</h1><p>5k+到8K+的一般就算是中端配置了。</p>
<h2 id="中端主流游戏配置——AMD：5300元"><a href="#中端主流游戏配置——AMD：5300元" class="headerlink" title="中端主流游戏配置——AMD：5300元"></a>中端主流游戏配置——AMD：5300元</h2><p>4000出头的预算怎么办？CPU和显卡放弃一个吧，换成G4560或者1050ti，以后准备升级。</p>
<p>一般来说对游戏而言显卡比CPU重要一点点。或者买映众家1060 3G乞丐，不过这卡也完全继承了昂达乞丐的缺点……</p>
<ul>
<li><p>CPU：R5-1400+B350M MORTAR/BAZOOKA套装 1400元</p>
</li>
<li><p>主板：和CPU的套装，AMD的U买套装比较划得来。</p>
</li>
</ul>
<p>r5-1400多线能力狂虐i5 7500，体现在大型单机或者多任务处理上，单核能力r5-1400可以通过超频来弥补，达到和i5 7500一样甚至超过i5 7500的水平。</p>
<p>同样是四个核心，r5 1400和r3 1200的区别是 1400多了超线程，（intel i5和i7的最大区别也是超线程），超线程相当于多了4个虚拟的核心，这使得1400的多核性能远超1200。</p>
<p>r5-1400基础频率非常低，极度需要超频，幸亏现在超频很容易。买AU一定要超频，放心，超不坏。</p>
<p>如果单纯是玩网游，不搞多开，那r5 1400和r3 1200并没有区别，可以省钱换成r3 1200的套装。刺客信条起源这种大型单机，能很好利用1400的多线程，但是老一点的游戏基本多线程无用。</p>
<ul>
<li>内存：英睿达8G ddr4 2400，600元。</li>
</ul>
<p>所有不超频的配置，都用这个条子！同价位里可能是最吼的做工，就问你们支持不支持。</p>
<ul>
<li>散热器：STB120 双风扇，125元</li>
</ul>
<p>百元最强散热，压r7-1700都没问题，牛刀现在用来杀鸡。</p>
<ul>
<li>显卡：映众gtx1060 冰龙海量（非冰龙ultra版） 2100元</li>
</ul>
<p>好像不需要多解释，常见的高端1060，极致静音。</p>
<ul>
<li>机箱：先马坦克 200元</li>
</ul>
<p>没什么好说的，推荐了N年的机箱，毫无出色之处，也没有什么缺点。</p>
<ul>
<li>电源：酷冷至尊GX450 JD 300元</li>
</ul>
<p>彦祖标配电源，以后换1700+1070都可以不换电源，牛逼不？</p>
<ul>
<li>机械硬盘：西数（或希捷）1T 300元</li>
<li>固态硬盘：PM961 128G 470元</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。</p>
<p><strong>总计：5200元</strong></p>
<h2 id="中端主流游戏配置——AMD：6500元"><a href="#中端主流游戏配置——AMD：6500元" class="headerlink" title="中端主流游戏配置——AMD：6500元"></a>中端主流游戏配置——AMD：6500元</h2><ul>
<li>CPU：RYZEN 1600+B350M MORTAR套装 1860元 </li>
<li>主板：和CPU的套装，AMD的U买套装比较划得来。</li>
</ul>
<p>r5-1600多线能力狂虐i7 7700，体现在大型单机或者多任务处理上，单核能力r5-1600可以通过超频来弥补，接近i7 7700的水平。6核心12线程高端CPU，你值得拥有！</p>
<p>r5-1600基础频率非常低，极度需要超频，幸亏现在超频很容易。买AU一定要超频，放心，超不坏。</p>
<ul>
<li>内存：英睿达8G ddr4 2400，600元 X2</li>
</ul>
<p>所有不超频的配置，都用这个条子！同价位里可能是最吼的做工，就问你们支持不支持。</p>
<ul>
<li>散热器：STB120 双风扇，125元</li>
</ul>
<p>百元最强散热，压r7-1700都没问题，牛刀现在用来杀鸡。</p>
<ul>
<li>显卡：映众gtx1060 冰龙海量（非冰龙ultra版） 2100元</li>
</ul>
<p>好像不需要多解释，常见的高端1060，极致静音。</p>
<ul>
<li>机箱：先马坦克 200元</li>
</ul>
<p>没什么好说的，推荐了N年的机箱，毫无出色之处，也没有什么缺点。</p>
<ul>
<li>电源：振华冰山金蝶550W战斗版 379元</li>
</ul>
<p>彦祖标配电源，以后换1700+1070ti都可以不换电源，牛逼不？</p>
<ul>
<li><p>机械硬盘：西数（或希捷）1T 300元</p>
</li>
<li><p>固态硬盘：PM961 256G 650元</p>
</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。</p>
<p><strong>总计：6520元</strong></p>
<h2 id="中端主流游戏配置——Intel：6700元"><a href="#中端主流游戏配置——Intel：6700元" class="headerlink" title="中端主流游戏配置——Intel：6700元"></a>中端主流游戏配置——Intel：6700元</h2><p>感谢i5-8400，Intel有活路了！</p>
<ul>
<li><p>CPU：I5 8400散片+华擎Z370 pro4套装 2100元</p>
</li>
<li><p>主板：pro4是乞丐款Z370，如果同价位能买到技嘉微星，那也行。</p>
</li>
</ul>
<p>6核心6线程高端CPU，你值得拥有！</p>
<p>8400无法超频，但是睿频4.0g已经吊打r5-1600了。</p>
<p>在很多游戏上，8400比r5 1600更出色，不过渲染剪辑等多线程任务，r5-1600依然牛逼。</p>
<ul>
<li>内存：英睿达8G ddr4 2400，600元 X2</li>
</ul>
<p>所有不超频的配置，都用这个条子！同价位里可能是最吼的做工，就问你们支持不支持。</p>
<ul>
<li>散热器：STB120 双风扇，125元</li>
</ul>
<p>百元最强散热，压r7-1700都没问题，牛刀现在用来杀鸡。</p>
<ul>
<li>显卡：映众gtx1060 冰龙海量（非冰龙ultra版） 2100元</li>
</ul>
<p>好像不需要多解释，常见的高端1060，极致静音。</p>
<ul>
<li>机箱：先马坦克 200元</li>
</ul>
<p>没什么好说的，推荐了N年的机箱，毫无出色之处，也没有什么缺点。</p>
<ul>
<li>电源：酷冷至尊GX450 JD 300元</li>
</ul>
<p>彦祖标配电源，以后换7700k+1070都可以不换电源，牛逼不？</p>
<ul>
<li><p>机械硬盘：西数（或希捷）1T 300元</p>
</li>
<li><p>固态硬盘：PM961 256G 650元</p>
</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。</p>
<p><strong>总计：6735元（不含1T硬盘）</strong></p>
<h2 id="重度游戏配置：7000左右"><a href="#重度游戏配置：7000左右" class="headerlink" title="重度游戏配置：7000左右"></a>重度游戏配置：7000左右</h2><blockquote>
<p>这套配置可以完成重度的渲染/建模/音频视频制作工作，胜任重度游戏需求。</p>
</blockquote>
<blockquote>
<p>对于有设计需求（渲染建模剪辑之类）的朋友推荐这套配置并且根据实际预算在此基础上做出修改。</p>
</blockquote>
<ul>
<li>CPU主板：ryzen r7 1700* + 微星B350M MORTAR 2300元</li>
<li>散热：镰刀STB120 双风扇版 125元*</li>
<li>显卡：gtx1060 6G冰龙海量版 2000元</li>
<li>电源：酷冷V550 499元</li>
<li>内存：海盗船复仇者3200C16 8GX2 1100元（目前1500元了…..）</li>
<li>硬盘：按需选择*</li>
<li>固态：PM961 256G 650元</li>
<li>机箱：先马米立方 200元</li>
</ul>
<p><strong>主机总计：6874元</strong></p>
<p>显示器如果没有特殊需求，选之前的惠普(hp)23es 23英寸 800元，如果需要专业绘图显示器，推荐戴尔U2515 2100元。</p>
<p>Ryzen 1700八核心十六线程，非常非常适合渲染等工作。</p>
<p>*需要注意的是，此U超频后可以达到200W的夸张功耗，不超频的话功耗不足100W，如果寝室限电，请老老实实不要超频。如果不限电，可以尝试小超3.7G 3.8G，性能相比默认的3.0G睿频3.7G，能提高20%以上，这个提升幅度是非常巨大的，当然，功耗翻倍了…….</p>
<p>超频可以参考：<a href="http://detail.zol.com.cn/product_param/index3447.html">    CPU : 什么是超频，怎么给CPU超频？</a></p>
<p>无论是否超频，散热都推荐STB120，相比原装散热，它非常安静而且能把CPU温度控制到更低。原装散热压不超频的1700是没问题的，除了长期满载的时候略有噪音以外，但是玩超频就绝对绝对不要用原装，省这个钱找罪受，没意思。</p>
<p>高频双通道内存是ryzen系列最好的搭配，相比单通道16G 2400提升巨大。这内存在此主板上可以上2933频率，但是3200大概率上不去。</p>
<p>不太需要X370，目前的ryzen CPU超频能力都略显捉急，微星B350M MORTAR已经足够，它对内存的支持也比较好。如果预算充裕，主板可以换成微星X370 krait，虽然贵了几百，但是温度和电压都会低一些，接口也更加丰富，或许这意味着稳定性会略微提高，如果接口不换的话，下一代U应该会更需要X370，也就是说，目前X370 B350差距不是很大，尤其是在仅仅略微超频的情况下，买X370一部分是为未来投资。但是，总之，不差钱还是X370吧！</p>
<p>冰龙海量，最安静的1060，现在的冰龙海量比最初版本缩了一点供电，但是散热没缩，依然可以买。</p>
<p>硬盘按需购买，现在都是云盘时代了，机械硬盘又吵又笨重，你真的要买吗？</p>
<p><strong>如果预算不够</strong></p>
<p>首先，首先考虑换显卡和电源，换耕升追风1060 6G，价格1770元，性能不变，温度和噪音略高（噪音不比机箱风扇大，依然可以忍受，温度也可以接受）。电源换酷冷至尊GX450，不解释。最多可以省530元</p>
<p>其次，考虑去掉STB120，用原装散热顶着。（更换散热需要拆卸主板，并不是很简单，建议散热要换就换玄冰400，装这个不用拆主板。） 可以省530+125=655元</p>
<p>还是觉得贵了？显卡换 1060 3G索泰毁灭者，1400元，省655+270=925元</p>
<p>还是没钱？CPU主板套装换1600+微星B350M MORTAR，1880元，省 925+420=1345元</p>
<p>还是没钱？显卡换昂达1050ti 4G神盾，900元，省 1345+500=1845元</p>
<p>还是没钱？买第一套配置吧，以后再换CPU。</p>
<h1 id="发烧级高端配置"><a href="#发烧级高端配置" class="headerlink" title="发烧级高端配置"></a>发烧级高端配置</h1><p>8K以上，随意感受来自土豪的蔑视吧……</p>
<h2 id="高端入门级游戏配置——Intel：9000元"><a href="#高端入门级游戏配置——Intel：9000元" class="headerlink" title="高端入门级游戏配置——Intel：9000元"></a>高端入门级游戏配置——Intel：9000元</h2><ul>
<li>CPU主板：i5 8600k散片+ 微星z370 gaming pro carbon主板套装 3200元</li>
</ul>
<p>超频神U，吊打i7 7700k</p>
<p>如果实在不想超频，U可以换成上面的 8400套装，省1100元</p>
<ul>
<li><p>主板：pro4是乞丐款Z370，如果同价位能买到技嘉微星，那也行。</p>
</li>
<li><p>内存：英睿达8G ddr4 2667，610元 X2</p>
</li>
<li><p>散热器：大霜塔标准版 200元</p>
</li>
</ul>
<p>不超频可以换STB120双风扇。</p>
<ul>
<li>显卡：耕升1070ti追风 3100元</li>
</ul>
<p>乞丐卡，不过作为1070ti，性能上肯定比1070顶配卡要好，显卡一定要砍价。</p>
<p>或者微星1070ti 红龙 3600元</p>
<p>高配卡，外观，静音和温度的体验非常好，性能和乞丐卡差距不大。</p>
<ul>
<li>机箱：先马坦克 200元</li>
</ul>
<p>没什么好说的，推荐了N年的机箱，毫无出色之处，也没有什么缺点。</p>
<ul>
<li>电源：振华550冰山金蝶战斗版 379元 JD</li>
</ul>
<p>中端电源里的良心。</p>
<ul>
<li><p>机械硬盘：西数（或希捷）1T 300元</p>
</li>
<li><p>固态硬盘：PM961 256G 650元</p>
</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。</p>
<p><strong>总计：8950</strong></p>
<h2 id="高端入门级游戏配置——AMD：9000元"><a href="#高端入门级游戏配置——AMD：9000元" class="headerlink" title="高端入门级游戏配置——AMD：9000元"></a>高端入门级游戏配置——AMD：9000元</h2><ul>
<li><p>CPU：RYZEN 1700X + 微星B350M MORTAR套装 2600元 </p>
</li>
<li><p>主板：1700X</p>
</li>
</ul>
<p>多线能力，渲染性能秒天秒地，连14核心28线程的E5 2683V3都不一定比1700X强。考虑到1700超频能力普遍比1700X差0.2-0.3G，为了游戏还是买1700X吧！</p>
<ul>
<li>内存： 芝奇幻光戟3200C16 8GX2 1500元</li>
</ul>
<p>幻光戟频率更高，对AMD提升很大，而且好看。</p>
<ul>
<li>散热器：大霜塔标准版 200 </li>
</ul>
<p>另外要问清楚是否支持AM4，不支持的话找卖家买扣具。</p>
<ul>
<li>显卡：耕升1070ti追风 3100元</li>
</ul>
<p>乞丐卡，不过作为1070ti，性能上肯定比1070顶配卡要好，显卡一定要砍价。</p>
<p>或者微星1070ti 红龙 3600元<br>高配卡，外观，静音和温度的体验非常好，性能和乞丐卡差距不大。</p>
<ul>
<li>机箱：先马坦克 200元</li>
</ul>
<p>没什么好说的，推荐了N年的机箱，毫无出色之处，也没有什么缺点。</p>
<ul>
<li><p>电源：振华550冰山金蝶战斗版 379元 JD<br>中端电源里的良心。</p>
</li>
<li><p>机械硬盘：西数（或希捷）1T 300元</p>
</li>
<li><p>固态硬盘：PM961 256G 650元</p>
</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。</p>
<p><strong>总计：8355元</strong></p>
<h2 id="高端土豪配置：10200元"><a href="#高端土豪配置：10200元" class="headerlink" title="高端土豪配置：10200元"></a>高端土豪配置：10200元</h2><p>等第八代CPU，今年十月初就能买到。</p>
<p>新款i3性能和现在的i5一样，新款i5比现在的i7强！</p>
<p>就算要买现在的第七代U，等第八代出来后，第七代会大幅度降价的。</p>
<p>另外，如果现在要买，请将第二套配置的U换成Ryzen 1600，显卡根据预算选择耕升1070 8G追风或1060 6G追风，当然，选择冰龙也行。其它不变，直接照抄第二套，也是非常好的选择。这个组合非常适合吃鸡以及其他多线程优化好的单机游戏。</p>
<p>不考虑功率的话：</p>
<ul>
<li><p>CPU：8600K散片 1900元/ 8700K散片 3000元</p>
</li>
<li><p>主板：微星Z370 GAMING PRO CARBON 1699元</p>
</li>
<li><p>散热器：大霜塔RGB 300元</p>
</li>
<li><p>显卡：GTX1070 8G G魂 3000元</p>
</li>
<li><p>电源：振华LEADEX G650 700元</p>
</li>
<li><p>内存：海盗船复仇者3200C16 8GX2 1500元</p>
</li>
<li><p>硬盘：按需选择1T 2T 3T希捷 固态：PM961 256g 650元</p>
</li>
<li><p>机箱：恩杰S340 350元</p>
</li>
</ul>
<p><strong>总计：10200元</strong></p>
<p>电源京东，其他淘宝。系统必须装win10镜像，直接百度就行。不可以用win7。</p>
<p>八代U，超频。土豪请选择8700K。其他可以不变。满载功耗看CPU超频幅度。</p>
<p><strong>考虑功率</strong></p>
<ul>
<li><p>CPU： i7 7700K 2000元散片</p>
</li>
<li><p>显卡：GTX1070 8G G魂 3000元</p>
</li>
<li><p>主板： B250M MORTAR 500元</p>
</li>
<li><p>电源：酷冷GX450 300元</p>
</li>
<li><p>内存：英睿达白马甲8gX2 1300元</p>
</li>
<li><p>硬盘：西数1T 300元</p>
</li>
<li><p>固态：PM961 256G 650元</p>
</li>
<li><p>散热：t400i 100元</p>
</li>
<li><p>机箱：先马坦克 209元/米立方 200元</p>
</li>
</ul>
<p><strong>总计：8350元</strong></p>
<p>电源京东，其他淘宝。系统必须装win10镜像，直接百度就行。不可以用win7。这套目测满载不足300W。</p>
<h2 id="高端Intel配置：15000元"><a href="#高端Intel配置：15000元" class="headerlink" title="高端Intel配置：15000元"></a>高端Intel配置：15000元</h2><p>更好电源，更好的散热，更好的主板，更好的内存，就酱紫。</p>
<ul>
<li><p>CPU：I7 8700K+微星Z370 gaming pro carbon 4199元</p>
</li>
<li><p>主板：pro4 </p>
</li>
</ul>
<p>不建议买太贵的Z370，因为明年要出Z390了。</p>
<ul>
<li>内存：芝奇幻光戟3200C14 8GX2 1700元</li>
</ul>
<p>幻光戟频率更高，对AMD提升很大，而且好看，C14版本比C16版本更有超频空间。</p>
<ul>
<li>散热器：九州风神阿萨辛 400元</li>
</ul>
<p>次顶级风冷散热，吊打一众中端水冷。</p>
<ul>
<li>显卡：技嘉1080TI 大雕 6400元 （小雕是垃圾卡）或者索泰1080TI AMP 6000元</li>
</ul>
<p>索泰AMP可能是最强的1080ti了，但是国行没有AMP，淘宝上卖的都是美行，美行唯一的缺点就是保修麻烦。 </p>
<ul>
<li>机箱：恩杰N450 600元</li>
</ul>
<p>彦祖同款中高端机箱。</p>
<ul>
<li>电源：leadex G650 660元</li>
</ul>
<p>高端电源，主要是外观一百分。 </p>
<ul>
<li>固态硬盘：PM981 512G 1300元</li>
</ul>
<p>读写速度比多数sata接口的固态快好了几倍，当然游戏帧数不会因为提高。</p>
<p><strong>总计：15000元</strong></p>
<h2 id="高端AMD配置"><a href="#高端AMD配置" class="headerlink" title="高端AMD配置"></a>高端AMD配置</h2><p>别闹了老铁们，1800X+坠吼的X370也超不高，何必呢？</p>
<p>可能也就比1700+B350多个0.3G，几千块钱买0.3G，反正我是不理解的。</p>
<p>不推荐。<br>、、、、、、、、、、、、、、、、、</p>
]]></content>
      <categories>
        <category>电脑组装</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF干货系列——工具资源——Burp_Suite_Pro教程</title>
    <url>/articles/Tool-Burp-Suite-Pro.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Burp Suite 是用于攻击 Web 应用程序的集成平台。它包含了很多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示 HTTP 消息、持久性、认证、代理、日志、警报的一个强大的可扩展的框架。</p>
<span id="more"></span>

<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p><a href="http://pan.baidu.com/s/1gfnd5RH">Burp Suite Pro 1.7.17</a>，提取密码：0554</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>只需要在安装 JDK 的环境中运行 jar 包即可。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>推荐用 FireFox 浏览器，因为丰富的插件更方便在开发者模式下进行各种神奇的操作。</p>
<ul>
<li>首先安装一个插件，叫做 AutoProxy，相关配置如下：</li>
</ul>
<p>打开插件首选项，在代理服务器选择编辑代理服务器，名字随意，添加代理：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Burp</span> Suite	<span class="number">127.0.0.1</span>	<span class="number">8080</span>	http</span><br></pre></td></tr></table></figure>
<p>然后选择代理服务器，选择默认代理服务器为Burp Suite。</p>
<p>之后在浏览器工具栏，推荐选择全局代理模式。</p>
<ul>
<li>FireFox 浏览器选项中，连接设置中，选择手动配置代理，相关配置如下：</li>
</ul>
<p>HTTP 代理：127.0.0.1    端口：8080</p>
<p>在“为所有协议使用相同代理服务器”前打对勾。</p>
<h2 id="模块简介及相关设置"><a href="#模块简介及相关设置" class="headerlink" title="模块简介及相关设置"></a>模块简介及相关设置</h2><h3 id="Target——目标"><a href="#Target——目标" class="headerlink" title="Target——目标"></a>Target——目标</h3><p>现实目标目录结构的一个功能。</p>
<h4 id="Site-map"><a href="#Site-map" class="headerlink" title="Site map"></a>Site map</h4><h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><h3 id="Proxy——代理"><a href="#Proxy——代理" class="headerlink" title="Proxy——代理"></a>Proxy——代理</h3><p>拦截 HTTP/S 的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许拦截、查看、修改在两个方向上的原始数据流。</p>
<h4 id="Intercept"><a href="#Intercept" class="headerlink" title="Intercept"></a>Intercept</h4><h4 id="HTTP-history"><a href="#HTTP-history" class="headerlink" title="HTTP history"></a>HTTP history</h4><h4 id="WebSockets-history"><a href="#WebSockets-history" class="headerlink" title="WebSockets history"></a>WebSockets history</h4><h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4><p>首先打开设置界面，设置代理监听。</p>
<p>缺省值为 127.0.0.1:8080。</p>
<p>需要注意的是，FireFox 浏览器有个大坑就是，这货需要证书认证，不然一直浏览器报错报错，在这里一开始浪费了我将近一小时来进行各种配置，烦得一匹，后来发现了这个问题，一分钟搞定。</p>
<p>进入浏览器 url 栏输入：127.0.0.1:8080，进入 Burp Suite 主页，点击右上角 CA Certificate 下载证书，然后在浏览器的安全选项中的证书，导入刚刚下载的证书即可。</p>
<h3 id="Spider——爬虫"><a href="#Spider——爬虫" class="headerlink" title="Spider——爬虫"></a>Spider——爬虫</h3><p>应用智能感应的网络爬虫，它能完整地枚举应用程序的内容和功能。</p>
<h4 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h4><h4 id="Options-1"><a href="#Options-1" class="headerlink" title="Options"></a>Options</h4><h3 id="Scanner——扫描器"><a href="#Scanner——扫描器" class="headerlink" title="Scanner——扫描器"></a>Scanner——扫描器</h3><p>高级工具，执行后，它能自动的发现 Web 应用程序的内容和功能。</p>
<h4 id="Issue-activity"><a href="#Issue-activity" class="headerlink" title="Issue activity"></a>Issue activity</h4><h4 id="Scan-queue"><a href="#Scan-queue" class="headerlink" title="Scan queue"></a>Scan queue</h4><h4 id="Live-scanning"><a href="#Live-scanning" class="headerlink" title="Live scanning"></a>Live scanning</h4><h4 id="Issue-definitions"><a href="#Issue-definitions" class="headerlink" title="Issue definitions"></a>Issue definitions</h4><h4 id="Options-2"><a href="#Options-2" class="headerlink" title="Options"></a>Options</h4><h3 id="Intruder——入侵"><a href="#Intruder——入侵" class="headerlink" title="Intruder——入侵"></a>Intruder——入侵</h3><p>一个定制的高度可配置的工具，对Web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用 fuzzing 技术探测常规漏洞。</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><h4 id="Positions"><a href="#Positions" class="headerlink" title="Positions"></a>Positions</h4><h4 id="Payloads"><a href="#Payloads" class="headerlink" title="Payloads"></a>Payloads</h4><h4 id="Options-3"><a href="#Options-3" class="headerlink" title="Options"></a>Options</h4><h3 id="Repeater——中继器"><a href="#Repeater——中继器" class="headerlink" title="Repeater——中继器"></a>Repeater——中继器</h3><p>一个靠手动操作来触发单独的 HTTP 请求，并分析应用程序相应的工具。</p>
<h3 id="Sequencer——会话"><a href="#Sequencer——会话" class="headerlink" title="Sequencer——会话"></a>Sequencer——会话</h3><p>用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性工具。</p>
<h4 id="Live-capture"><a href="#Live-capture" class="headerlink" title="Live capture"></a>Live capture</h4><h4 id="Manual-load"><a href="#Manual-load" class="headerlink" title="Manual load"></a>Manual load</h4><h4 id="Analysis-options"><a href="#Analysis-options" class="headerlink" title="Analysis options"></a>Analysis options</h4><h3 id="Decoder——解码器"><a href="#Decoder——解码器" class="headerlink" title="Decoder——解码器"></a>Decoder——解码器</h3><p>进行手动执行或对应用程序数据者智能编码的工具。</p>
<h3 id="Comparer——对比"><a href="#Comparer——对比" class="headerlink" title="Comparer——对比"></a>Comparer——对比</h3><p>通常是通过一些相关的请求和相应得到两项数据的一个可视化的“差异”。</p>
<h3 id="Extender——扩展"><a href="#Extender——扩展" class="headerlink" title="Extender——扩展"></a>Extender——扩展</h3><p>可以让用户加载 Burp Suite 的扩展，使用自己的或第三方代码来扩展 Burp Suite 的功能。</p>
<h4 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h4><h4 id="BApp-Store"><a href="#BApp-Store" class="headerlink" title="BApp Store"></a>BApp Store</h4><h4 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h4><h4 id="Options-4"><a href="#Options-4" class="headerlink" title="Options"></a>Options</h4><h3 id="Project-options——设置"><a href="#Project-options——设置" class="headerlink" title="Project options——设置"></a>Project options——设置</h3><p>对 Burp Suite 的一些设置。</p>
<h4 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h4><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><h4 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h4><h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><h3 id="User-options"><a href="#User-options" class="headerlink" title="User options"></a>User options</h3><p>对用户使用的一些设置。</p>
<h4 id="Connections-1"><a href="#Connections-1" class="headerlink" title="Connections"></a>Connections</h4><h4 id="SSL-1"><a href="#SSL-1" class="headerlink" title="SSL"></a>SSL</h4><h4 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h4><h4 id="Misc-1"><a href="#Misc-1" class="headerlink" title="Misc"></a>Misc</h4><h3 id="Alters"><a href="#Alters" class="headerlink" title="Alters"></a>Alters</h3><p>类似于日志的模块。</p>
<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="Target-1"><a href="#Target-1" class="headerlink" title="Target"></a>Target</h3><p>在 Proxy-Intercept 中设置”Intercept is on”，去浏览器打开页面，会发现页面一直在载入，因为我们拦截了发往服务器的请求；</p>
<p>点击 Forward 可以继续发往服务器，Drop 是放弃，Action 是更多操作。</p>
<p>在下面的信息栏，能看到数据包的内容；在这里，我们可以修改数据包，或者提取有用的信息，之后选择不同的操作。</p>
<p>进入 Proxy-HTTP history 就能看到之前的所有请求和相应的数据包。</p>
<p>Target 标签下的 Site map，会列出拦截的站点结构及信息。</p>
<p>Scope 添加过滤规则。回到 Site map 就能利用 Filter 对于想要的信息进行过滤，不显得杂乱无章。</p>
<h3 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h3><p>Burp Spider 是一个映射 Web 应用程序的工具。它使用多种智能技术对一个应用程序的内容和功能进行去那面的清查。</p>
<h4 id="启用和配置-Spider"><a href="#启用和配置-Spider" class="headerlink" title="启用和配置 Spider"></a>启用和配置 Spider</h4><p>在浏览器中访问一个网站，在 Target 的 Site map 中将目标添加到 Scope。右键目标，选择 Spider this host，就会自动爬下网站的所有内容。</p>
<p>在 Spider 的 Options 中，可以对 Spider 进行各种配置。</p>
<h4 id="Passive-spidering（被动扫描）"><a href="#Passive-spidering（被动扫描）" class="headerlink" title="Passive spidering（被动扫描）"></a>Passive spidering（被动扫描）</h4><h4 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h4><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><h4 id="启动扫描"><a href="#启动扫描" class="headerlink" title="启动扫描"></a>启动扫描</h4><p>根据 Site map 中站点的 url、参数、cookie、表单等进行扫描，安全方面的检测。</p>
<h4 id="Active-scanning"><a href="#Active-scanning" class="headerlink" title="Active scanning"></a>Active scanning</h4><p>主动扫描根据每个路径，按照配置的规则，进行主动探测。相较而言，主动扫描要花费更多时间，但是也更加深入。 </p>
<h4 id="Passive-scanning"><a href="#Passive-scanning" class="headerlink" title="Passive scanning"></a>Passive scanning</h4>]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF干货系列——工具资源</title>
    <url>/articles/Tool-Resources.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里就是我很喜欢的部分了哈哈。</p>
<p>但是气不气，就是没时间写。继续挖大坑。</p>
<p>以后会放出工具和资源，作为整合帖。也会另开文单独介绍。</p>
<span id="more"></span>

<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h2 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h2><h2 id="MacBook-Pro"><a href="#MacBook-Pro" class="headerlink" title="MacBook Pro"></a>MacBook Pro</h2><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h2 id="在线编码"><a href="#在线编码" class="headerlink" title="在线编码"></a>在线编码</h2><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="BurpSuite"><a href="#BurpSuite" class="headerlink" title="BurpSuite"></a>BurpSuite</h3><p>Burp Suite是用于攻击Web应用程序的集成平台。它包含了很多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP消息、持久性、认证、代理、日志、警报的一个强大的可扩展的框架。</p>
<p><a href="http://pan.baidu.com/s/1gfnd5RH">Burp Suite Pro</a>，提取密码:0554</p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1dEC9YXb">资源</a>  密码:l4he</p>
<p>具体教程另开贴。</p>
<h3 id="CKnife"><a href="#CKnife" class="headerlink" title="CKnife"></a>CKnife</h3><p>中国菜刀</p>
<p><a href="http://www.freebuf.com/sectool/99461.html">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1kU5CglD">资源</a>  密码:pp61</p>
<h2 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h2><h3 id="Pangolin"><a href="#Pangolin" class="headerlink" title="Pangolin"></a>Pangolin</h3><p>SQL注入，扫描等</p>
<p><a href="http://www.nosec-inc.com/">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1mioVuJY">资源</a>  密码:skb4</p>
<h3 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h3><p>SQL注入工具</p>
<h2 id="隐写工具"><a href="#隐写工具" class="headerlink" title="隐写工具"></a>隐写工具</h2><h3 id="HxD"><a href="#HxD" class="headerlink" title="HxD"></a>HxD</h3><p>一款好用免费的内核查看器</p>
<p><a href="https://mh-nexus.de/en/hxd/">链接</a></p>
<h3 id="Stegsolve"><a href="#Stegsolve" class="headerlink" title="Stegsolve"></a>Stegsolve</h3><p>破解色道隐写，需要JAVA环境</p>
<h3 id="Audacity"><a href="#Audacity" class="headerlink" title="Audacity"></a>Audacity</h3><p>运行于Windows的常用音频隐写工具</p>
<p><a href="http://www.audacityteam.org/">链接</a></p>
<h3 id="Outguess"><a href="#Outguess" class="headerlink" title="Outguess"></a>Outguess</h3><p>开源隐写工具，C语言编写</p>
<h2 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h2><h2 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h2><h3 id="IDA-pro"><a href="#IDA-pro" class="headerlink" title="IDA pro"></a>IDA pro</h3><p>知名逆向工具。</p>
<p><a href="https://www.hex-rays.com/products/ida/">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1bHzNbS">资源</a>  密码:tku8</p>
<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><h3 id="御剑后台扫描"><a href="#御剑后台扫描" class="headerlink" title="御剑后台扫描"></a>御剑后台扫描</h3><p>目录扫描</p>
<p><a href="https://www.t00ls.net/">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1i4G5Eyp">资源</a>  密码:h4d6</p>
<h3 id="DirBuster"><a href="#DirBuster" class="headerlink" title="DirBuster"></a>DirBuster</h3><p>漏洞扫描、目录扫描，Java语言编写</p>
<p><a href="https://sourceforge.net/projects/dirbuster/">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1hr7ep5i">资源</a>  密码:mn9h</p>
<h3 id="AppScan"><a href="#AppScan" class="headerlink" title="AppScan"></a>AppScan</h3><p>强大的WEB漏洞扫描工具</p>
<p><a href="https://sourceforge.net/projects/dirbuster/">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1mimT1Sc">资源</a>  密码:e8tf</p>
<h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><h3 id="AZPR"><a href="#AZPR" class="headerlink" title="AZPR"></a>AZPR</h3><p>对zip暴力破解速度极快，支持明文攻击。</p>
<p><a href="https://cn.elcomsoft.com/archpr.html">链接</a></p>
<p><a href="http://pan.baidu.com/s/1o8uWXPC">资源</a>  密码:4fhk</p>
<h3 id="ARPR"><a href="#ARPR" class="headerlink" title="ARPR"></a>ARPR</h3><p>常用RAR爆破工具。</p>
<p><a href="https://cn.elcomsoft.com/archpr.html">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1jH9cepC">资源</a>  密码:ntw5</p>
<h3 id="Ziperello"><a href="#Ziperello" class="headerlink" title="Ziperello"></a>Ziperello</h3><p>常用zip爆破工具，界面美观，可爆破隐写压缩包。</p>
<p><a href="http://be.findeen.com/ziperello%E5%AE%98%E7%BD%91.html">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1c1FtTdu">资源</a>  密码:1ebq</p>
<h3 id="密码字典生成器"><a href="#密码字典生成器" class="headerlink" title="密码字典生成器"></a>密码字典生成器</h3><p>体积小巧，功能强大。</p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1kVR7dw7">资源</a>  密码:alfu</p>
<h3 id="Orcalpass"><a href="#Orcalpass" class="headerlink" title="Orcalpass"></a>Orcalpass</h3><p>开源Orcal密码爆破，附源码，DOS下运行。</p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1hsQrquS">资源</a>  密码:l5bm</p>
<h3 id="phpMyAdmin"><a href="#phpMyAdmin" class="headerlink" title="phpMyAdmin"></a>phpMyAdmin</h3><p>phpMyAdmin密码爆破。</p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1hrYO4j6">资源</a>  密码:f0so</p>
<h3 id="hydra-7-3-windows"><a href="#hydra-7-3-windows" class="headerlink" title="hydra-7.3-windows"></a>hydra-7.3-windows</h3><p>密码爆破，DOS下运行。</p>
<p><a href="http://www.freebuf.com/sectool/36461.html">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1nveJVk9">资源</a>  密码:gz8y</p>
<h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><h3 id="UltraISO"><a href="#UltraISO" class="headerlink" title="UltraISO"></a>UltraISO</h3><p>虚拟光驱、ISO烧录到U盘或光盘，小巧免费无广告。</p>
<p><a href="https://cn.ultraiso.net/">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1dFLDI2d">资源</a>  密码:v2em</p>
<h3 id="putty"><a href="#putty" class="headerlink" title="putty"></a>putty</h3><p>用于Linux系统远程连接，小巧免费无广告。</p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1dF4II9z">资源</a>  密码:j9u9</p>
<h3 id="sunny-ngrok"><a href="#sunny-ngrok" class="headerlink" title="sunny-ngrok"></a>sunny-ngrok</h3><p>免费内网穿透。</p>
<p><a href="https://ngrok.cc/">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1gf7wzj9">资源</a>  密码:tghf</p>
<h2 id="工具合集"><a href="#工具合集" class="headerlink" title="工具合集"></a>工具合集</h2><h3 id="CTF工具合集"><a href="#CTF工具合集" class="headerlink" title="CTF工具合集"></a>CTF工具合集</h3><p>精灵表格总结的CTF工具合集。</p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1cwbuvO">资源</a>  密码:wu31</p>
<h3 id="分类详尽的工具合集"><a href="#分类详尽的工具合集" class="headerlink" title="分类详尽的工具合集"></a>分类详尽的工具合集</h3><p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1jIL36KY">资源</a>  密码:s1ta</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h2><h2 id="靶机"><a href="#靶机" class="headerlink" title="靶机"></a>靶机</h2><h2 id="CTF-Crack-Tools"><a href="#CTF-Crack-Tools" class="headerlink" title="CTF Crack Tools"></a>CTF Crack Tools</h2><p>CTF Crack框架（集成栅栏、凯撒等），国内首个CTF Crack框架，Java编写，源码在Github</p>
<p><a href="https://github.com/0Chencc/CTFCrackTools">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1mh6Wepy">资源</a>  密码:y1jk</p>
<h2 id="Pentest-Box"><a href="#Pentest-Box" class="headerlink" title="Pentest Box"></a>Pentest Box</h2><p>一款Windows平台下预配置的便携式开源渗透测试环境。</p>
<p>Pentest Box不同于运行在虚拟机或者双启动环境的Linux渗透测试发行版。它打包了所有的安全工具，并且可以再Windows系统中原生地运行，有效降低了对虚拟机或者双启动环境的需求。</p>
<p>这里选择的是集成了Metasploit的版本，安装时要关闭杀毒软件和防火墙，默认释放在C:/PentestBox/。</p>
<p><a href="https://pentestbox.org/zh/#download">链接</a></p>
<p><a href="%E9%93%BE%E6%8E%A5:http://pan.baidu.com/s/1nvMdwtN">资源</a>  密码:4lxe</p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>如何打造宇宙最强 Macbook</title>
    <url>/articles/Tool-best-Mac.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为开发者，如何打造宇宙最强 Mac 呢？</p>
<span id="more"></span>

<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><p>homebrew 之于 Mac，相当于 apt-get 之于 Ubuntu，rpm 之于 Centos。Unix 对比 Windows 优势很大的一点就是软件安装管理比较方便，有一套系统的工具，自然 homebrew 也是 Mac 上必装的应用之一。</p>
<p>使用以下语句安装：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>配置路径：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;/usr/local/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>之后可以下载安装 Mac 不自带而本身十分强大的各种工具，如 wget 等：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">brew install wget</span><br></pre></td></tr></table></figure>

<h2 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a>Homebrew Cask</h2><h1 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h1><p>先普及一下什么叫 shell：<br>在 Unix 内核的操作系统中，当然现在衍生出好多分支，Linux，Mac OS X 都算。<br>shell 就算和上面这些系统内核指令打交道的一座桥梁，我们通过键盘输入一种自己容易记忆识别的符号标识(shell 命令)，然后 shell 解析这种命令再反馈给内核去执行一系列操作。</p>
<p>其实 zsh 也是一种 shell ，但是并不是我们系统默认的 shell ，Unix 衍生系统的默认 shell 都是 bash。</p>
<p>我们查看一下 Mac 里面内置了哪些shell：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>

<p>Mac 自带的 Terminal 是 bash，现将其换成 zsh，采取 iTerm2 + Oh-My-Zsh + Solarized 配色方案，使其拥有语法高亮、命令行补全、自动提示符、显示 Git 仓库状态等功能。</p>
<h2 id="iTerm2-zsh"><a href="#iTerm2-zsh" class="headerlink" title="iTerm2 + zsh"></a>iTerm2 + zsh</h2><ul>
<li>首先安装 iTerm2，官网即可下载：<a href="http://iterm2.com/">http://iterm2.com/</a>。</li>
<li>将 iTem2 设置为默认终端：<br>iTerm2 -&gt; Make iTerm2 Default Term</li>
<li>然后打开偏好设置 Preference，选中 Keys，勾选 Hotkey 下的 Show/hide iTerm2 with a system-wide hotkey，将热键设置为 Command+. ，这样你就可以通过 Command+. 全局热键来打开或关闭 iTerm2 窗口，非常方便。</li>
<li>配色方案,我选用的是 <a href="http://ethanschoonover.com/solarized">solarized</a>，效果还不错。点开官网，下载，解压，然后打开 iTerm2 下的偏好设置 Preference ，点开 Profiles 下的 colors 选项，点击右下角的 Color Presets 选项，选择 import ，导入解压的 solarized 文件下的 Solarized Dark.itermcolors。</li>
<li>安装 oh-my-zsh。<br>Github 链接：<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></li>
</ul>
<p>使用 curl 安装：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者使用 wget 安装：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主题。<br>安装成功后，用 vim 打开隐藏文件 .zshrc ，修改主题为 agnoster：</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;agnoster&quot;</span></span><br></pre></td></tr></table></figure>

<p>应用这个主题需要特殊的字体支持，否则会出现乱码情况，这时我们来配置字体：</p>
<ol>
<li>使用 <a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo</a> 字体，点开连接点击 view raw 下载字体。</li>
<li>安装字体到系统字体册。</li>
<li>应用字体到 iTerm2 下，我自己喜欢将字号设置为 14 px，看着舒服（iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font）。</li>
<li>重新打开 iTerm2 窗口，这时便可以看到效果了。</li>
</ol>
<p>到这步我们的终端看上去已经非常好看了，这时我们来安装其它插件，让终端看起来更加风骚。</p>
<ul>
<li>自动提示命令。当我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。</li>
</ul>
<p>设置如下：</p>
<ol>
<li>克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下：</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用 vim 打开 .zshrc 文件，找到插件设置命令，默认是 plugins=(git) ，我们把它修改为:</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">plugins=(zsh-autosuggestions git)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重新打开终端窗口。</li>
</ol>
<p>PS：当你重新打开终端的时候可能看不到变化，可能你的字体颜色太淡了，我们把其改亮一些：</p>
<p>移动到 ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 路径下:</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>用 vim 打开 zsh-autosuggestions.zsh 文件，修改:</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=<span class="string">&#x27;fg=10&#x27;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>语法高亮。</li>
</ul>
<ol>
<li>使用 homebrew 安装 zsh-syntax-highlighting 插件。</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 .zshrc 文件，插入一行。</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>输入命令。</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>开始静静地装逼吧<br>(逃~</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>vim 是 Unix 平台上最常用的文本编辑器，因此对 vim 进行相应顺手的配置也非常重要。</p>
<p>Mac 的用户目录下没有默认的 .vimrc 配置文件，我们可以先 touch 一个空的 .vimrc 文件，然后在 vimrc 文件里进行相关的配置。</p>
<p>一般我使用的最简单的几个配置项如下：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">color desert <span class="string">&quot;颜色设置&quot;</span></span><br><span class="line">syntax on <span class="string">&quot;语法高亮&quot;</span></span><br><span class="line"><span class="built_in">set</span> number <span class="string">&quot;自动显示行号&quot;</span></span><br><span class="line"><span class="built_in">set</span> cursorline <span class="string">&quot;突出显示当前行&quot;</span></span><br><span class="line"><span class="built_in">set</span> ts=4 <span class="string">&quot;设置tab长度为4&quot;</span></span><br><span class="line"><span class="built_in">set</span> shiftwidth=4 <span class="string">&quot;设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4&quot;</span></span><br><span class="line"><span class="built_in">let</span> &amp;termencoding=&amp;encodingset fileencodings=utf-8,gbk <span class="string">&quot;解决中文编码乱码&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>Mac 上的 MySQL 安装配置简直就是大坑。</p>
<p>首先，最重要最重要的就是，一定不要用 homebrew 安装 MySQL，你会感受到无比的绝望~！！</p>
<h3 id="MySQL-配置环境变量"><a href="#MySQL-配置环境变量" class="headerlink" title="MySQL 配置环境变量"></a>MySQL 配置环境变量</h3><ul>
<li>首先要知道你使用的 Mac OS X 是什么样的 shell，使用命令</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure>

<p>如果输出的是：csh 或者是 tcsh，那么你用的就是 C Shell。</p>
<p>如果输出的是：bash，sh，zsh，那么你的用的可能就是 Bourne Shell 的一个变种。</p>
<p>Mac OS X 10.2 之前默认的是 C Shell。</p>
<p>Mac OS X 10.3 之后默认的是 Bourne Shell。</p>
<ul>
<li>打开终端，输入： cd ~</li>
</ul>
<p>会进入~文件夹</p>
<ul>
<li>然后输入：</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo vim .bash_profile</span><br></pre></td></tr></table></figure>

<p>回车执行，需要输入 root 用户密码。sudo 是使用 root 用户修改环境变量文件。</p>
<p>在文档的最下方输入：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:/usr/<span class="built_in">local</span>/mysql/bin</span><br></pre></td></tr></table></figure>

<p>然后 esc 退出 insert 状态，并在最下方输入 <code>:wq!</code> 保存退出。</p>
<ul>
<li>输入：</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>

<p>回车执行，运行环境变量。</p>
<ul>
<li><p>再输入 <code>mysql</code>，即可使用。</p>
</li>
<li><p>本人测试以后发现，上面的做法每次关掉终端在打开都需要重新 source .bash_profile。<br>于是</p>
</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>在这里面添加了：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:/usr/<span class="built_in">local</span>/mysql/bin</span><br></pre></td></tr></table></figure>

<p>保存后</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc </span><br></pre></td></tr></table></figure>

<p>这样的话就可以一劳永逸了。</p>
<h3 id="重设-MySQL-的-root-初始密码"><a href="#重设-MySQL-的-root-初始密码" class="headerlink" title="重设 MySQL 的 root 初始密码"></a>重设 MySQL 的 root 初始密码</h3><ul>
<li>停止 mysql server.  通常是在 <code>系统偏好设置</code> &gt; MySQL &gt; <code>Stop MySQL Server</code></li>
</ul>
<ul>
<li>打开终端，输入：</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe --skip-grant-tables</span><br></pre></td></tr></table></figure>

<ul>
<li>打开另一个新终端，输入:</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/mysql/bin/mysql -u root</span><br></pre></td></tr></table></figure>



<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET authentication_string=PASSWORD(<span class="string">&#x27;新密码&#x27;</span>) WHERE User=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重启 MySQL.</p>
</li>
<li><p>以上方法针对 MySQL V5.7.9，旧版的 MySQL 请使用：</p>
</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET Password=PASSWORD(<span class="string">&#x27;新密码&#x27;</span>) WHERE User=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><ul>
<li>不少 Mac 在第一次使用的时候，会出现这样的错误提示：</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">You must reset your password using ALTER USER statement before executing this statement.</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案如下：</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">SET PASSWORD = PASSWORD(<span class="string">&#x27;your new password&#x27;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NEVER;</span><br></pre></td></tr></table></figure>



<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>完成以上三步退出再登，使用新设置的密码就行了，以上除了 <code>your new password</code> 自己修改成新密码外，其他原样输入即可。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Mac 自带 git，我的 Mac 自带 2.13.5 版本，所以就省了 git 的安装。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="JDK-的安装"><a href="#JDK-的安装" class="headerlink" title="JDK 的安装"></a>JDK 的安装</h3><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html">Oracle 官网</a>，找到对应的 JDK 版本，下载安装即可。</p>
<p>安装完成以后，无须配置环境变量，直接可以运行相应的 java 命令。</p>
<h3 id="Maven的安装"><a href="#Maven的安装" class="headerlink" title="Maven的安装"></a>Maven的安装</h3><p>Maven 是现在 Java 项目管理的在开发过程中必不可少的工具。</p>
<p>利用前面我们安装好的 homebrew，很容易就可以安装上 Maven。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">brew install maven</span><br></pre></td></tr></table></figure>

<p>检查版本:</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>



<h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>Mac 自带 ruby，我的 Mac 自带 2.0.0p648 (2015-12-16 revision 53162) 版本，所以就省了 ruby 的安装。</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>Mac 自带 php，我的 Mac 自带 5.6.30 版本，所以就省了 php 的安装。</p>
<h3 id="Xdebug"><a href="#Xdebug" class="headerlink" title="Xdebug"></a>Xdebug</h3><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Mac 自带 python，我的 Mac 自带 2.7.10 版本，所以就省了 python 的安装。</p>
<p>1.Mac 系统已经默认安装好了python 2.7</p>
<p>2.安装 python 的包管理器 pip </p>
<p>先下载 get-pip.py <a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a> 执行命令安装</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo python get-pip.py</span><br></pre></td></tr></table></figure>

<p>3.安装virtualenv 。virtualenv 为每个不同项目提供一份 Python 安装。它并没有真正安装多个 Python 副本，但是它确实提供了一种巧妙的方式来让各项目环境保持独立。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br></pre></td></tr></table></figure>

<p>现在你只需要键入以下的命令来激活 virtualenv 中的 Flask:</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">pip install Flask</span><br></pre></td></tr></table></figure>



<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>目前 Python2.x 版本基本废弃，转向 Python3.x 版本。</p>
<p>推荐使用 Anaconda 来管理环境和相关的包。</p>
<p>这里挖个坑，以后另开 Python 版块详细介绍。</p>
<h2 id="Node-JS"><a href="#Node-JS" class="headerlink" title="Node.JS"></a>Node.JS</h2><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">brew install nodejs</span><br></pre></td></tr></table></figure>

<p>之后检查版本：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>



<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>



<h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><p>最近几年算法跟大数据方面最火的分布式框架非 Spark 莫属了。因为 Spark 的缘故，所以咱们得对 Scala 至少得混个脸熟。</p>
<p>因为安装了 homebrew，安装 Scala 就变得很 easy 了。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">brew install scala</span><br></pre></td></tr></table></figure>



<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><h2 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h2><h3 id="Xcode-addones"><a href="#Xcode-addones" class="headerlink" title="Xcode addones"></a>Xcode addones</h3><h2 id="JetBrains"><a href="#JetBrains" class="headerlink" title="JetBrains"></a>JetBrains</h2><p>Activation code</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CD4C1E7Z6V</span>-eyJsaWNlbnNlSWQiOiJDRDRDMUU<span class="number">3</span>WjZWIiwibGljZW<span class="number">5</span>zZWVOYW<span class="number">1</span>lIjoiRGVtZXRyaXVzIENvbnRyZXJhcyIsImFzc<span class="number">2</span>lnbmVlTmFtZSI<span class="number">6</span>IiIsImFzc<span class="number">2</span>lnbmVlRW<span class="number">1</span>haWwiOiIiLCJsaWNlbnNlUmVzdHJpY<span class="number">3</span>Rpb<span class="number">24</span>iOiJGb<span class="number">3</span>IgZWR<span class="number">1</span>Y<span class="number">2</span>F<span class="number">0</span>aW<span class="number">9</span>uYWwgdXNlIG<span class="number">9</span>ubHkiLCJjaGVja<span class="number">0</span>NvbmN<span class="number">1</span>cnJlbnRVc<span class="number">2</span>UiOmZhbHNlLCJwcm<span class="number">9</span>kdWN<span class="number">0</span>cyI<span class="number">6</span>W<span class="number">3</span>siY<span class="number">29</span>kZSI<span class="number">6</span>IkFDIiwicGFpZFVwVG<span class="number">8</span>iOiIyMDE<span class="number">4</span>LTAzLTEyIn<span class="number">0</span>seyJjb<span class="number">2</span>RlIjoiRE<span class="number">0</span>iLCJwYWlkVXBUbyI<span class="number">6</span>IjIwMTgtMDMtMTIifSx<span class="number">7</span>ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAxOC<span class="number">0</span>wMy<span class="number">0</span>xMiJ<span class="number">9</span>LHsiY<span class="number">29</span>kZSI<span class="number">6</span>IlJTMCIsInBhaWRVcFRvIjoiMjAxOC<span class="number">0</span>wMy<span class="number">0</span>xMiJ<span class="number">9</span>LHsiY<span class="number">29</span>kZSI<span class="number">6</span>IldTIiwicGFpZFVwVG<span class="number">8</span>iOiIyMDE<span class="number">4</span>LTAzLTEyIn<span class="number">0</span>seyJjb<span class="number">2</span>RlIjoiRFBOIiwicGFpZFVwVG<span class="number">8</span>iOiIyMDE<span class="number">4</span>LTAzLTEyIn<span class="number">0</span>seyJjb<span class="number">2</span>RlIjoiUkMiLCJwYWlkVXBUbyI<span class="number">6</span>IjIwMTgtMDMtMTIifSx<span class="number">7</span>ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOC<span class="number">0</span>wMy<span class="number">0</span>xMiJ<span class="number">9</span>LHsiY<span class="number">29</span>kZSI<span class="number">6</span>IkRDIiwicGFpZFVwVG<span class="number">8</span>iOiIyMDE<span class="number">4</span>LTAzLTEyIn<span class="number">0</span>seyJjb<span class="number">2</span>RlIjoiREIiLCJwYWlkVXBUbyI<span class="number">6</span>IjIwMTgtMDMtMTIifSx<span class="number">7</span>ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxOC<span class="number">0</span>wMy<span class="number">0</span>xMiJ<span class="number">9</span>LHsiY<span class="number">29</span>kZSI<span class="number">6</span>IlBDIiwicGFpZFVwVG<span class="number">8</span>iOiIyMDE<span class="number">4</span>LTAzLTEyIn<span class="number">0</span>seyJjb<span class="number">2</span>RlIjoiQ<span class="number">0</span>wiLCJwYWlkVXBUbyI<span class="number">6</span>IjIwMTgtMDMtMTIifV<span class="number">0</span>sImhhc<span class="number">2</span>giOiI<span class="number">1</span>NDc<span class="number">2</span>MjU<span class="number">1</span>LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF<span class="number">1</span>dG<span class="number">9</span>Qcm<span class="number">9</span>sb<span class="number">25</span>nYXRlZCI<span class="number">6</span>ZmFsc<span class="number">2</span>UsImlzQXV<span class="number">0</span>b<span class="number">1</span>Byb<span class="number">2</span>xvbmdhdGVkIjpmYWxzZX<span class="number">0</span>=-gnfWktLzZjpomv<span class="number">7</span>IR<span class="number">5</span>yOFM<span class="number">70</span>UCC<span class="number">9</span>fk<span class="number">6</span>yskvEBVtKRSZLoC+Pys<span class="number">880</span>dERQOTe<span class="number">443</span>osbEJVLhpediv/tC<span class="number">9</span>mIwJLGLJlvPr<span class="number">1</span>Ps<span class="number">3</span>ruV<span class="number">5</span>ugk/l<span class="number">1</span>PPYJeLnfVfYWNeOlCkt+GJSlwRqvo<span class="number">24</span>rGwWnGXosiZ<span class="number">35</span>juVzQHXcIMU<span class="number">6</span>ekkyiMrHXWb<span class="number">9</span>xMlwlJ<span class="number">1</span>Bm<span class="number">0</span>KwIddOnxCGi<span class="number">5</span>q<span class="number">17</span>qFc<span class="number">4</span>ArDNqACUS<span class="number">9</span>FkeKEHjV<span class="number">5</span>+xAs<span class="number">7</span>uJBW/QMGDwHq/eu<span class="number">7</span>mm<span class="number">7</span>x<span class="number">5</span>QUUA<span class="number">3</span>VbQUqHn/rcECDuNoMpQ<span class="number">8</span>tzrpS<span class="number">1</span>vFGQkthfVPcHREVudCJ/<span class="number">9</span>bJaE<span class="number">9</span>lIoa<span class="number">55</span>rgxWUPiOQDicygCsRlAiZoeu/WNSvaA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG<span class="number">9</span>w<span class="number">0</span>BAQsFADAYMRYwFAYDVQQDDA<span class="number">1</span>KZXRQcm<span class="number">9</span>maWxlIENBMB<span class="number">4</span>XDTE<span class="number">1</span>MTEwMjA<span class="number">4</span>MjE<span class="number">0</span>OFoXDTE<span class="number">4</span>MTEwMTA<span class="number">4</span>MjE<span class="number">0</span>OFowETEPMA<span class="number">0</span>GA<span class="number">1</span>UEAwwGcHJvZDN<span class="number">5</span>MIIBIjANBgkqhkiG<span class="number">9</span>w<span class="number">0</span>BAQEFAAOCAQ<span class="number">8</span>AMIIBCgKCAQEAxcQkq+zdxlR<span class="number">2</span>mmRYBPzGbUNdMN<span class="number">6</span>OaXiXzxIWtMEkrJMO/<span class="number">5</span>oUfQJbLLuMSMK<span class="number">0</span>QHFmaI<span class="number">37</span>WShyxZcfRCidwXjot<span class="number">4</span>zmNBKnlyHodDij/<span class="number">78</span>TmVqFl<span class="number">8</span>nOeD<span class="number">5</span>+<span class="number">07</span>B<span class="number">8</span>VEaIu<span class="number">7</span>c<span class="number">3</span>E<span class="number">1</span>N+e<span class="number">1</span>doC<span class="number">6</span>wht<span class="number">4</span>I<span class="number">4</span>+IEmtsPAdoaj<span class="number">5</span>WCQVQbrI<span class="number">8</span>KeT<span class="number">8</span>M<span class="number">9</span>VcBIWX<span class="number">7</span>fD<span class="number">0</span>fhexfg<span class="number">3</span>ZRt<span class="number">0</span>xqwMcXGNp<span class="number">3</span>DdJHiO<span class="number">0</span>rCdU+Itv<span class="number">7</span>EmtnSVq<span class="number">9</span>jBG<span class="number">1</span>usMSFvMowR<span class="number">25</span>mju<span class="number">2</span>JcPFp<span class="number">1</span>+I<span class="number">4</span>ZI+FqgR<span class="number">8</span>gyG<span class="number">8</span>oiNDyNEoAbsR<span class="number">3</span>lOpI<span class="number">7</span>grUYSvkB/xVy/VoklPCK<span class="number">2</span>h<span class="number">0</span>f<span class="number">0</span>GJxFjnye<span class="number">8</span>NT<span class="number">1</span>PAywoyl<span class="number">7</span>RmiAVRE/EKwIDAQABo<span class="number">4</span>GZMIGWMAkGA<span class="number">1</span>UdEwQCMAAwHQYDVR<span class="number">0</span>OBBYEFGEpG<span class="number">9</span>oZGcfLMGNBkY<span class="number">7</span>SgHiMGgTcMEgGA<span class="number">1</span>UdIwRBMD+AFKOetkhnQhI<span class="number">2</span>Qb<span class="number">1</span>t<span class="number">4</span>Lm<span class="number">0</span>oFKLl/GzoRykGjAYMRYwFAYDVQQDDA<span class="number">1</span>KZXRQcm<span class="number">9</span>maWxlIENBggkA<span class="number">0</span>myxg<span class="number">7</span>KDeeEwEwYDVR<span class="number">0</span>lBAwwCgYIKwYBBQUHAwEwCwYDVR<span class="number">0</span>PBAQDAgWgMA<span class="number">0</span>GCSqGSIb<span class="number">3</span>DQEBCwUAA<span class="number">4</span>ICAQC<span class="number">9</span>WZuYgQedSuOc<span class="number">5</span>TOUSrRigMw<span class="number">4</span>/+wuC<span class="number">5</span>EtZBfvdl<span class="number">4</span>HT/<span class="number">8</span>vzMW/oUlIP<span class="number">4</span>YCvA<span class="number">0</span>XKyBaCJ<span class="number">2</span>iX+ZCDKoPfiYXiaSiH+HxAPV<span class="number">6</span>J<span class="number">79</span>vvouxKrWg<span class="number">2</span>XV<span class="number">6</span>ShFtPLP+<span class="number">0</span>gPdGq<span class="number">3</span>x<span class="number">9</span>R<span class="number">3</span>+kJbmAm<span class="number">8</span>w+FOdlWqAfJrLvpzMGNeDU<span class="number">14</span>YGXiZ<span class="number">9</span>bVzmIQbwrBA+c/F<span class="number">4</span>tlK/DV<span class="number">07</span>dsNExihqFoibnqDiVNTGombaU<span class="number">2</span>dDup<span class="number">2</span>gwKdL<span class="number">81</span>ua<span class="number">8</span>EIcGNExHe<span class="number">82</span>kjF<span class="number">4</span>zwfadHk<span class="number">3</span>bQVvbfdAwxcDy<span class="number">4</span>xBjs<span class="number">3</span>L<span class="number">4</span>raPLU<span class="number">3</span>yenSzr/OEur<span class="number">1</span>+jfOxnQSmEcMXKXgrAQ<span class="number">9</span>U<span class="number">55</span>gwjcOFKrgOxEdek/Sk<span class="number">1</span>VfOjvS+nuM<span class="number">4</span>eyEruFMfaZHzoQiuw<span class="number">4</span>IqgGc<span class="number">45</span>ohFH<span class="number">0</span>UUyjYcuFxxDSU<span class="number">9</span>lMCv<span class="number">8</span>qdHKm+wnPRb<span class="number">0</span>l<span class="number">9</span>l<span class="number">5</span>vXsCBDuhAGYD<span class="number">6</span>ss+Ga+aDY<span class="number">6</span>f/qXZuUCEUOH<span class="number">3</span>QUNbbCUlviSz<span class="number">6</span>+GiRnt<span class="number">1</span>kA<span class="number">9</span>N<span class="number">2</span>Qachl+<span class="number">2</span>yBfaqUqr<span class="number">8</span>h<span class="number">7</span>Z<span class="number">2</span>gsx<span class="number">5</span>LcIf<span class="number">5</span>kYNsqJ<span class="number">0</span>GavXTVyWh<span class="number">7</span>PYiKX<span class="number">4</span>bs<span class="number">354</span>ZQLUwwa/cG++<span class="number">2</span>+wNWP+HtBhVxMRNTdVhSm<span class="number">38</span>AknZlD+PTAsWGu<span class="number">9</span>GyLmhti<span class="number">2</span>EnVwGybSD<span class="number">2</span>Dxmhxk<span class="number">3</span>IPCkhKAK+pl<span class="number">0</span>eWYGZWG<span class="number">3</span>tJ<span class="number">9</span>mZ<span class="number">7</span>SowcXLWDFAk<span class="number">0</span>lRJnKGFMTggrWjV<span class="number">8</span>GYpw<span class="number">5</span>bq<span class="number">23</span>VmIqqDLgkNzuoog==</span><br></pre></td></tr></table></figure>

<h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>现在很多激活码都失效了。</p>
<p>教大家一个永久试用的方法：</p>
<ul>
<li><p>任何一个 JB 家的 IDE 中打开 Preference -&gt; Plugins -&gt; Setting（Installed 右边的小齿轮） -&gt; Manage Plugin Repositories</p>
</li>
<li><p>新增 <code>https://plugins.zhile.io</code></p>
</li>
<li><p>返回 Marketplace，搜索 <code>IDE Eval Reset</code>，安装并重启 IDE</p>
</li>
<li><p>打开后，菜单栏 Help 中，最下面就是 Eval Reset，可以设置每次重启自动刷新试用时间，即可无限期试用</p>
</li>
</ul>
<h1 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h1><h2 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h2><p>对于 RD 同学来说，习惯、顺手的文本编辑器也是非常重要的一个工具。</p>
<p>我一直用 Sublime，用的时间也比较长了，感觉还不错。</p>
<p>Sublime 的官网地址：<a href="https://www.sublimetext.com/">https://www.sublimetext.com/</a>。</p>
<p>去官网下载，安装即可。</p>
<h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><h1 id="VIrtual-Machine"><a href="#VIrtual-Machine" class="headerlink" title="VIrtual Machine"></a>VIrtual Machine</h1><h2 id="VMware-Fusion"><a href="#VMware-Fusion" class="headerlink" title="VMware Fusion"></a>VMware Fusion</h2><h2 id="Mac-Kali-Lnux-Win10"><a href="#Mac-Kali-Lnux-Win10" class="headerlink" title="Mac + Kali Lnux + Win10"></a>Mac + Kali Lnux + Win10</h2><h1 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h1><h2 id="FireFox"><a href="#FireFox" class="headerlink" title="FireFox"></a>FireFox</h2><h3 id="FireFox-addones"><a href="#FireFox-addones" class="headerlink" title="FireFox addones"></a>FireFox addones</h3><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><h3 id="Chrome-addones"><a href="#Chrome-addones" class="headerlink" title="Chrome addones"></a>Chrome addones</h3><h2 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h2><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p>Shadowsocks</p>
<p><a href="https://github.com/shadowsocks/shadowsocks-gui">https://github.com/shadowsocks/shadowsocks-gui</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>教程</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>todoList</title>
    <url>/articles/todoList.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Github-Hexo-搭建个人博客，主题配置"><a href="#Github-Hexo-搭建个人博客，主题配置" class="headerlink" title="Github + Hexo 搭建个人博客，主题配置"></a>Github + Hexo 搭建个人博客，主题配置</h1><p><a href="http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">参考链接</a> </p>
<span id="more"></span>

<h2 id="清理工作"><a href="#清理工作" class="headerlink" title="清理工作"></a>清理工作</h2><p>之前既然搭建失败了，那么删掉 Github 项目和本地文件夹。然后从0开始，重新搭建。</p>
<h2 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>检测方式，查看版本号：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>



<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>



<h2 id="本地文件夹"><a href="#本地文件夹" class="headerlink" title="本地文件夹"></a>本地文件夹</h2><p>新创建一个本地文件夹，我是命名成 myBlog，符合命名规则，看起来舒服一点。之后进入文件夹，操作都在文件夹中。</p>
<h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>安装</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>部署过程，生成静态页面</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>或简写：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>本地启动服务器</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>浏览器进入<br><a href="http://localhost:4000/">http://localhost:4000/</a></p>
<h2 id="Github-配置"><a href="#Github-配置" class="headerlink" title="Github 配置"></a>Github 配置</h2><p>新建仓库，命名为：<br>username.github.io</p>
<p>去<strong>站点配置文件</strong>_config.yml中：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>然后安装提交插件：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>进行第一次提交：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>或者简写：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>这时候访问你的主页就好</p>
<p><a href="http://username.github.io/">http://username.github.io</a></p>
<p><strong>以下是部署常用命令</strong></p>
<p>hexo clean 清除原配置</p>
<p>hexo generate 部署</p>
<p>hexo deploy 提交</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>选择自己喜欢的主题，然后阅读 README.md 文档，因为不同的主题有各自不同的安装配置方法，并不是通用的。</p>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>头像、图标等配置，页面语言、风格等配置，自己参照之前的网址。</p>
<h2 id="创作"><a href="#创作" class="headerlink" title="创作"></a>创作</h2><p>常用命令自己看吧，都不难。</p>
<h1 id="Kali-Win10-虚拟机"><a href="#Kali-Win10-虚拟机" class="headerlink" title="Kali + Win10 虚拟机"></a>Kali + Win10 虚拟机</h1><h1 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h1><h1 id="PHP-黑魔法"><a href="#PHP-黑魔法" class="headerlink" title="PHP 黑魔法"></a>PHP 黑魔法</h1><h1 id="Python-脚本"><a href="#Python-脚本" class="headerlink" title="Python 脚本"></a>Python 脚本</h1><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h2 id="技术层面"><a href="#技术层面" class="headerlink" title="技术层面"></a>技术层面</h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><h3 id="分布式处理技术"><a href="#分布式处理技术" class="headerlink" title="分布式处理技术"></a>分布式处理技术</h3><h3 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h3><h3 id="感知技术"><a href="#感知技术" class="headerlink" title="感知技术"></a>感知技术</h3><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="互联网大数据"><a href="#互联网大数据" class="headerlink" title="互联网大数据"></a>互联网大数据</h3><h3 id="政府大数据"><a href="#政府大数据" class="headerlink" title="政府大数据"></a>政府大数据</h3><h3 id="企业大数据"><a href="#企业大数据" class="headerlink" title="企业大数据"></a>企业大数据</h3><h3 id="个人大数据"><a href="#个人大数据" class="headerlink" title="个人大数据"></a>个人大数据</h3><h2 id="发展方向"><a href="#发展方向" class="headerlink" title="发展方向"></a>发展方向</h2><h3 id="机器学习-gt-人工智能"><a href="#机器学习-gt-人工智能" class="headerlink" title="机器学习-&gt;人工智能"></a>机器学习-&gt;人工智能</h3><h1 id="未来研究方向，车载系统安全漏洞"><a href="#未来研究方向，车载系统安全漏洞" class="headerlink" title="未来研究方向，车载系统安全漏洞"></a>未来研究方向，车载系统安全漏洞</h1><ul>
<li><p>远程控制网络（39%）</p>
</li>
<li><p>本地网络软件（17%）</p>
</li>
<li><p>车载蜂窝网络（16%）</p>
</li>
<li><p>CAN网络总线（10%）</p>
</li>
<li><p>USB（通用串行总线）设备（13%）</p>
</li>
<li><p>车载网络系统串口复制软件Serial（5%）</p>
</li>
<li><p>……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>Plan</tag>
      </tags>
  </entry>
</search>
